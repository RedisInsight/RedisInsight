version: 2.1

aliases:
  keychain: &keychain
    run:
      name: Add cert to the keychain
      command: |
        security create-keychain -p mysecretpassword $KEYCHAIN
        security default-keychain -s $KEYCHAIN
        security unlock-keychain -p mysecretpassword $KEYCHAIN
        security set-keychain-settings -u -t 10000000 $KEYCHAIN
        security import certs/mac-developer.p12 -k $KEYCHAIN -P "$CSC_KEY_PASSWORD" -T /usr/bin/codesign -T /usr/bin/productbuild
        security import certs/mas-distribution.p12 -k $KEYCHAIN -P "$CSC_MAS_PASSWORD" -T /usr/bin/codesign -T /usr/bin/productbuild
        security import certs/mac-installer.p12 -k $KEYCHAIN -P "$CSC_MAC_INSTALLER_PASSWORD" -T /usr/bin/codesign -T /usr/bin/productbuild
        security set-key-partition-list -S apple-tool:,apple: -s -k mysecretpassword $KEYCHAIN
      environment:
        KEYCHAIN: redisinsight.keychain
  import: &import
    run:
      name: User certutil to import certificate
      command: certutil -p %WIN_CSC_KEY_PASSWORD% -importpfx certs\redislabs_win.pfx
      shell: cmd.exe
  sign: &sign
    run:
      name: Sign application
      command: |
        $filePath = $(Get-ChildItem release -Filter Redis-Insight*.exe | % { $_.FullName })
        $filePathWithQuotes = '"{0}"' -f $filePath
        & "C:\Program Files (x86)\Windows Kits\10\bin\10.0.19041.0\x86\signtool.exe" sign /a /sm /n "Redis Labs Inc." /fd sha256 /tr http://sha256timestamp.ws.symantec.com/sha256/timestamp /v $FilePathWithQuotes
      shell: powershell.exe
  fileScan: &fileScan
    run:
      name: Virustotal file scan
      command: &virusfilescan |
        uploadUrl=$(curl -sq -XGET https://www.virustotal.com/api/v3/files/upload_url -H "x-apikey: $VIRUSTOTAL_API_KEY" | jq -r '.data')
        uploadFile=$("/usr/bin/find" /tmp/release -name ${FILE_NAME})
        echo "File to upload: ${uploadFile}"
        analysedId=$(curl -sq -XPOST "${uploadUrl}" -H "x-apikey: $VIRUSTOTAL_API_KEY" --form file=@"${uploadFile}" | jq -r '.data.id')
        if [ $analysedId == "null" ]; then
          echo 'Status is null, something went wrong'; exit 1;
        fi
        echo "export ANALYZED_ID=${analysedId}" >> $BASH_ENV
        echo "Virustotal Analyzed id: ${analysedId}"
        sleep 10
      shell: /bin/bash
  urlScan: &urlScan
    run:
      name: Virustotal url scan
      command: &virusurlscan |
        echo "Url to check: ${URL}"

        analysedId=$(curl -sq -XPOST https://www.virustotal.com/api/v3/urls -H "x-apikey: $VIRUSTOTAL_API_KEY" --form url=${URL} | jq -r '.data.id')

        if [ $analysedId == "null" ]; then
          echo 'Status is null, something went wrong'; exit 1;
        fi
        echo "export ANALYZED_ID=${analysedId}" >> $BASH_ENV
        echo "Virustotal Analyzed id: ${analysedId}"
        sleep 10
      shell: /bin/bash
  validate: &validate
    run:
      name: Virustotal validate scan results
      command: &virusValidate |
        analyzeStatus=$(curl -sq -XGET https://www.virustotal.com/api/v3/analyses/${ANALYZED_ID} -H "x-apikey: $VIRUSTOTAL_API_KEY" | jq -r '.data.attributes.status')
        if [ $analyzeStatus == "null" ]; then
          echo 'Status is null, something went wrong'; exit 1;
        fi

        currentOperation="50"
        until [ "$currentOperation" == "0" ]; do
          if [ "$analyzeStatus" == "completed" ]
          then
            echo "Current status: ${analyzeStatus}"; break;
          else
            echo "Current status: ${analyzeStatus}, retries left: ${currentOperation} ";
            analyzeStatus=$(curl -sq -XGET https://www.virustotal.com/api/v3/analyses/${ANALYZED_ID} -H "x-apikey: $VIRUSTOTAL_API_KEY" | jq -r '.data.attributes.status');
            sleep 20;
            currentOperation=$[$currentOperation - 1];
          fi
        done

        analyzeStats=$(curl -sq -XGET https://www.virustotal.com/api/v3/analyses/${ANALYZED_ID} -H "x-apikey: $VIRUSTOTAL_API_KEY" | jq -r '.data.attributes.stats')
        analazedHarmless=$(echo ${analyzeStats} | jq '.harmless')
        analazedMalicious=$(echo ${analyzeStats} | jq '.malicious')
        analazedSuspicious=$(echo ${analyzeStats} | jq '.suspicious')

        if [ "$analyzeStatus" != "completed" ]; then
          echo 'Analyse is not completed'; exit 1;
        fi
        echo "Results:"
        echo "analazedHarmless: ${analazedHarmless}, analazedMalicious:  ${analazedMalicious}, analazedSuspicious: ${analazedSuspicious}"

        if [ "$analazedMalicious" != "0" ] || [ "$analazedSuspicious" != "0" ]; then
          echo "export VIRUS_CHECK_FAILED=true" >> $BASH_ENV
          echo 'Found dangers'; exit 0;
        fi

        echo "export VIRUS_CHECK_FAILED=false" >> $BASH_ENV
        echo "export SKIP_VIRUSTOTAL_REPORT=true" >> $BASH_ENV
        echo 'Passed';
      shell: /bin/bash
      no_output_timeout: 15m
  virustotalReport: &virustotalReport
    run:
      name: Virustotal slack report
      command: &virusreport |
        if [ "$SKIP_VIRUSTOTAL_REPORT" == "true" ]; then
          exit 0;
        fi

        FILE_NAME=virustotal.report.json
        BUILD_NAME=$BUILD_NAME FILE_NAME=$FILE_NAME VIRUS_CHECK_FAILED=$VIRUS_CHECK_FAILED node .circleci/virustotal-report.js &&
        curl -H "Content-type: application/json" --data @$FILE_NAME -H "Authorization: Bearer ${SLACK_TEST_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage

        if [ "$VIRUS_CHECK_FAILED" == "true" ]; then
          echo 'Found dangers'; exit 1;
        fi
      shell: /bin/bash
  iTestsNames: &iTestsNames
    - oss-st-5            # OSS Standalone v5
    - oss-st-5-pass       # OSS Standalone v5 with admin pass required
    - oss-st-6            # OSS Standalone v6 and all modules
    # TODO: Investigate why it randomly fails
    # - oss-st-big          # OSS Standalone v6 and all modules and predefined amount of data inside (~3-4M)
    - mods-preview        # OSS Standalone and all preview modules
    - oss-st-6-tls        # OSS Standalone v6 with TLS enabled
    - oss-st-6-tls-auth   # OSS Standalone v6 with TLS auth required
#    - oss-st-6-tls-auth-ssh   # OSS Standalone v6 with TLS auth required through ssh
    - oss-clu             # OSS Cluster
    - oss-clu-tls         # OSS Cluster with TLS enabled
    - oss-sent            # OSS Sentinel
    - oss-sent-tls-auth   # OSS Sentinel with TLS auth
    - re-st               # Redis Enterprise with Standalone inside
    - re-clu              # Redis Enterprise with Cluster inside
    - re-crdt             # Redis Enterprise with active-active database inside
  iTestsNamesShort: &iTestsNamesShort
    - oss-st-5-pass       # OSS Standalone v5 with admin pass required
    - oss-st-6-tls-auth   # OSS Standalone v6 with TLS auth required
    - oss-clu-tls         # OSS Cluster with TLS enabled
    - re-crdt             # Redis Enterprise with active-active database inside
    - oss-sent-tls-auth   # OSS Sentinel with TLS auth
  guides-filter: &guidesFilter
    filters:
      branches:
        only:
          - guides
  dev-filter: &devFilter
    filters:
      branches:
        only:
          - main
          - /^build\/.*/
  stage-filter: &stageFilter
    filters:
      branches:
        only:
          - /^release.*/
  prod-filter: &prodFilter
    filters:
      branches:
        only:
          - latest
  ui-deps-cache-key: &uiDepsCacheKey
    key: v1-ui-deps-{{ checksum "yarn.lock" }}
  api-deps-cache-key: &apiDepsCacheKey
    key: v1-ui-deps-{{ checksum "redisinsight/api/yarn.lock" }}
  manual-build-conditions: &manual-build-conditions
    or:
      - << pipeline.parameters.linux >>
      - << pipeline.parameters.mac >>
      - << pipeline.parameters.windows >>
      - << pipeline.parameters.docker >>
  ignore-for-manual-build: &ignore-for-manual-build
    when:
      not: *manual-build-conditions

orbs:
  win: circleci/windows@2.4.1
  node: circleci/node@5.2.0
  aws: circleci/aws-cli@2.0.3

executors:
  linux-executor:
    machine:
      image: ubuntu-2004:2023.04.2
  linux-executor-dlc:
    machine:
      image: ubuntu-2004:2023.04.2
      docker_layer_caching: true
  docker-node:
    docker:
      - image: cimg/node:20.15
  docker:
    docker:
      - image: cibuilds/docker:19.03.5
  macos:
    macos:
      xcode: 14.2.0

parameters:
  linux:
    type: string
    default: &ignore ""
  mac:
    type: string
    default: *ignore
  windows:
    type: string
    default: *ignore
  docker:
    type: string
    default: *ignore
  redis_client:
    type: string
    default: ""
  env:
    type: string
    default: "stage"

jobs:
  # Test jobs
  unit-tests-ui:
    executor: docker-node
    steps:
      - checkout
      - restore_cache:
          <<: *uiDepsCacheKey
      - run:
          name: UI PROD dependencies audit
          command: |
            FILENAME=ui.prod.deps.audit.json
            yarn audit --groups dependencies --json > $FILENAME || true &&
            FILENAME=$FILENAME DEPS="UI prod" node .circleci/deps-audit-report.js &&
            curl -H "Content-type: application/json" --data @slack.$FILENAME -H "Authorization: Bearer ${SLACK_AUDIT_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage
      - run:
          name: UI DEV dependencies audit
          command: |
            FILENAME=ui.dev.deps.audit.json
            yarn audit --groups devDependencies --json > $FILENAME || true &&
            FILENAME=$FILENAME DEPS="UI dev" node .circleci/deps-audit-report.js &&
            curl -H "Content-type: application/json" --data @slack.$FILENAME -H "Authorization: Bearer ${SLACK_AUDIT_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage
      - run:
          name: Code analysis
          command: |
            SKIP_POSTINSTALL=1 yarn install

            FILENAME=ui.lint.audit.json
            WORKDIR="."
            yarn lint:ui -f json -o $FILENAME || true &&
            FILENAME=$FILENAME WORKDIR=$WORKDIR TARGET="UI" node .circleci/lint-report.js &&
            curl -H "Content-type: application/json" --data @$WORKDIR/slack.$FILENAME -H "Authorization: Bearer ${SLACK_AUDIT_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage

            FILENAME=rest.lint.audit.json
            yarn lint -f json -o $FILENAME || true &&
            FILENAME=$FILENAME WORKDIR=$WORKDIR TARGET="REST" node .circleci/lint-report.js &&
            curl -H "Content-type: application/json" --data @$WORKDIR/slack.$FILENAME -H "Authorization: Bearer ${SLACK_AUDIT_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage
      - run:
          name: Unit tests UI
          command: |
            yarn test:cov --ci --silent
      - save_cache:
          <<: *uiDepsCacheKey
          paths:
            - ./node_modules
  unit-tests-api:
    executor: docker-node
    steps:
      - checkout
      - restore_cache:
          <<: *apiDepsCacheKey
      - run:
          name: API PROD dependencies scan
          command: |
            FILENAME=api.prod.deps.audit.json
            yarn --cwd redisinsight/api audit --groups dependencies --json > $FILENAME || true &&
            FILENAME=$FILENAME DEPS="API prod" node .circleci/deps-audit-report.js &&
            curl -H "Content-type: application/json" --data @slack.$FILENAME -H "Authorization: Bearer ${SLACK_AUDIT_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage
      - run:
          name: API DEV dependencies scan
          command: |
            FILENAME=api.dev.deps.audit.json
            yarn --cwd redisinsight/api audit --groups devDependencies --json > $FILENAME || true &&
            FILENAME=$FILENAME DEPS="API dev" node .circleci/deps-audit-report.js &&
            curl -H "Content-type: application/json" --data @slack.$FILENAME -H "Authorization: Bearer ${SLACK_AUDIT_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage
      - run:
          name: Code analysis
          command: |
            yarn --cwd redisinsight/api

            FILENAME=api.lint.audit.json
            WORKDIR="./redisinsight/api"
            yarn lint:api -f json -o $FILENAME || true &&
            FILENAME=$FILENAME WORKDIR=$WORKDIR TARGET="API" node .circleci/lint-report.js &&
            curl -H "Content-type: application/json" --data @$WORKDIR/slack.$FILENAME -H "Authorization: Bearer ${SLACK_AUDIT_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage
      - run:
          name: Unit tests API
          command: |
            yarn --cwd redisinsight/api/ test:cov --ci
      - save_cache:
          <<: *apiDepsCacheKey
          paths:
            - ./redisinsight/api/node_modules
  integration-tests-run:
    executor: linux-executor-dlc
    parameters:
      rte:
        description: Redis Test Environment name
        type: string
      build:
        description: Backend build to run tests over
        type: enum
        default: local
        enum: ['local', 'docker', 'saas']
      report:
        description: Send report for test run to slack
        type: boolean
        default: false
      redis_client:
        description: Library to use for redis connection
        type: string
        default: ""
    steps:
      - checkout
      - restore_cache:
          <<: *apiDepsCacheKey
      - when:
          condition:
            equal: [ 'docker', << parameters.build >> ]
          steps:
            - attach_workspace:
                at: /tmp
            - run:
                name: Load built docker image from workspace
                command: |
                  docker image load -i /tmp/release/docker/docker-linux-alpine.amd64.tar
      - run:
          name: Run tests
          command: |
            if [ << parameters.redis_client >> != "" ]; then
              export RI_REDIS_CLIENTS_FORCE_STRATEGY=<< parameters.redis_client >>
            fi

            ./redisinsight/api/test/test-runs/start-test-run.sh -r << parameters.rte >> -t << parameters.build >>
            mkdir -p mkdir itest/coverages && mkdir -p itest/results
            cp ./redisinsight/api/test/test-runs/coverage/test-run-result.json ./itest/results/<< parameters.rte >>.result.json
            cp ./redisinsight/api/test/test-runs/coverage/test-run-result.xml ./itest/results/<< parameters.rte >>.result.xml
            cp ./redisinsight/api/test/test-runs/coverage/test-run-coverage.json ./itest/coverages/<< parameters.rte >>.coverage.json
      - when:
          condition:
            equal: [ true, << parameters.report >> ]
          steps:
            - run:
                name: Send report
                when: always
                command: |
                  ITEST_NAME=<< parameters.rte >> node ./.circleci/itest-results.js
                  curl -H "Content-type: application/json" --data @itests.report.json -H "Authorization: Bearer $SLACK_TEST_REPORT_KEY" -X POST https://slack.com/api/chat.postMessage
      - store_test_results:
          path: ./itest/results
      - persist_to_workspace:
          root: .
          paths:
            - ./itest/results/<< parameters.rte >>.result.json
            - ./itest/coverages/<< parameters.rte >>.coverage.json
  integration-tests-coverage:
    executor: linux-executor
    steps:
      - checkout
      - attach_workspace:
          at: /tmp
      - run:
          name: Calculate coverage across all tests runs
          command: |
            sudo mkdir -p /usr/src/app
            sudo cp -a ./redisinsight/api/. /usr/src/app/
            sudo cp -R /tmp/itest/coverages /usr/src/app && sudo chmod 777 -R /usr/src/app
            cd /usr/src/app && npx nyc report -t ./coverages -r text -r text-summary
  e2e-app-image:
    executor: linux-executor-dlc
    parameters:
      report:
        description: Send report for test run to slack
        type: boolean
        default: false
      parallelism:
        description: Number of threads to run tests
        type: integer
        default: 1
    parallelism: << parameters.parallelism >>
    steps:
      - checkout
      - node/install:
          install-yarn: true
          node-version: '20.15'
      - attach_workspace:
          at: .
      - run: sudo apt-get install net-tools
      - run: sudo apt-get install xdotool
      - run: sudo apt-get install -y desktop-file-utils
      - run:
          name: Install Google Chrome
          command: |
            wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -
            sudo sh -c 'echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" >> /etc/apt/sources.list.d/google-chrome.list'
            sudo apt-get update
            sudo apt-get install -y google-chrome-stable
            sudo apt-get install -y \
            libnss3 \
            libgconf-2-4 \
            libxss1 \
            libasound2
            xdg-settings set default-web-browser google-chrome.desktop
      - run:
          name: Install WM
          command: sudo apt install fluxbox
      - run:
          name: Install Xvfb
          command: sudo apt-get install -y xvfb
      - run:
          name: Start Xvfb
          command: |
            if [ -f /tmp/.X99-lock ]; then rm /tmp/.X99-lock; fi
            Xvfb :99 -ac -screen 0 1920x1080x24 &
            sleep 3
            fluxbox &
            export DISPLAY=:99
            echo $DISPLAY
      # - run:
      #     name: Download Chrome Profile
      #     command: |
      #       curl -O $E2E_USER_PROFILE_LINK
      #       tar -xvzf chrome-profile.tar.gz -C tests/e2e/test-data
      # - run:
      #     name: Clone mocked RDI server
      #     command: |
      #       git clone https://$GH_RDI_MOCKED_SERVER_KEY@github.com/RedisInsight/RDI_server_mocked.git tests/e2e/rte/rdi
      - run:
          name: .AppImage tests
          command: |
            cd tests/e2e && export TEST_FILES=$(circleci tests glob "tests/electron/**/*.e2e.ts" | circleci tests split --split-by=timings) && cd ../..
            .circleci/e2e/test.app-image.sh
      - run:
          name: Archive and Save Google Chrome User Data
          when: always
          command: |
            tar -czvf chrome-user-data.tar.gz -C "$HOME/.config" google-chrome
            mkdir -p tests/e2e/report
            mv chrome-user-data.tar.gz tests/e2e/report/
      - when:
          condition:
            equal: [ true, << parameters.report >> ]
          steps:
            - run:
                name: Send report
                when: always
                command: |
                  APP_BUILD_TYPE="Electron (Linux)" node ./.circleci/e2e-results.js
                  curl -H "Content-type: application/json" --data @e2e.report.json -H "Authorization: Bearer $SLACK_TEST_REPORT_KEY" -X POST https://slack.com/api/chat.postMessage
      - store_test_results:
          path: ./tests/e2e/results
      - store_artifacts:
          path: tests/e2e/report
          destination: tests/e2e/report
  e2e-exe:
    executor:
      name: win/default
    parameters:
      report:
        description: Send report for test run to slack
        type: boolean
        default: false
      parallelism:
        description: Number of threads to run tests
        type: integer
        default: 1
    parallelism: << parameters.parallelism >>
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run:
          command: |
            nvm install 20.15
            nvm use 20.15
            npm install --global yarn
      - run:
          command: |
            cd tests/e2e && export TEST_FILES=$(circleci tests glob "tests/electron/**/*.e2e.ts" | circleci tests split --split-by=timings) && cd ../..
            .circleci/e2e/test.exe.cmd
          shell: bash.exe
      - when:
          condition:
            equal: [ true, << parameters.report >> ]
          steps:
            - run:
                name: Send report
                when: always
                command: |
                  APP_BUILD_TYPE="Electron (Windows)" node ./.circleci/e2e-results.js
                  curl -H "Content-type: application/json" --data @e2e.report.json -H "Authorization: Bearer $SLACK_TEST_REPORT_KEY" -X POST https://slack.com/api/chat.postMessage
                shell: bash.exe
      - store_test_results:
          path: ./tests/e2e/results
      - store_artifacts:
          path: tests/e2e/report
          destination: tests/e2e/report
  e2e-tests:
    executor: linux-executor-dlc
    parameters:
      build:
        description: Backend build to run tests over
        type: enum
        default: local
        enum: ['local', 'docker']
      report:
        description: Send report for test run to slack
        type: boolean
        default: false
      parallelism:
        description: Number of threads to run tests
        type: integer
        default: 1
    parallelism: << parameters.parallelism >>
    steps:
      - checkout
      - when:
          condition:
            equal: [ 'docker', << parameters.build >> ]
          steps:
            - attach_workspace:
                at: /tmp
            - run:
                name: Load built docker image from workspace
                command: |
                  docker image load -i /tmp/release/docker/docker-linux-alpine.amd64.tar
            # - run:
            #     name: Clone mocked RDI server
            #     command: |
            #       git clone https://$GH_RDI_MOCKED_SERVER_KEY@github.com/RedisInsight/RDI_server_mocked.git tests/e2e/rte/rdi
            - run:
                name: Run tests
                command: |
                  cd tests/e2e && export TEST_FILES=$(circleci tests glob "tests/web/**/*.e2e.ts" | circleci tests split --split-by=timings) && cd ../..
                  TEST_BIG_DB_DUMP=$TEST_BIG_DB_DUMP \
                  RI_SERVER_TLS_CERT="$RI_SERVER_TLS_CERT" \
                  RI_SERVER_TLS_KEY="$RI_SERVER_TLS_KEY" \
                  docker-compose \
                  -f tests/e2e/rte.docker-compose.yml \
                  -f tests/e2e/docker.web.docker-compose.yml \
                  up --abort-on-container-exit --force-recreate --build
                no_output_timeout: 5m
      - when:
          condition:
            equal: [ 'local', << parameters.build >> ]
          steps:
            - run:
                name: Run tests
                command: |
                  cd tests/e2e && export TEST_FILES=$(circleci tests glob "tests/web/**/*.e2e.ts" | circleci tests split --split-by=timings) && cd ../..
                  TEST_BIG_DB_DUMP=$TEST_BIG_DB_DUMP \
                  RI_SERVER_TLS_CERT="$RI_SERVER_TLS_CERT" \
                  RI_SERVER_TLS_KEY="$RI_SERVER_TLS_KEY" \
                  docker-compose \
                  -f tests/e2e/rte.docker-compose.yml \
                  -f tests/e2e/local.web.docker-compose.yml \
                  up --abort-on-container-exit --force-recreate
                no_output_timeout: 5m
      - when:
          condition:
            equal: [ true, << parameters.report >> ]
          steps:
            - run:
                name: Send report
                when: always
                command: |
                  node ./.circleci/e2e-results.js
                  curl -H "Content-type: application/json" --data @e2e.report.json -H "Authorization: Bearer $SLACK_TEST_REPORT_KEY" -X POST https://slack.com/api/chat.postMessage
      - store_test_results:
          path: ./tests/e2e/results
      - store_artifacts:
          path: tests/e2e/report
          destination: tests/e2e/report

  # Build jobs
  manual-build-validate:
    executor: docker-node
    parameters:
      os:
        type: string
        default: ""
      target:
        type: string
        default: ""
    steps:
      - checkout
      - run:
          command: |
            node .circleci/build/manual-build-validate.js << parameters.os >> << parameters.target >>
  setup-sign-certificates:
    executor: linux-executor
    steps:
      - run:
          name: Setup sign certificates
          command: |
            mkdir -p certs
            echo "$CSC_P12_BASE64" | base64 -id > certs/mac-developer.p12
            echo "$CSC_MAC_INSTALLER_P12_BASE64" | base64 -id > certs/mac-installer.p12
            echo "$CSC_MAS_P12_BASE64" | base64 -id > certs/mas-distribution.p12
            echo "$WIN_CSC_PFX_BASE64" | base64 -id > certs/redislabs_win.pfx
      - persist_to_workspace:
          root: .
          paths:
            - certs
  setup-build:
    executor: docker
    parameters:
      env:
        description: Build environment (stage || prod)
        type: enum
        default: stage
        enum: [ 'dev', 'stage', 'prod' ]
    steps:
      - checkout
      - run:
          command: |
            mkdir electron

            CURRENT_VERSION=$(jq -r ".version" redisinsight/package.json)
            echo "Build version: $CURRENT_VERSION"
            cp ./redisinsight/package.json ./electron/package.json
            echo "$VERSION" > electron/version
            exit 0

      - persist_to_workspace:
          root: /root/project
          paths:
            - electron
  linux:
    executor: linux-executor
    resource_class: large
    parameters:
      env:
        description: Build environment (stage || prod)
        type: enum
        default: stage
        enum: ['stage', 'prod', 'dev']
      target:
        description: Build target
        type: string
        default: ""
    steps:
      - checkout
      - node/install:
          install-yarn: true
          node-version: '20.15'
      - attach_workspace:
          at: .
      - run:
          command: |
            cp ./electron/package.json ./redisinsight/
      - run:
          name: install dependencies
          command: |
            sudo apt-get update -y && sudo apt-get install -y rpm flatpak flatpak-builder ca-certificates
            flatpak remote-add --user --if-not-exists flathub https://dl.flathub.org/repo/flathub.flatpakrepo
            flatpak install flathub --no-deps --arch x86_64 --assumeyes \
            runtime/org.freedesktop.Sdk/x86_64/20.08 \
            runtime/org.freedesktop.Platform/x86_64/20.08 \
            org.electronjs.Electron2.BaseApp/x86_64/20.08

            yarn --cwd redisinsight/api/ install --ignore-optional
            yarn --cwd redisinsight/ install --ignore-optional
            yarn install
          no_output_timeout: 15m
      - run:
          name: Install plugins dependencies and build plugins
          command: |
            yarn build:statics
          no_output_timeout: 15m
      - run:
          name: Build linux AppImage and deb
          command: |
            if [ << parameters.env >> == 'prod' ]; then
              yarn package:prod
              exit 0;
            fi

            export RI_CLOUD_IDP_AUTHORIZE_URL=$RI_CLOUD_IDP_AUTHORIZE_URL_STAGE
            export RI_CLOUD_IDP_TOKEN_URL=$RI_CLOUD_IDP_TOKEN_URL_STAGE
            export RI_CLOUD_IDP_ISSUER=$RI_CLOUD_IDP_ISSUER_STAGE
            export RI_CLOUD_IDP_CLIENT_ID=$RI_CLOUD_IDP_CLIENT_ID_STAGE
            export RI_CLOUD_IDP_REDIRECT_URI=$RI_CLOUD_IDP_REDIRECT_URI_STAGE
            export RI_CLOUD_IDP_GOOGLE_ID=$RI_CLOUD_IDP_GOOGLE_ID_STAGE
            export RI_CLOUD_IDP_GH_ID=$RI_CLOUD_IDP_GH_ID_STAGE
            export RI_CLOUD_API_URL=$RI_CLOUD_API_URL_STAGE
            export RI_CLOUD_CAPI_URL=$RI_CLOUD_CAPI_URL_STAGE
            export RI_FEATURES_CONFIG_URL=$RI_FEATURES_CONFIG_URL_STAGE

            if [ << parameters.env >> == 'stage' ]; then
              RI_UPGRADES_LINK=$RI_UPGRADES_LINK_STAGE RI_SEGMENT_WRITE_KEY=$RI_SEGMENT_WRITE_KEY_STAGE yarn package:stage --linux << parameters.target >>
              exit 0;
            fi

            RI_UPGRADES_LINK='' RI_SEGMENT_WRITE_KEY='' yarn package:stage --linux << parameters.target >>
      - persist_to_workspace:
          root: .
          paths:
            - release/Redis-Insight*.deb
            - release/Redis-Insight*.rpm
            - release/Redis-Insight*.AppImage
            - release/Redis-Insight*.flatpak
            - release/Redis-Insight*.snap
            - release/*-linux.yml
  macosx:
    executor: macos
    resource_class: macos.m1.medium.gen1
    parameters:
      env:
        description: Build environment (stage || prod)
        type: enum
        default: stage
        enum: ['stage', 'prod', 'dev']
      redisstack:
        description: Build RedisStack archives
        type: boolean
        default: true
      target:
        description: Build target
        type: string
        default: ""
    steps:
      - checkout
      - node/install:
          node-version: '20.15'
      - attach_workspace:
          at: .
      - run:
          command: |
            cp ./electron/package.json ./redisinsight/
      - <<: *keychain
      - run:
          name: install dependencies
          command: |
            yarn install
            yarn --cwd redisinsight/api/ install
            yarn --cwd redisinsight/ install
            yarn build:statics
          no_output_timeout: 15m
      - run:
          name: Build macos dmg
          command: |
            unset CSC_LINK
            export CSC_IDENTITY_AUTO_DISCOVERY=true
            export CSC_KEYCHAIN=redisinsight.keychain

            if [ << parameters.env >> == 'prod' ]; then
              yarn package:prod
              yarn package:mas
              rm -rf release/mac
              mv release/mas-universal/Redis-Insight-mac-universal-mas.pkg release/Redis-Insight-mac-universal-mas.pkg
              exit 0;
            fi

            export RI_CLOUD_IDP_AUTHORIZE_URL=$RI_CLOUD_IDP_AUTHORIZE_URL_STAGE
            export RI_CLOUD_IDP_TOKEN_URL=$RI_CLOUD_IDP_TOKEN_URL_STAGE
            export RI_CLOUD_IDP_ISSUER=$RI_CLOUD_IDP_ISSUER_STAGE
            export RI_CLOUD_IDP_CLIENT_ID=$RI_CLOUD_IDP_CLIENT_ID_STAGE
            export RI_CLOUD_IDP_REDIRECT_URI=$RI_CLOUD_IDP_REDIRECT_URI_STAGE
            export RI_CLOUD_IDP_GOOGLE_ID=$RI_CLOUD_IDP_GOOGLE_ID_STAGE
            export RI_CLOUD_IDP_GH_ID=$RI_CLOUD_IDP_GH_ID_STAGE
            export RI_CLOUD_API_URL=$RI_CLOUD_API_URL_STAGE
            export RI_CLOUD_CAPI_URL=$RI_CLOUD_CAPI_URL_STAGE
            export RI_UPGRADES_LINK=''
            export RI_SEGMENT_WRITE_KEY=''
            export RI_FEATURES_CONFIG_URL=$RI_FEATURES_CONFIG_URL_STAGE

            if [ << parameters.env >> == 'stage' ]; then
              export RI_UPGRADES_LINK=$RI_UPGRADES_LINK_STAGE
              export RI_SEGMENT_WRITE_KEY=$RI_SEGMENT_WRITE_KEY_STAGE
            fi

            # handle manual builds
            if [ << parameters.target >> ]; then
              yarn package:stage --mac << parameters.target >>
              rm -rf release/mac
              exit 0;
            fi

            yarn package:stage && yarn package:mas
            rm -rf release/mac
            mv release/mas-universal/Redis-Insight-mac-universal-mas.pkg release/Redis-Insight-mac-universal-mas.pkg
          no_output_timeout: 60m
      - when:
          condition:
            equal: [ true, << parameters.redisstack >> ]
          steps:
            - run:
                name: Repack dmg to tar
                command: |
                  ARCH=x64 ./.circleci/redisstack/dmg.repack.sh
                  ARCH=arm64 ./.circleci/redisstack/dmg.repack.sh
      - persist_to_workspace:
          root: .
          paths:
            - release/Redis-Insight*.zip
            - release/Redis-Insight*.dmg
            - release/Redis-Insight*.dmg.blockmap
            - release/Redis-Insight*.pkg
            - release/*-mac.yml
            - release/redisstack
  windows:
    executor:
      name: win/default
    parameters:
      env:
        description: Build environment (stage || prod)
        type: enum
        default: stage
        enum: ['stage', 'prod', 'dev']
      target:
        description: Build target
        type: string
        default: ""
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run:
          command: |
            cp ./electron/package.json ./redisinsight/
      - run:
          name: Build windows exe
          command: |
            nvm install 20.15
            nvm use 20.15
            npm install --global yarn

            # set ALL_REDIS_COMMANDS=$(curl $ALL_REDIS_COMMANDS_RAW_URL)
            # install dependencies
            yarn install
            yarn --cwd redisinsight/api/ install
            yarn --cwd redisinsight/ install
            yarn build:statics:win

            if [ << parameters.env >> == 'prod' ]; then
              yarn package:prod
              rm -rf release/win-unpacked
              exit 0;
            fi

            export RI_CLOUD_IDP_AUTHORIZE_URL=$RI_CLOUD_IDP_AUTHORIZE_URL_STAGE
            export RI_CLOUD_IDP_TOKEN_URL=$RI_CLOUD_IDP_TOKEN_URL_STAGE
            export RI_CLOUD_IDP_ISSUER=$RI_CLOUD_IDP_ISSUER_STAGE
            export RI_CLOUD_IDP_CLIENT_ID=$RI_CLOUD_IDP_CLIENT_ID_STAGE
            export RI_CLOUD_IDP_REDIRECT_URI=$RI_CLOUD_IDP_REDIRECT_URI_STAGE
            export RI_CLOUD_IDP_GOOGLE_ID=$RI_CLOUD_IDP_GOOGLE_ID_STAGE
            export RI_CLOUD_IDP_GH_ID=$RI_CLOUD_IDP_GH_ID_STAGE
            export RI_CLOUD_API_URL=$RI_CLOUD_API_URL_STAGE
            export RI_CLOUD_CAPI_URL=$RI_CLOUD_CAPI_URL_STAGE
            export RI_FEATURES_CONFIG_URL=$RI_FEATURES_CONFIG_URL_STAGE

            if [ << parameters.env >> == 'stage' ]; then
              RI_UPGRADES_LINK=$RI_UPGRADES_LINK_STAGE RI_SEGMENT_WRITE_KEY=$RI_SEGMENT_WRITE_KEY_STAGE yarn package:stage --win << parameters.target >>
            else
              RI_UPGRADES_LINK='' RI_SEGMENT_WRITE_KEY='' yarn package:stage --win << parameters.target >>
            fi

            rm -rf release/win-unpacked
          shell: bash.exe
          no_output_timeout: 20m
      - persist_to_workspace:
          root: .
          paths:
            - release/Redis-Insight*.exe
            - release/Redis-Insight*.exe.blockmap
            - release/*.yml
  virustotal-file:
    executor: linux-executor
    parameters:
      ext:
        description: File extension
        type: string
    steps:
      - checkout
      - attach_workspace:
          at: /tmp/release
      - run:
          name: export FILE_NAME environment variable
          command: |
            echo 'export FILE_NAME="Redis-Insight*<< parameters.ext >>"' >> $BASH_ENV
      - <<: *fileScan
      - <<: *validate
  virustotal-url:
    executor: linux-executor
    parameters:
      fileName:
        description: File name
        type: string
    steps:
      - checkout
      - run:
          name: export URL environment variable
          command: |
            echo 'export URL="https://download.redisinsight.redis.com/latest/<< parameters.fileName >>"' >> $BASH_ENV
            echo 'export BUILD_NAME="<< parameters.fileName >>"' >> $BASH_ENV
      - <<: *urlScan
      - <<: *validate
      - <<: *virustotalReport
  virustotal-report:
    executor: linux-executor
    steps:
      - checkout
      - run:
          name: Send virustotal passed report
          command: |
            echo 'export VIRUS_CHECK_FAILED=0' >> $BASH_ENV
            echo 'export SKIP_VIRUSTOTAL_REPORT=false' >> $BASH_ENV
      - <<: *virustotalReport
  docker:
    executor: linux-executor
    parameters:
      env:
        type: enum
        default: staging
        enum: [ 'staging', 'production' ]
    steps:
      - checkout
      - node/install:
          install-yarn: true
          node-version: '20.15'
      - run:
          name: Install dependencies
          command: |
            sudo apt-get update -y && sudo apt-get install -y ca-certificates qemu-user-static
      - run:
          name: Build sources
          command: ./.circleci/build/build.sh
      - run:
          name: Build web archives
          command: |
            unset npm_config_keytar_binary_host_mirror
            unset npm_config_node_sqlite3_binary_host_mirror

            # Docker sources
            PLATFORM=linux ARCH=x64 LIBC=musl .circleci/build/build_modules.sh
            PLATFORM=linux ARCH=arm64 LIBC=musl .circleci/build/build_modules.sh

            # Redis Stack + VSC Linux
            PLATFORM=linux ARCH=x64 .circleci/build/build_modules.sh
            PLATFORM=linux ARCH=arm64 .circleci/build/build_modules.sh

            # VSC Darwin
            PLATFORM=darwin ARCH=x64 .circleci/build/build_modules.sh
            PLATFORM=darwin ARCH=arm64 .circleci/build/build_modules.sh
            # VSC Windows
            PLATFORM=win32 ARCH=x64 .circleci/build/build_modules.sh
      - run:
          name: Build Docker (x64, arm64)
          command: |
            TELEMETRY=$RI_SEGMENT_WRITE_KEY_DEV

            if [ << parameters.env >> == 'production' ]; then
              TELEMETRY=$RI_SEGMENT_WRITE_KEY
            fi

            if [ << parameters.env >> == 'staging' ]; then
              TELEMETRY=$RI_SEGMENT_WRITE_KEY_STAGE
            fi

            # Build alpine x64 image
            docker buildx build \
            -f .circleci/build/build.Dockerfile \
            --platform linux/amd64 \
            --build-arg DIST=release/web/Redis-Insight-web-linux-musl.x64.tar.gz \
            --build-arg NODE_ENV=<< parameters.env >> \
            --build-arg RI_SEGMENT_WRITE_KEY="$TELEMETRY" \
            -t redisinsight:amd64 \
            .

            # Build alpine arm64 image
            docker buildx build \
            -f .circleci/build/build.Dockerfile \
            --platform linux/arm64 \
            --build-arg DIST=release/web/Redis-Insight-web-linux-musl.arm64.tar.gz \
            --build-arg NODE_ENV=<< parameters.env >> \
            --build-arg RI_SEGMENT_WRITE_KEY="$TELEMETRY" \
            -t redisinsight:arm64 \
            .

            mkdir -p release/docker
            docker image save -o release/docker/docker-linux-alpine.amd64.tar redisinsight:amd64
            docker image save -o release/docker/docker-linux-alpine.arm64.tar redisinsight:arm64
      - persist_to_workspace:
          root: .
          paths:
            - ./release

  licenses-check:
    executor: linux-executor
    steps:
      - checkout
      - restore_cache:
          <<: *uiDepsCacheKey
          <<: *apiDepsCacheKey
      - run:
          name: Run install all dependencies
          command: |
            yarn install
            yarn --cwd redisinsight/api install
            yarn --cwd tests/e2e install
            # Install plugins dependencies
            export pluginsOnlyInstall=1
            yarn build:statics
      - run:
          name: Generate licenses csv files and send csv data to google sheet
          command: |
            npm i -g license-checker

            echo "$GOOGLE_ACCOUNT_SERVICE_KEY_BASE64" | base64 -id > gasKey.json
            SPREADSHEET_ID=$GOOGLE_SPREADSHEET_DEPENDENCIES_ID node .circleci/deps-licenses-report.js
      - store_artifacts:
          path: licenses
          destination: licenses

  # Release jobs
  store-build-artifacts:
    executor: linux-executor
    steps:
      - attach_workspace:
          at: .
      - store_artifacts:
          path: release
          destination: release
  release-aws-private-dev:
    executor: linux-executor
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run:
          name: publish
          command: |
            rm release/._* ||:
            chmod +x .circleci/build/sum_sha256.sh
            .circleci/build/sum_sha256.sh
            applicationVersion=$(jq -r '.version' redisinsight/package.json)

            aws s3 cp release/ s3://${AWS_BUCKET_NAME_TEST}/private/builds/${CIRCLE_BUILD_NUM} --recursive
  release-aws-private:
    executor: linux-executor
    steps:
      - checkout
      - attach_workspace:
          at: .
      - store_artifacts:
          path: release
          destination: release
      - run:
          name: prepare release
          command: |
            rm release/._* ||:
      - run:
          name: publish
          command: |
            chmod +x .circleci/build/sum_sha256.sh
            .circleci/build/sum_sha256.sh
            applicationVersion=$(jq -r '.version' redisinsight/package.json)

            aws s3 cp release/ s3://${AWS_BUCKET_NAME}/private/${applicationVersion} --recursive

  release-docker:
    executor: linux-executor
    steps:
      - checkout
      - attach_workspace:
            at: .
      - run:
          name: Release docker images
          command: |
            appVersion=$(jq -r '.version' redisinsight/package.json)

            docker login -u $DOCKER_USER -p $DOCKER_PASS

            ./.circleci/build/release-docker.sh \
            -d redisinsight \
            -r $DOCKER_REPO \
            -v $appVersion

            docker login -u $DOCKER_V1_USER -p $DOCKER_V1_PASS

            ./.circleci/build/release-docker.sh \
            -d redisinsight \
            -r $DOCKER_V1_REPO \
            -v $appVersion

  publish-prod-aws:
    executor: linux-executor
    steps:
      - checkout
      - run:
          name: Init variables
          command: |
            latestYmlFileName="latest.yml"
            downloadLatestFolderPath="public/latest"
            upgradeLatestFolderPath="public/upgrades"
            releasesFolderPath="public/releases"
            appName=$(jq -r '.productName' electron-builder.json)
            appVersion=$(jq -r '.version' redisinsight/package.json)

            echo "export downloadLatestFolderPath=${downloadLatestFolderPath}" >> $BASH_ENV
            echo "export upgradeLatestFolderPath=${upgradeLatestFolderPath}" >> $BASH_ENV
            echo "export releasesFolderPath=${releasesFolderPath}" >> $BASH_ENV
            echo "export applicationName=${appName}" >> $BASH_ENV
            echo "export applicationVersion=${appVersion}" >> $BASH_ENV
            echo "export appFileName=Redis-Insight" >> $BASH_ENV

            # download latest.yml file to get last public version
            aws s3 cp s3://${AWS_BUCKET_NAME}/${downloadLatestFolderPath}/${latestYmlFileName} .

            versionLine=$(head -1 ${latestYmlFileName})
            versionLineArr=(${versionLine/:// })
            previousAppVersion=${versionLineArr[1]}

            echo "export previousApplicationVersion=${previousAppVersion}" >> $BASH_ENV

      - run:
          name: Publish AWS S3
          command: |
            # remove previous build from the latest directory /public/latest
            aws s3 rm s3://${AWS_BUCKET_NAME}/${downloadLatestFolderPath} --recursive

            # remove previous build from the upgrade directory /public/upgrades
            aws s3 rm s3://${AWS_BUCKET_NAME}/${upgradeLatestFolderPath} --recursive

            # copy current version apps for download to /public/latest
            aws s3 cp s3://${AWS_BUCKET_NAME}/private/${applicationVersion}/ \
              s3://${AWS_BUCKET_NAME}/${downloadLatestFolderPath} --recursive  --exclude "*.zip"

            # copy current version apps for upgrades to /public/upgrades
            aws s3 cp s3://${AWS_BUCKET_NAME}/private/${applicationVersion}/ \
              s3://${AWS_BUCKET_NAME}/${upgradeLatestFolderPath} --recursive

            # !MOVE current version apps to releases folder /public/releases
            aws s3 mv s3://${AWS_BUCKET_NAME}/private/${applicationVersion}/ \
              s3://${AWS_BUCKET_NAME}/${releasesFolderPath}/${applicationVersion} --recursive

            # invalidate cloudfront cash
            aws cloudfront create-invalidation --distribution-id ${AWS_DISTRIBUTION_ID} --paths "/*"

      - run:
          name: Add tags for all objects and create S3 metrics
          command: |

            # declare all tags
            declare -A tag0=(
                [arch]='x64'
                [platform]='macos'
                [objectDownload]=${appFileName}'-mac-x64.dmg'
                [objectUpgrade]=${appFileName}'-mac-x64.zip'
            )

            declare -A tag1=(
                [arch]='arm64'
                [platform]='macos'
                [objectDownload]=${appFileName}'-mac-arm64.dmg'
                [objectUpgrade]=${appFileName}'-mac-arm64.zip'
            )

            declare -A tag2=(
                [arch]='x64'
                [platform]='windows'
                [objectDownload]=${appFileName}'-win-installer.exe'
            )

            declare -A tag3=(
                [arch]='x64'
                [platform]='linux_AppImage'
                [objectDownload]=${appFileName}'-linux-x86_64.AppImage'
            )

            declare -A tag4=(
                [arch]='x64'
                [platform]='linux_deb'
                [objectDownload]=${appFileName}'-linux-amd64.deb'
            )

            declare -A tag5=(
                [arch]='x64'
                [platform]='linux_rpm'
                [objectDownload]=${appFileName}'-linux-x86_64.rpm'
            )

            # loop for add all tags to each app and create metrics
            declare -n tag
            for tag in ${!tag@}; do

                designation0="downloads"
                designation1="upgrades"

                id0="${tag[platform]}_${tag[arch]}_${designation0}_${applicationVersion}"
                id1="${tag[platform]}_${tag[arch]}_${designation1}_${applicationVersion}"

                # add tags to each app for download
                aws s3api put-object-tagging \
                  --bucket ${AWS_BUCKET_NAME} \
                  --key ${downloadLatestFolderPath}/${tag[objectDownload]} \
                  --tagging '{"TagSet": [{ "Key": "version", "Value": "'"${applicationVersion}"'" }, {"Key": "platform", "Value": "'"${tag[platform]}"'"}, {"Key": "arch", "Value": "'"${tag[arch]}"'"}, { "Key": "designation", "Value": "'"${designation0}"'" }]}'

                # add tags to each app for upgrades
                aws s3api put-object-tagging \
                  --bucket ${AWS_BUCKET_NAME} \
                  --key ${upgradeLatestFolderPath}/${tag[objectUpgrade]:=${tag[objectDownload]}} \
                  --tagging '{"TagSet": [{ "Key": "version", "Value": "'"${applicationVersion}"'" }, {"Key": "platform", "Value": "'"${tag[platform]}"'"}, {"Key": "arch", "Value": "'"${tag[arch]}"'"}, { "Key": "designation", "Value": "'"${designation1}"'" }]}'

                # Create metrics for all tags for downloads to S3
                aws s3api put-bucket-metrics-configuration \
                  --bucket ${AWS_BUCKET_NAME} \
                  --id ${id0} \
                  --metrics-configuration '{"Id": "'"${id0}"'", "Filter": {"And": {"Tags": [{"Key": "platform", "Value": "'"${tag[platform]}"'"}, {"Key": "arch", "Value": "'"${tag[arch]}"'"}, {"Key": "designation", "Value": "'"${designation0}"'"}, {"Key": "version", "Value": "'"${applicationVersion}"'"} ]}}}'

                # Create metrics for all tags for upgrades to S3
                aws s3api put-bucket-metrics-configuration \
                  --bucket ${AWS_BUCKET_NAME} \
                  --id ${id1} \
                  --metrics-configuration '{"Id": "'"${id1}"'", "Filter": {"And": {"Tags": [{"Key": "platform", "Value": "'"${tag[platform]}"'"}, {"Key": "arch", "Value": "'"${tag[arch]}"'"}, {"Key": "designation", "Value": "'"${designation1}"'"}, {"Key": "version", "Value": "'"${applicationVersion}"'"}]}}}'

            done


workflows:
  # FE Unit tests for "fe/feature" or "fe/bugfix" branches only
  frontend-tests:
    <<: *ignore-for-manual-build
    jobs:
      - unit-tests-ui:
          name: UTest - UI
          filters:
            branches:
              only:
                - /^fe/feature.*/
                - /^fe/bugfix.*/
  # BE Unit + Integration (limited RTEs) tests for "be/feature" or "be/bugfix" branches only
  backend-tests:
    <<: *ignore-for-manual-build
    jobs:
      - unit-tests-api:
          name: UTest - API
          filters:
            branches:
              only:
                - /^be/feature.*/
                - /^be/bugfix.*/
      - integration-tests-run:
          redis_client: << pipeline.parameters.redis_client >>
          matrix:
            alias: itest-code
            parameters:
              rte: *iTestsNamesShort
          name: ITest - << matrix.rte >> (code)
          requires:
            - UTest - API
  # E2E tests for "e2e/feature" or "e2e/bugfix" branches only
  e2e-tests:
    jobs:
      - approve:
          name: Start E2E Tests
          type: approval
          filters:
            branches:
              only:
                - /^e2e/feature.*/
                - /^e2e/bugfix.*/
      - setup-sign-certificates:
          name: Setup sign certificates (stage)
          requires:
            - Start E2E Tests
      - setup-build:
          name: Setup build (stage)
          requires:
            - Setup sign certificates (stage)
      - linux:
          name: Build app - Linux (stage)
          env: stage
          target: AppImage
          requires:
            - Setup build (stage)
      # - docker:
      #     name: Build docker image
      #     requires:
      #       - Start E2E Tests
      # - e2e-tests:
      #     name: E2ETest
      #     build: docker
      #     parallelism: 4
      #     requires:
      #       - Build docker image
      - e2e-app-image:
          name: E2ETest (AppImage)
          parallelism: 1
          requires:
            - Build app - Linux (stage)
  # Workflow for feature, bugfix, main branches
  feature-main-branch:
    <<: *ignore-for-manual-build
    jobs:
      # Approve to run all (unit, integration, e2e) tests
      - approve:
          name: Start All Tests
          type: approval
          filters:
            branches:
              only:
                - /^feature.*/
                - /^bugfix.*/
                - main
      # FE tests
      - unit-tests-ui:
          name: UTest - UI
          requires:
            - Start All Tests
      # BE tests
      - unit-tests-api:
          name: UTest - API
          requires:
            - Start All Tests
      - integration-tests-run:
          matrix:
            alias: itest-code
            parameters:
              rte: *iTestsNames
              redis_client:
                - << pipeline.parameters.redis_client >>
          name: ITest - << matrix.rte >> (code)
          requires:
            - Start All Tests
      - integration-tests-coverage:
          name: ITest - Final coverage
          requires:
            - itest-code
      # E2E tests
      - setup-sign-certificates:
          name: Setup sign certificates (stage)
          requires:
            - Start All Tests
      - setup-build:
          name: Setup build (stage)
          requires:
            - Setup sign certificates (stage)
      - linux:
          name: Build app - Linux (stage)
          requires:
            - Setup build (stage)
      - docker:
          name: Build docker image
          requires:
            - Start All Tests
      - e2e-tests:
          name: E2ETest
          build: docker
          parallelism: 4
          requires:
            - Build docker image
      - e2e-app-image:
          name: E2ETest (AppImage)
          parallelism: 2
          requires:
            - Build app - Linux (stage)
      # Approve to build
      - approve:
          name: Build App
          type: approval
          requires:
            - UTest - UI
            - UTest - API
            - ITest - Final coverage
          filters:
            branches:
              only:
                - /^e2e/feature.*/
                - /^e2e/bugfix.*/
  # Manual builds using web UI
  manual-build-linux:
    when: << pipeline.parameters.linux >>
    jobs:
      - manual-build-validate:
          name: Validating build parameters
          os: linux
          target: << pipeline.parameters.linux >>
      - setup-sign-certificates:
          name: Setup sign certificates (<< pipeline.parameters.env >>)
          requires:
            - Validating build parameters
      - setup-build:
          name: Setup build (<< pipeline.parameters.env >>)
          env:  << pipeline.parameters.env >>
          requires:
            - Setup sign certificates (<< pipeline.parameters.env >>)
      - linux:
          name: Build app - Linux (<< pipeline.parameters.env >>)
          env: << pipeline.parameters.env >>
          target: << pipeline.parameters.linux >>
          requires:
            - Setup build (<< pipeline.parameters.env >>)
      - store-build-artifacts:
          name: Store build artifacts (<< pipeline.parameters.env >>)
          requires:
            - Build app - Linux (<< pipeline.parameters.env >>)
  manual-build-mac:
    when: << pipeline.parameters.mac >>
    jobs:
      - manual-build-validate:
          name: Validating build parameters
          os: mac
          target: << pipeline.parameters.mac >>
      - setup-sign-certificates:
          name: Setup sign certificates (<< pipeline.parameters.env >>)
          requires:
            - Validating build parameters
      - setup-build:
          name: Setup build (<< pipeline.parameters.env >>)
          env: << pipeline.parameters.env >>
          requires:
            - Setup sign certificates (<< pipeline.parameters.env >>)
      - macosx:
          name: Build app - MacOS (<< pipeline.parameters.env >>)
          env: << pipeline.parameters.env >>
          redisstack: false
          target: << pipeline.parameters.mac >>
          requires:
            - Setup build (<< pipeline.parameters.env >>)
      - store-build-artifacts:
          name: Store build artifacts (<< pipeline.parameters.env >>)
          requires:
            - Build app - MacOS (<< pipeline.parameters.env >>)
  manual-build-windows:
    when: << pipeline.parameters.windows >>
    jobs:
      - manual-build-validate:
          name: Validating build parameters
          os: windows
          target: << pipeline.parameters.windows >>
      - setup-sign-certificates:
          name: Setup sign certificates (<< pipeline.parameters.env >>)
          requires:
            - Validating build parameters
      - setup-build:
          name: Setup build (<< pipeline.parameters.env >>)
          env: << pipeline.parameters.env >>
          requires:
            - Setup sign certificates (<< pipeline.parameters.env >>)
      - windows:
          name: Build app - Windows (<< pipeline.parameters.env >>)
          env: << pipeline.parameters.env >>
          target: << pipeline.parameters.windows >>
          requires:
            - Setup build (<< pipeline.parameters.env >>)
      - store-build-artifacts:
          name: Store build artifacts (<< pipeline.parameters.env >>)
          requires:
            - Build app - Windows (<< pipeline.parameters.env >>)
  manual-build-docker:
    when: << pipeline.parameters.docker >>
    jobs:
      - manual-build-validate:
          name: Validating build parameters
          os: docker
          target: << pipeline.parameters.docker >>
      - setup-sign-certificates:
          name: Setup sign certificates (<< pipeline.parameters.env >>)
          requires:
            - Validating build parameters
      - setup-build:
          name: Setup build (<< pipeline.parameters.env >>)
          env: << pipeline.parameters.env >>
          requires:
            - Setup sign certificates (<< pipeline.parameters.env >>)
      - docker:
          name: Build docker images (<< pipeline.parameters.env >>)
          requires:
            - Setup build (<< pipeline.parameters.env >>)
      - store-build-artifacts:
          name: Store build artifacts (<< pipeline.parameters.env >>)
          requires:
            - Build docker images (<< pipeline.parameters.env >>)

  # build electron app (dev) from "build" branches
  build:
    <<: *ignore-for-manual-build
    jobs:
      - setup-sign-certificates:
          name: Setup sign certificates (dev)
          filters:
            branches:
              only:
                - /^build.*/
      - setup-build:
          name: Setup build (dev)
          env: dev
          requires:
            - Setup sign certificates (dev)
      - linux:
          name: Build app - Linux (dev)
          env: dev
          requires: &devBuildRequire
            - Setup build (dev)
      - macosx:
          name: Build app - MacOS (dev)
          env: dev
          requires: *devBuildRequire
      - windows:
          name: Build app - Windows (dev)
          env: dev
          requires: *devBuildRequire
      - docker:
          name: Build docker images (dev)
          requires: *devBuildRequire
      - store-build-artifacts:
          name: Store build artifacts (dev)
          requires:
            - Build app - Linux (dev)
            - Build app - MacOS (dev)
            - Build app - Windows (dev)
            - Build docker images (dev)

  # build electron app (dev) for internal use only
  internal:
    <<: *ignore-for-manual-build
    jobs:
      - setup-sign-certificates:
          name: Setup sign certificates (dev)
          filters:
            branches:
              only:
                - /^internal.*/
      - setup-build:
          name: Setup build (dev)
          env: dev
          requires:
            - Setup sign certificates (dev)
      - linux:
          name: Build app - Linux (dev)
          env: dev
          requires: &devBuildRequire
            - Setup build (dev)
      - macosx:
          name: Build app - MacOS (dev)
          env: dev
          requires: *devBuildRequire
      - windows:
          name: Build app - Windows (dev)
          env: dev
          requires: *devBuildRequire
      - docker:
          name: Build docker images (dev)
          requires: *devBuildRequire
      # release to private AWS (dev)
      - release-aws-private-dev:
          name: Release private AWS dev
          requires:
            - Build app - Linux (dev)
            - Build app - MacOS (dev)
            - Build app - Windows (dev)
            - Build docker images (dev)

  # Main workflow for release/* and latest branches only
  release:
    <<: *ignore-for-manual-build
    jobs:
      # unit tests (on any commit)
      - unit-tests-ui:
          name: UTest - UI
          filters: &releaseAndLatestFilter
            branches:
              only:
                - /^release.*/
                - latest
      - unit-tests-api:
          name: UTest - API
          filters: *releaseAndLatestFilter
      # integration tests
      - integration-tests-run:
          matrix:
            alias: itest-code
            parameters:
              rte: *iTestsNames
              redis_client:
                - << pipeline.parameters.redis_client >>
          name: ITest - << matrix.rte >> (code)
          filters: *releaseAndLatestFilter
      - integration-tests-coverage:
          name: ITest - Final coverage
          requires:
            - itest-code

      # ================== STAGE ==================
      # prebuild (stage)
      - setup-sign-certificates:
          name: Setup sign certificates (stage)
          requires:
            - UTest - UI
            - UTest - API
            - ITest - Final coverage
          <<: *stageFilter
      - setup-build:
          name: Setup build (stage)
          requires:
            - Setup sign certificates (stage)
      # build electron app (stage)
      - linux:
          name: Build app - Linux (stage)
          requires: &stageElectronBuildRequires
            - Setup build (stage)
      - macosx:
          name: Build app - MacOS (stage)
          requires: *stageElectronBuildRequires
      - windows:
          name: Build app - Windows (stage)
          requires: *stageElectronBuildRequires
      - docker:
          name: Build docker images (stage)
          requires: *stageElectronBuildRequires
      # e2e desktop tests on AppImage build
      - e2e-app-image:
          name: E2ETest (AppImage)
          parallelism: 2
          requires:
            - Build app - Linux (stage)
      # e2e docker tests
      - e2e-tests:
          name: E2ETest
          build: docker
          parallelism: 4
          requires:
            - Build docker images (stage)
      - store-build-artifacts:
          name: Store build artifacts (stage)
          requires:
            - Build app - Linux (stage)
            - Build app - MacOS (stage)
            - Build app - Windows (stage)
            - Build docker images (stage)

      # Needs approval from QA team that build was tested before merging to latest
      - qa-approve:
          name: Approved by QA team
          type: approval
          requires:
            - Build app - Linux (stage)
            - Build app - MacOS (stage)
            - Build app - Windows (stage)
            - Build docker images (stage)

      # ================== PROD ==================
      # build and release electron app (prod)
      - setup-sign-certificates:
          name: Setup sign certificates (prod)
          requires:
            - UTest - UI
            - UTest - API
            - ITest - Final coverage
          <<: *prodFilter
      - setup-build:
          name: Setup build (prod)
          env: prod
          requires:
            - Setup sign certificates (prod)
      - linux:
          name: Build app - Linux (prod)
          env: prod
          requires: &prodElectronBuildRequires
            - Setup build (prod)
      - macosx:
          name: Build app - MacOS (prod)
          env: prod
          requires: *prodElectronBuildRequires
      - windows:
          name: Build app - Windows (prod)
          env: prod
          requires: *prodElectronBuildRequires
      - docker:
          name: Build docker images (prod)
          env: production
          requires: *prodElectronBuildRequires
      # e2e desktop tests on AppImage build
      - e2e-app-image:
          name: E2ETest (AppImage)
          parallelism: 2
          requires:
            - Build app - Linux (prod)
      # e2e docker tests
      - e2e-tests:
          name: E2ETest
          build: docker
          parallelism: 4
          requires:
            - Build docker images (prod)
      # virus check all electron apps (prod)
      - virustotal-file:
          name: Virus check - AppImage (prod)
          ext: .AppImage
          requires:
            - Build app - Linux (prod)
      - virustotal-file:
          name: Virus check - deb (prod)
          ext: .deb
          requires:
            - Build app - Linux (prod)
      - virustotal-file:
          name: Virus check - rpm (prod)
          ext: .rpm
          requires:
            - Build app - Linux (prod)
      - virustotal-file:
          name: Virus check - snap (prod)
          ext: .snap
          requires:
            - Build app - Linux (prod)
      - virustotal-file:
          name: Virus check x64 - dmg (prod)
          ext: -x64.dmg
          requires:
            - Build app - MacOS (prod)
      - virustotal-file:
          name: Virus check arm64 - dmg (prod)
          ext: -arm64.dmg
          requires:
            - Build app - MacOS (prod)
      - virustotal-file:
          name: Virus check MAS - pkg (prod)
          ext: -mas.pkg
          requires:
            - Build app - MacOS (prod)
      - virustotal-file:
          name: Virus check - exe (prod)
          ext: .exe
          requires:
            - Build app - Windows (prod)
      # upload release to prerelease AWS folder
      - release-aws-private:
          name: Release AWS S3 Private (prod)
          requires:
            - Virus check - AppImage (prod)
            - Virus check - deb (prod)
            - Virus check - rpm (prod)
            - Virus check - snap (prod)
            - Virus check x64 - dmg (prod)
            - Virus check arm64 - dmg (prod)
            - Virus check MAS - pkg (prod)
            - Virus check - exe (prod)
            - Build docker images (prod)
      # Manual approve for publish release
      - approve-publish:
          name: Approve Publish Release (prod)
          type: approval
          requires:
            - Release AWS S3 Private (prod)
          <<: *prodFilter # double check for "latest"
      # Publish release
      - publish-prod-aws:
          name: Publish AWS S3
          requires:
            - Approve Publish Release (prod)
          <<: *prodFilter # double check for "latest"
      - release-docker:
          name: Release docker images
          requires:
            - Approve Publish Release (prod)
          <<: *prodFilter # double check for "latest"
  # Nightly tests
  nightly:
    triggers:
      - schedule:
          cron: '0 0 * * *'
          filters:
            branches:
              only:
                - main
    jobs:
      # build docker image
      - docker:
          name: Build docker image
      # build desktop app
      - setup-sign-certificates:
          name: Setup sign certificates (stage)
      - setup-build:
          name: Setup build (stage)
          requires:
            - Setup sign certificates (stage)
      - linux:
          name: Build app - Linux (stage)
          requires:
            - Setup build (stage)
      #  - windows:
      #      name: Build app - Windows (stage)
      #      requires:
      #        - Setup build (stage)
      # integration tests on docker image build
      - integration-tests-run:
          matrix:
            alias: itest-docker
            parameters:
              rte: *iTestsNames
              build: ['docker']
              report: [true]
          name: ITest - << matrix.rte >> (docker)
          requires:
            - Build docker image
      # e2e web tests on docker image build
      - e2e-tests:
          name: E2ETest - Nightly
          parallelism: 4
          build: docker
          report: true
          requires:
            - Build docker image
      # e2e desktop tests on AppImage build
      - e2e-app-image:
          name: E2ETest (AppImage) - Nightly
          parallelism: 2
          report: true
          requires:
            - Build app - Linux (stage)

      - virustotal-url:
          name: Virus check - AppImage (nightly)
          fileName: Redis-Insight-linux-x86_64.AppImage
      - virustotal-url:
          name: Virus check - deb (nightly)
          fileName: Redis-Insight-linux-amd64.deb
      - virustotal-url:
          name: Virus check - rpm (nightly)
          fileName: Redis-Insight-linux-x86_64.rpm
      - virustotal-url:
          name: Virus check - snap (nightly)
          fileName: Redis-Insight-linux-amd64.snap
      - virustotal-url:
          name: Virus check x64 - dmg (nightly)
          fileName: Redis-Insight-mac-x64.dmg
      - virustotal-url:
          name: Virus check arm64 - dmg (nightly)
          fileName: Redis-Insight-mac-arm64.dmg
      - virustotal-url:
          name: Virus check MAS - pkg (nightly)
          fileName: Redis-Insight-mac-universal-mas.pkg
      - virustotal-url:
          name: Virus check - exe (nightly)
          fileName: Redis-Insight-win-installer.exe
      - virustotal-report:
          name: Virus check report (prod)
          requires:
            - Virus check - AppImage (nightly)
            - Virus check - deb (nightly)
            - Virus check - rpm (nightly)
            - Virus check - snap (nightly)
            - Virus check x64 - dmg (nightly)
            - Virus check arm64 - dmg (nightly)
            - Virus check MAS - pkg (nightly)
            - Virus check - exe (nightly)

      # # e2e desktop tests on exe build
      # - e2e-exe:
      #     name: E2ETest (exe) - Nightly
      #     parallelism: 4
      #     report: true
      #     requires:
      #       - Build app - Windows (stage)

  weekly:
    triggers:
      - schedule:
          cron: '0 0 * * 1'
          filters:
            branches:
              only:
                - main
    jobs:
      # Process all licenses
      - licenses-check:
          name: Process licenses of packages

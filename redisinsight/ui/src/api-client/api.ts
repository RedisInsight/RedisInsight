/* tslint:disable */
/* eslint-disable */
/**
 * Redis Insight Backend API
 * Redis Insight Backend API
 *
 * The version of the OpenAPI document: 2.70.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AckPendingEntriesDto
 */
export interface AckPendingEntriesDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof AckPendingEntriesDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * 
     * @type {GetConsumersDtoGroupName}
     * @memberof AckPendingEntriesDto
     */
    'groupName': GetConsumersDtoGroupName;
    /**
     * Entries IDs
     * @type {Array<CreateListWithExpireDtoElementsInner>}
     * @memberof AckPendingEntriesDto
     */
    'entries': Array<CreateListWithExpireDtoElementsInner>;
}
/**
 * 
 * @export
 * @interface AckPendingEntriesResponse
 */
export interface AckPendingEntriesResponse {
    /**
     * Number of affected entries
     * @type {number}
     * @memberof AckPendingEntriesResponse
     */
    'affected': number;
}
/**
 * 
 * @export
 * @interface AddFieldsToHashDto
 */
export interface AddFieldsToHashDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof AddFieldsToHashDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Hash fields
     * @type {Array<HashFieldDto>}
     * @memberof AddFieldsToHashDto
     */
    'fields': Array<HashFieldDto>;
}
/**
 * 
 * @export
 * @interface AddMembersToSetDto
 */
export interface AddMembersToSetDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof AddMembersToSetDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Set members
     * @type {Array<CreateListWithExpireDtoElementsInner>}
     * @memberof AddMembersToSetDto
     */
    'members': Array<CreateListWithExpireDtoElementsInner>;
}
/**
 * 
 * @export
 * @interface AddMembersToZSetDto
 */
export interface AddMembersToZSetDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof AddMembersToZSetDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * ZSet members
     * @type {Array<ZSetMemberDto>}
     * @memberof AddMembersToZSetDto
     */
    'members': Array<ZSetMemberDto>;
}
/**
 * 
 * @export
 * @interface AddRedisEnterpriseDatabaseResponse
 */
export interface AddRedisEnterpriseDatabaseResponse {
    /**
     * The unique ID of the database
     * @type {number}
     * @memberof AddRedisEnterpriseDatabaseResponse
     */
    'uid': number;
    /**
     * Add Redis Enterprise database status
     * @type {string}
     * @memberof AddRedisEnterpriseDatabaseResponse
     */
    'status': AddRedisEnterpriseDatabaseResponseStatusEnum;
    /**
     * Message
     * @type {string}
     * @memberof AddRedisEnterpriseDatabaseResponse
     */
    'message': string;
    /**
     * The database details.
     * @type {RedisEnterpriseDatabase}
     * @memberof AddRedisEnterpriseDatabaseResponse
     */
    'databaseDetails'?: RedisEnterpriseDatabase;
    /**
     * Error
     * @type {object}
     * @memberof AddRedisEnterpriseDatabaseResponse
     */
    'error'?: object;
}

export const AddRedisEnterpriseDatabaseResponseStatusEnum = {
    Success: 'success',
    Fail: 'fail'
} as const;

export type AddRedisEnterpriseDatabaseResponseStatusEnum = typeof AddRedisEnterpriseDatabaseResponseStatusEnum[keyof typeof AddRedisEnterpriseDatabaseResponseStatusEnum];

/**
 * 
 * @export
 * @interface AddRedisEnterpriseDatabasesDto
 */
export interface AddRedisEnterpriseDatabasesDto {
    /**
     * The hostname of your Redis Enterprise.
     * @type {string}
     * @memberof AddRedisEnterpriseDatabasesDto
     */
    'host': string;
    /**
     * The port your Redis Enterprise cluster is available on.
     * @type {number}
     * @memberof AddRedisEnterpriseDatabasesDto
     */
    'port': number;
    /**
     * The admin e-mail/username
     * @type {string}
     * @memberof AddRedisEnterpriseDatabasesDto
     */
    'username': string;
    /**
     * The admin password
     * @type {string}
     * @memberof AddRedisEnterpriseDatabasesDto
     */
    'password': string;
    /**
     * The unique IDs of the databases.
     * @type {Array<number>}
     * @memberof AddRedisEnterpriseDatabasesDto
     */
    'uids': Array<number>;
}
/**
 * 
 * @export
 * @interface AddStreamEntriesDto
 */
export interface AddStreamEntriesDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof AddStreamEntriesDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Entries to push
     * @type {Array<StreamEntryDto>}
     * @memberof AddStreamEntriesDto
     */
    'entries': Array<StreamEntryDto>;
}
/**
 * 
 * @export
 * @interface AddStreamEntriesResponse
 */
export interface AddStreamEntriesResponse {
    /**
     * 
     * @type {PushListElementsResponseKeyName}
     * @memberof AddStreamEntriesResponse
     */
    'keyName': PushListElementsResponseKeyName;
    /**
     * Entries IDs
     * @type {Array<string>}
     * @memberof AddStreamEntriesResponse
     */
    'entries': Array<string>;
}
/**
 * 
 * @export
 * @interface AdditionalRedisModule
 */
export interface AdditionalRedisModule {
    /**
     * Name of the module.
     * @type {string}
     * @memberof AdditionalRedisModule
     */
    'name': string;
    /**
     * Integer representation of a module version.
     * @type {number}
     * @memberof AdditionalRedisModule
     */
    'version'?: number;
    /**
     * Semantic versioning representation of a module version.
     * @type {string}
     * @memberof AdditionalRedisModule
     */
    'semanticVersion'?: string;
}
/**
 * 
 * @export
 * @interface AiChat
 */
export interface AiChat {
    /**
     * 
     * @type {string}
     * @memberof AiChat
     */
    'id': string;
    /**
     * 
     * @type {Array<AiChatMessage>}
     * @memberof AiChat
     */
    'messages': Array<AiChatMessage>;
}
/**
 * 
 * @export
 * @interface AiChatMessage
 */
export interface AiChatMessage {
    /**
     * 
     * @type {string}
     * @memberof AiChatMessage
     */
    'type': AiChatMessageTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AiChatMessage
     */
    'content': string;
    /**
     * 
     * @type {object}
     * @memberof AiChatMessage
     */
    'context': object;
}

export const AiChatMessageTypeEnum = {
    HumanMessage: 'HumanMessage',
    AiMessage: 'AIMessage'
} as const;

export type AiChatMessageTypeEnum = typeof AiChatMessageTypeEnum[keyof typeof AiChatMessageTypeEnum];

/**
 * 
 * @export
 * @interface AnalysisProgress
 */
export interface AnalysisProgress {
    /**
     * Total keys in the database
     * @type {number}
     * @memberof AnalysisProgress
     */
    'total': number;
    /**
     * Total keys scanned for entire database
     * @type {number}
     * @memberof AnalysisProgress
     */
    'scanned': number;
    /**
     * Total keys processed for entire database. (Filtered keys returned by scan command)
     * @type {number}
     * @memberof AnalysisProgress
     */
    'processed': number;
}
/**
 * 
 * @export
 * @interface BrowserHistory
 */
export interface BrowserHistory {
    /**
     * History id
     * @type {string}
     * @memberof BrowserHistory
     */
    'id': string;
    /**
     * Database id
     * @type {string}
     * @memberof BrowserHistory
     */
    'databaseId': string;
    /**
     * Filters for scan operation
     * @type {ScanFilter}
     * @memberof BrowserHistory
     */
    'filter': ScanFilter;
    /**
     * Mode of history
     * @type {string}
     * @memberof BrowserHistory
     */
    'mode': BrowserHistoryModeEnum;
    /**
     * History created date (ISO string)
     * @type {string}
     * @memberof BrowserHistory
     */
    'createdAt': string;
}

export const BrowserHistoryModeEnum = {
    Pattern: 'pattern',
    Redisearch: 'redisearch'
} as const;

export type BrowserHistoryModeEnum = typeof BrowserHistoryModeEnum[keyof typeof BrowserHistoryModeEnum];

/**
 * 
 * @export
 * @interface CaCertificate
 */
export interface CaCertificate {
    /**
     * Certificate id
     * @type {string}
     * @memberof CaCertificate
     */
    'id': string;
    /**
     * Certificate name
     * @type {string}
     * @memberof CaCertificate
     */
    'name': string;
    /**
     * Certificate body
     * @type {string}
     * @memberof CaCertificate
     */
    'certificate': string;
    /**
     * Whether the certificate was created from a file or environment variables at startup
     * @type {boolean}
     * @memberof CaCertificate
     */
    'isPreSetup'?: boolean;
}
/**
 * 
 * @export
 * @interface ClaimPendingEntriesResponse
 */
export interface ClaimPendingEntriesResponse {
    /**
     * Entries IDs were affected by claim command
     * @type {Array<string>}
     * @memberof ClaimPendingEntriesResponse
     */
    'affected': Array<string>;
}
/**
 * 
 * @export
 * @interface ClaimPendingEntryDto
 */
export interface ClaimPendingEntryDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof ClaimPendingEntryDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * 
     * @type {GetConsumersDtoGroupName}
     * @memberof ClaimPendingEntryDto
     */
    'groupName': GetConsumersDtoGroupName;
    /**
     * 
     * @type {GetPendingEntriesDtoConsumerName}
     * @memberof ClaimPendingEntryDto
     */
    'consumerName': GetPendingEntriesDtoConsumerName;
    /**
     * Claim only if its idle time is greater the minimum idle time 
     * @type {number}
     * @memberof ClaimPendingEntryDto
     */
    'minIdleTime': number;
    /**
     * Entries IDs
     * @type {Array<string>}
     * @memberof ClaimPendingEntryDto
     */
    'entries': Array<string>;
    /**
     * Set the idle time (last time it was delivered) of the message
     * @type {number}
     * @memberof ClaimPendingEntryDto
     */
    'idle'?: number;
    /**
     * This is the same as IDLE but instead of a relative amount of milliseconds, it sets the idle time to a specific Unix time (in milliseconds)
     * @type {number}
     * @memberof ClaimPendingEntryDto
     */
    'time'?: number;
    /**
     * Set the retry counter to the specified value. This counter is incremented every time a message is delivered again. Normally XCLAIM does not alter this counter, which is just served to clients when the XPENDING command is called: this way clients can detect anomalies, like messages that are never processed for some reason after a big number of delivery attempts
     * @type {number}
     * @memberof ClaimPendingEntryDto
     */
    'retryCount'?: number;
    /**
     * Creates the pending message entry in the PEL even if certain specified IDs are not already in the PEL assigned to a different client
     * @type {boolean}
     * @memberof ClaimPendingEntryDto
     */
    'force'?: boolean;
}
/**
 * 
 * @export
 * @interface ClientCertificate
 */
export interface ClientCertificate {
    /**
     * Certificate id
     * @type {string}
     * @memberof ClientCertificate
     */
    'id': string;
    /**
     * Certificate name
     * @type {string}
     * @memberof ClientCertificate
     */
    'name': string;
    /**
     * Certificate body
     * @type {string}
     * @memberof ClientCertificate
     */
    'certificate': string;
    /**
     * Key body
     * @type {string}
     * @memberof ClientCertificate
     */
    'key': string;
    /**
     * Whether the certificate was created from a file or environment variables at startup
     * @type {boolean}
     * @memberof ClientCertificate
     */
    'isPreSetup'?: boolean;
}
/**
 * 
 * @export
 * @interface CloudAccountInfo
 */
export interface CloudAccountInfo {
    /**
     * Account id
     * @type {number}
     * @memberof CloudAccountInfo
     */
    'accountId': number;
    /**
     * Account name
     * @type {string}
     * @memberof CloudAccountInfo
     */
    'accountName': string;
    /**
     * Account owner name
     * @type {string}
     * @memberof CloudAccountInfo
     */
    'ownerName': string;
    /**
     * Account owner email
     * @type {string}
     * @memberof CloudAccountInfo
     */
    'ownerEmail': string;
}
/**
 * 
 * @export
 * @interface CloudAuthRequestOptions
 */
export interface CloudAuthRequestOptions {
    /**
     * OAuth identity provider strategy
     * @type {string}
     * @memberof CloudAuthRequestOptions
     */
    'strategy': CloudAuthRequestOptionsStrategyEnum;
    /**
     * Action to perform after authentication
     * @type {string}
     * @memberof CloudAuthRequestOptions
     */
    'action'?: string;
    /**
     * Additional data for the authentication request
     * @type {object}
     * @memberof CloudAuthRequestOptions
     */
    'data'?: object;
    /**
     * Callback function to execute after authentication
     * @type {object}
     * @memberof CloudAuthRequestOptions
     */
    'callback'?: object;
}

export const CloudAuthRequestOptionsStrategyEnum = {
    Google: 'google',
    Github: 'github',
    Sso: 'sso'
} as const;

export type CloudAuthRequestOptionsStrategyEnum = typeof CloudAuthRequestOptionsStrategyEnum[keyof typeof CloudAuthRequestOptionsStrategyEnum];

/**
 * 
 * @export
 * @interface CloudAuthResponse
 */
export interface CloudAuthResponse {
    /**
     * Authentication status
     * @type {string}
     * @memberof CloudAuthResponse
     */
    'status': CloudAuthResponseStatusEnum;
    /**
     * Success or informational message
     * @type {string}
     * @memberof CloudAuthResponse
     */
    'message'?: string;
    /**
     * 
     * @type {CloudAuthResponseError}
     * @memberof CloudAuthResponse
     */
    'error'?: CloudAuthResponseError;
}

export const CloudAuthResponseStatusEnum = {
    Succeed: 'succeed',
    Failed: 'failed'
} as const;

export type CloudAuthResponseStatusEnum = typeof CloudAuthResponseStatusEnum[keyof typeof CloudAuthResponseStatusEnum];

/**
 * @type CloudAuthResponseError
 * Error details if authentication failed
 * @export
 */
export type CloudAuthResponseError = object | string;

/**
 * 
 * @export
 * @interface CloudCapiKey
 */
export interface CloudCapiKey {
    /**
     * 
     * @type {string}
     * @memberof CloudCapiKey
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CloudCapiKey
     */
    'userId': string;
    /**
     * Autogenerated name of capi key (Redisinsight-<RI id>-<ISO date of creation>
     * @type {string}
     * @memberof CloudCapiKey
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CloudCapiKey
     */
    'cloudAccountId': number;
    /**
     * 
     * @type {number}
     * @memberof CloudCapiKey
     */
    'cloudUserId': number;
    /**
     * 
     * @type {string}
     * @memberof CloudCapiKey
     */
    'capiKey': string;
    /**
     * 
     * @type {string}
     * @memberof CloudCapiKey
     */
    'capiSecret': string;
    /**
     * 
     * @type {boolean}
     * @memberof CloudCapiKey
     */
    'valid': boolean;
    /**
     * 
     * @type {string}
     * @memberof CloudCapiKey
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CloudCapiKey
     */
    'lastUsed': string;
}
/**
 * 
 * @export
 * @interface CloudDatabase
 */
export interface CloudDatabase {
    /**
     * Subscription id
     * @type {number}
     * @memberof CloudDatabase
     */
    'subscriptionId': number;
    /**
     * Subscription type
     * @type {string}
     * @memberof CloudDatabase
     */
    'subscriptionType': CloudDatabaseSubscriptionTypeEnum;
    /**
     * Database id
     * @type {number}
     * @memberof CloudDatabase
     */
    'databaseId': number;
    /**
     * Database name
     * @type {string}
     * @memberof CloudDatabase
     */
    'name': string;
    /**
     * Address your Redis Cloud database is available on
     * @type {string}
     * @memberof CloudDatabase
     */
    'publicEndpoint': string;
    /**
     * Database status
     * @type {string}
     * @memberof CloudDatabase
     */
    'status': CloudDatabaseStatusEnum;
    /**
     * Is ssl authentication enabled or not
     * @type {boolean}
     * @memberof CloudDatabase
     */
    'sslClientAuthentication': boolean;
    /**
     * Information about the modules loaded to the database
     * @type {Array<string>}
     * @memberof CloudDatabase
     */
    'modules': Array<string>;
    /**
     * Additional database options
     * @type {object}
     * @memberof CloudDatabase
     */
    'options': object;
    /**
     * Tags associated with the database.
     * @type {Array<Tag>}
     * @memberof CloudDatabase
     */
    'tags': Array<Tag>;
}

export const CloudDatabaseSubscriptionTypeEnum = {
    Flexible: 'flexible',
    Fixed: 'fixed'
} as const;

export type CloudDatabaseSubscriptionTypeEnum = typeof CloudDatabaseSubscriptionTypeEnum[keyof typeof CloudDatabaseSubscriptionTypeEnum];
export const CloudDatabaseStatusEnum = {
    Draft: 'draft',
    Pending: 'pending',
    CreationFailed: 'creation-failed',
    Active: 'active',
    ActiveChangePending: 'active-change-pending',
    ImportPending: 'import-pending',
    DeletePending: 'delete-pending',
    Recovery: 'recovery'
} as const;

export type CloudDatabaseStatusEnum = typeof CloudDatabaseStatusEnum[keyof typeof CloudDatabaseStatusEnum];

/**
 * 
 * @export
 * @interface CloudDatabaseDetails
 */
export interface CloudDatabaseDetails {
    /**
     * Database id from the cloud
     * @type {number}
     * @memberof CloudDatabaseDetails
     */
    'cloudId': number;
    /**
     * Subscription id from the cloud
     * @type {number}
     * @memberof CloudDatabaseDetails
     */
    'subscriptionId': number;
    /**
     * Subscription type
     * @type {string}
     * @memberof CloudDatabaseDetails
     */
    'subscriptionType': CloudDatabaseDetailsSubscriptionTypeEnum;
    /**
     * Plan memory limit
     * @type {number}
     * @memberof CloudDatabaseDetails
     */
    'planMemoryLimit'?: number;
    /**
     * Memory limit units
     * @type {string}
     * @memberof CloudDatabaseDetails
     */
    'memoryLimitMeasurementUnit'?: string;
    /**
     * Is free database
     * @type {boolean}
     * @memberof CloudDatabaseDetails
     */
    'free'?: boolean;
    /**
     * Is subscription using bdb packages
     * @type {boolean}
     * @memberof CloudDatabaseDetails
     */
    'isBdbPackage'?: boolean;
}

export const CloudDatabaseDetailsSubscriptionTypeEnum = {
    Flexible: 'flexible',
    Fixed: 'fixed'
} as const;

export type CloudDatabaseDetailsSubscriptionTypeEnum = typeof CloudDatabaseDetailsSubscriptionTypeEnum[keyof typeof CloudDatabaseDetailsSubscriptionTypeEnum];

/**
 * 
 * @export
 * @interface CloudJobInfo
 */
export interface CloudJobInfo {
    /**
     * 
     * @type {string}
     * @memberof CloudJobInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CloudJobInfo
     */
    'name': CloudJobInfoNameEnum;
    /**
     * 
     * @type {string}
     * @memberof CloudJobInfo
     */
    'status': CloudJobInfoStatusEnum;
    /**
     * Children job if any
     * @type {CloudJobInfo}
     * @memberof CloudJobInfo
     */
    'child'?: CloudJobInfo;
    /**
     * Error if any
     * @type {object}
     * @memberof CloudJobInfo
     */
    'error'?: object;
    /**
     * Job result
     * @type {object}
     * @memberof CloudJobInfo
     */
    'result'?: object;
    /**
     * Job step
     * @type {string}
     * @memberof CloudJobInfo
     */
    'step'?: string;
}

export const CloudJobInfoNameEnum = {
    CreateFreeSubscriptionAndDatabase: 'CREATE_FREE_SUBSCRIPTION_AND_DATABASE',
    CreateFreeDatabase: 'CREATE_FREE_DATABASE',
    CreateFreeSubscription: 'CREATE_FREE_SUBSCRIPTION',
    ImportFreeDatabase: 'IMPORT_FREE_DATABASE',
    WaitForActiveDatabase: 'WAIT_FOR_ACTIVE_DATABASE',
    WaitForActiveSubscription: 'WAIT_FOR_ACTIVE_SUBSCRIPTION',
    WaitForTask: 'WAIT_FOR_TASK',
    Unknown: 'UNKNOWN'
} as const;

export type CloudJobInfoNameEnum = typeof CloudJobInfoNameEnum[keyof typeof CloudJobInfoNameEnum];
export const CloudJobInfoStatusEnum = {
    Initializing: 'initializing',
    Running: 'running',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type CloudJobInfoStatusEnum = typeof CloudJobInfoStatusEnum[keyof typeof CloudJobInfoStatusEnum];

/**
 * 
 * @export
 * @interface CloudSubscription
 */
export interface CloudSubscription {
    /**
     * Subscription id
     * @type {number}
     * @memberof CloudSubscription
     */
    'id': number;
    /**
     * Subscription name
     * @type {string}
     * @memberof CloudSubscription
     */
    'name': string;
    /**
     * Subscription type
     * @type {string}
     * @memberof CloudSubscription
     */
    'type': CloudSubscriptionTypeEnum;
    /**
     * Number of databases in subscription
     * @type {number}
     * @memberof CloudSubscription
     */
    'numberOfDatabases': number;
    /**
     * Subscription status
     * @type {string}
     * @memberof CloudSubscription
     */
    'status': CloudSubscriptionStatusEnum;
    /**
     * Subscription provider
     * @type {string}
     * @memberof CloudSubscription
     */
    'provider'?: string;
    /**
     * Subscription region
     * @type {string}
     * @memberof CloudSubscription
     */
    'region'?: string;
    /**
     * Subscription price
     * @type {number}
     * @memberof CloudSubscription
     */
    'price'?: number;
    /**
     * Determines if subscription is 0 price
     * @type {boolean}
     * @memberof CloudSubscription
     */
    'free'?: boolean;
}

export const CloudSubscriptionTypeEnum = {
    Flexible: 'flexible',
    Fixed: 'fixed'
} as const;

export type CloudSubscriptionTypeEnum = typeof CloudSubscriptionTypeEnum[keyof typeof CloudSubscriptionTypeEnum];
export const CloudSubscriptionStatusEnum = {
    Active: 'active',
    NotActivated: 'not_activated',
    Deleting: 'deleting',
    Pending: 'pending',
    Error: 'error'
} as const;

export type CloudSubscriptionStatusEnum = typeof CloudSubscriptionStatusEnum[keyof typeof CloudSubscriptionStatusEnum];

/**
 * 
 * @export
 * @interface CloudSubscriptionPlanResponse
 */
export interface CloudSubscriptionPlanResponse {
    /**
     * 
     * @type {number}
     * @memberof CloudSubscriptionPlanResponse
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof CloudSubscriptionPlanResponse
     */
    'regionId': number;
    /**
     * Subscription type
     * @type {string}
     * @memberof CloudSubscriptionPlanResponse
     */
    'type': CloudSubscriptionPlanResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CloudSubscriptionPlanResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CloudSubscriptionPlanResponse
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof CloudSubscriptionPlanResponse
     */
    'region'?: string;
    /**
     * 
     * @type {number}
     * @memberof CloudSubscriptionPlanResponse
     */
    'price'?: number;
    /**
     * 
     * @type {CloudSubscriptionRegion}
     * @memberof CloudSubscriptionPlanResponse
     */
    'details': CloudSubscriptionRegion;
}

export const CloudSubscriptionPlanResponseTypeEnum = {
    Flexible: 'flexible',
    Fixed: 'fixed'
} as const;

export type CloudSubscriptionPlanResponseTypeEnum = typeof CloudSubscriptionPlanResponseTypeEnum[keyof typeof CloudSubscriptionPlanResponseTypeEnum];

/**
 * 
 * @export
 * @interface CloudSubscriptionRegion
 */
export interface CloudSubscriptionRegion {
    /**
     * 
     * @type {string}
     * @memberof CloudSubscriptionRegion
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof CloudSubscriptionRegion
     */
    'regionId': number;
    /**
     * 
     * @type {string}
     * @memberof CloudSubscriptionRegion
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CloudSubscriptionRegion
     */
    'displayOrder': number;
    /**
     * 
     * @type {string}
     * @memberof CloudSubscriptionRegion
     */
    'region'?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudSubscriptionRegion
     */
    'provider'?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudSubscriptionRegion
     */
    'cloud'?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudSubscriptionRegion
     */
    'countryName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudSubscriptionRegion
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudSubscriptionRegion
     */
    'flag'?: string;
}
/**
 * 
 * @export
 * @interface CloudUser
 */
export interface CloudUser {
    /**
     * User id
     * @type {number}
     * @memberof CloudUser
     */
    'id'?: number;
    /**
     * User name
     * @type {string}
     * @memberof CloudUser
     */
    'name'?: string;
    /**
     * Current account id
     * @type {number}
     * @memberof CloudUser
     */
    'currentAccountId'?: number;
    /**
     * Cloud API key
     * @type {CloudCapiKey}
     * @memberof CloudUser
     */
    'capiKey'?: CloudCapiKey;
    /**
     * User accounts
     * @type {Array<CloudUserAccount>}
     * @memberof CloudUser
     */
    'accounts'?: Array<CloudUserAccount>;
    /**
     * Additional user data
     * @type {object}
     * @memberof CloudUser
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface CloudUserAccount
 */
export interface CloudUserAccount {
    /**
     * Account id
     * @type {number}
     * @memberof CloudUserAccount
     */
    'id': number;
    /**
     * Account name
     * @type {string}
     * @memberof CloudUserAccount
     */
    'name': string;
    /**
     * Cloud API key
     * @type {string}
     * @memberof CloudUserAccount
     */
    'capiKey': string;
    /**
     * Cloud API secret
     * @type {string}
     * @memberof CloudUserAccount
     */
    'capiSecret': string;
}
/**
 * 
 * @export
 * @interface ClusterConnectionDetailsDto
 */
export interface ClusterConnectionDetailsDto {
    /**
     * The hostname of your Redis Enterprise.
     * @type {string}
     * @memberof ClusterConnectionDetailsDto
     */
    'host': string;
    /**
     * The port your Redis Enterprise cluster is available on.
     * @type {number}
     * @memberof ClusterConnectionDetailsDto
     */
    'port': number;
    /**
     * The admin e-mail/username
     * @type {string}
     * @memberof ClusterConnectionDetailsDto
     */
    'username': string;
    /**
     * The admin password
     * @type {string}
     * @memberof ClusterConnectionDetailsDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ClusterDetails
 */
export interface ClusterDetails {
    /**
     * Redis version
     * @type {string}
     * @memberof ClusterDetails
     */
    'version': string;
    /**
     * Redis mode. Currently one of: standalone, cluster or sentinel
     * @type {string}
     * @memberof ClusterDetails
     */
    'mode': string;
    /**
     * Username from the connection or undefined in case when connected with default user
     * @type {string}
     * @memberof ClusterDetails
     */
    'user'?: string;
    /**
     * Maximum value uptime_in_seconds from all nodes
     * @type {number}
     * @memberof ClusterDetails
     */
    'uptimeSec': number;
    /**
     * cluster_state from CLUSTER INFO command
     * @type {string}
     * @memberof ClusterDetails
     */
    'state': string;
    /**
     * cluster_slots_assigned from CLUSTER INFO command
     * @type {number}
     * @memberof ClusterDetails
     */
    'slotsAssigned': number;
    /**
     * cluster_slots_ok from CLUSTER INFO command
     * @type {number}
     * @memberof ClusterDetails
     */
    'slotsOk': number;
    /**
     * cluster_slots_pfail from CLUSTER INFO command
     * @type {number}
     * @memberof ClusterDetails
     */
    'slotsPFail': number;
    /**
     * cluster_slots_fail from CLUSTER INFO command
     * @type {number}
     * @memberof ClusterDetails
     */
    'slotsFail': number;
    /**
     * Calculated from (16384 - cluster_slots_assigned from CLUSTER INFO command)
     * @type {number}
     * @memberof ClusterDetails
     */
    'slotsUnassigned': number;
    /**
     * cluster_stats_messages_sent from CLUSTER INFO command
     * @type {number}
     * @memberof ClusterDetails
     */
    'statsMessagesSent': number;
    /**
     * cluster_stats_messages_received from CLUSTER INFO command
     * @type {number}
     * @memberof ClusterDetails
     */
    'statsMessagesReceived': number;
    /**
     * cluster_current_epoch from CLUSTER INFO command
     * @type {number}
     * @memberof ClusterDetails
     */
    'currentEpoch': number;
    /**
     * cluster_my_epoch from CLUSTER INFO command
     * @type {number}
     * @memberof ClusterDetails
     */
    'myEpoch': number;
    /**
     * Number of shards. cluster_size from CLUSTER INFO command
     * @type {number}
     * @memberof ClusterDetails
     */
    'size': number;
    /**
     * All nodes number in the Cluster. cluster_known_nodes from CLUSTER INFO command
     * @type {number}
     * @memberof ClusterDetails
     */
    'knownNodes': number;
    /**
     * Details per each node
     * @type {Array<ClusterNodeDetails>}
     * @memberof ClusterDetails
     */
    'nodes': Array<ClusterNodeDetails>;
}
/**
 * 
 * @export
 * @interface ClusterNodeDetails
 */
export interface ClusterNodeDetails {
    /**
     * Node id
     * @type {string}
     * @memberof ClusterNodeDetails
     */
    'id': string;
    /**
     * Redis version
     * @type {string}
     * @memberof ClusterNodeDetails
     */
    'version': string;
    /**
     * Redis mode
     * @type {string}
     * @memberof ClusterNodeDetails
     */
    'mode': string;
    /**
     * Node IP address
     * @type {string}
     * @memberof ClusterNodeDetails
     */
    'host': string;
    /**
     * Node IP address
     * @type {number}
     * @memberof ClusterNodeDetails
     */
    'port': number;
    /**
     * Node role in cluster
     * @type {string}
     * @memberof ClusterNodeDetails
     */
    'role': ClusterNodeDetailsRoleEnum;
    /**
     * ID of primary node (for replica only)
     * @type {string}
     * @memberof ClusterNodeDetails
     */
    'primary'?: string;
    /**
     * Node\'s current health status
     * @type {string}
     * @memberof ClusterNodeDetails
     */
    'health': ClusterNodeDetailsHealthEnum;
    /**
     * Array of assigned slots or slots ranges. Shown for primary nodes only
     * @type {Array<string>}
     * @memberof ClusterNodeDetails
     */
    'slots'?: Array<string>;
    /**
     * Total keys stored inside this node
     * @type {number}
     * @memberof ClusterNodeDetails
     */
    'totalKeys': number;
    /**
     * Memory used by node. \"memory.used_memory\" from INFO command
     * @type {number}
     * @memberof ClusterNodeDetails
     */
    'usedMemory': number;
    /**
     * Current operations per second. \"stats.instantaneous_ops_per_sec\" from INFO command
     * @type {number}
     * @memberof ClusterNodeDetails
     */
    'opsPerSecond': number;
    /**
     * Total connections received by node. \"stats.total_connections_received\" from INFO command
     * @type {number}
     * @memberof ClusterNodeDetails
     */
    'connectionsReceived': number;
    /**
     * Currently connected clients. \"clients.connected_clients\" from INFO command
     * @type {number}
     * @memberof ClusterNodeDetails
     */
    'connectedClients': number;
    /**
     * Total commands processed by node. \"stats.total_commands_processed\" from INFO command
     * @type {number}
     * @memberof ClusterNodeDetails
     */
    'commandsProcessed': number;
    /**
     * Current input network usage in KB/s. \"stats.instantaneous_input_kbps\" from INFO command
     * @type {number}
     * @memberof ClusterNodeDetails
     */
    'networkInKbps': number;
    /**
     * Current output network usage in KB/s. \"stats.instantaneous_output_kbps\" from INFO command
     * @type {number}
     * @memberof ClusterNodeDetails
     */
    'networkOutKbps': number;
    /**
     * Ratio for cache hits and misses [0 - 1]. Ideally should be close to 1
     * @type {number}
     * @memberof ClusterNodeDetails
     */
    'cacheHitRatio'?: number;
    /**
     * The replication offset of this node. This information can be used to send commands to the most up to date replicas.
     * @type {number}
     * @memberof ClusterNodeDetails
     */
    'replicationOffset': number;
    /**
     * For replicas only. Determines on how much replica is behind of primary.
     * @type {number}
     * @memberof ClusterNodeDetails
     */
    'replicationLag'?: number;
    /**
     * Current node uptime_in_seconds
     * @type {number}
     * @memberof ClusterNodeDetails
     */
    'uptimeSec': number;
    /**
     * For primary nodes only. Replica node(s) details
     * @type {Array<ClusterNodeDetails>}
     * @memberof ClusterNodeDetails
     */
    'replicas'?: Array<ClusterNodeDetails>;
}

export const ClusterNodeDetailsRoleEnum = {
    Primary: 'primary',
    Replica: 'replica'
} as const;

export type ClusterNodeDetailsRoleEnum = typeof ClusterNodeDetailsRoleEnum[keyof typeof ClusterNodeDetailsRoleEnum];
export const ClusterNodeDetailsHealthEnum = {
    Online: 'online',
    Offline: 'offline',
    Loading: 'loading'
} as const;

export type ClusterNodeDetailsHealthEnum = typeof ClusterNodeDetailsHealthEnum[keyof typeof ClusterNodeDetailsHealthEnum];

/**
 * 
 * @export
 * @interface CommandExecution
 */
export interface CommandExecution {
    /**
     * Command execution id
     * @type {string}
     * @memberof CommandExecution
     */
    'id': string;
    /**
     * Database id
     * @type {string}
     * @memberof CommandExecution
     */
    'databaseId': string;
    /**
     * Redis command
     * @type {string}
     * @memberof CommandExecution
     */
    'command': string;
    /**
     * Workbench mode
     * @type {string}
     * @memberof CommandExecution
     */
    'mode'?: CommandExecutionModeEnum;
    /**
     * Workbench result mode
     * @type {string}
     * @memberof CommandExecution
     */
    'resultsMode'?: CommandExecutionResultsModeEnum;
    /**
     * Workbench executions summary
     * @type {ResultsSummary}
     * @memberof CommandExecution
     */
    'summary'?: ResultsSummary;
    /**
     * Command execution result
     * @type {Array<CommandExecutionResult>}
     * @memberof CommandExecution
     */
    'result': Array<CommandExecutionResult>;
    /**
     * Result did not stored in db
     * @type {boolean}
     * @memberof CommandExecution
     */
    'isNotStored'?: boolean;
    /**
     * Date of command execution
     * @type {string}
     * @memberof CommandExecution
     */
    'createdAt': string;
    /**
     * Workbench command execution time
     * @type {number}
     * @memberof CommandExecution
     */
    'executionTime'?: number;
    /**
     * Logical database number.
     * @type {number}
     * @memberof CommandExecution
     */
    'db'?: number;
    /**
     * Command execution type. Used to distinguish between search and workbench
     * @type {string}
     * @memberof CommandExecution
     */
    'type'?: CommandExecutionTypeEnum;
}

export const CommandExecutionModeEnum = {
    Raw: 'RAW',
    Ascii: 'ASCII'
} as const;

export type CommandExecutionModeEnum = typeof CommandExecutionModeEnum[keyof typeof CommandExecutionModeEnum];
export const CommandExecutionResultsModeEnum = {
    Default: 'DEFAULT',
    GroupMode: 'GROUP_MODE',
    Silent: 'SILENT'
} as const;

export type CommandExecutionResultsModeEnum = typeof CommandExecutionResultsModeEnum[keyof typeof CommandExecutionResultsModeEnum];
export const CommandExecutionTypeEnum = {
    Workbench: 'WORKBENCH',
    Search: 'SEARCH'
} as const;

export type CommandExecutionTypeEnum = typeof CommandExecutionTypeEnum[keyof typeof CommandExecutionTypeEnum];

/**
 * 
 * @export
 * @interface CommandExecutionFilter
 */
export interface CommandExecutionFilter {
    /**
     * Command execution type. Used to distinguish between search and workbench
     * @type {string}
     * @memberof CommandExecutionFilter
     */
    'type'?: CommandExecutionFilterTypeEnum;
}

export const CommandExecutionFilterTypeEnum = {
    Workbench: 'WORKBENCH',
    Search: 'SEARCH'
} as const;

export type CommandExecutionFilterTypeEnum = typeof CommandExecutionFilterTypeEnum[keyof typeof CommandExecutionFilterTypeEnum];

/**
 * 
 * @export
 * @interface CommandExecutionResult
 */
export interface CommandExecutionResult {
    /**
     * Redis CLI command execution status
     * @type {string}
     * @memberof CommandExecutionResult
     */
    'status': CommandExecutionResultStatusEnum;
    /**
     * Redis response
     * @type {string}
     * @memberof CommandExecutionResult
     */
    'response': string;
    /**
     * Flag showing if response was replaced with message notification about response size limit threshold
     * @type {boolean}
     * @memberof CommandExecutionResult
     */
    'sizeLimitExceeded': boolean;
}

export const CommandExecutionResultStatusEnum = {
    Success: 'success',
    Fail: 'fail'
} as const;

export type CommandExecutionResultStatusEnum = typeof CommandExecutionResultStatusEnum[keyof typeof CommandExecutionResultStatusEnum];

/**
 * 
 * @export
 * @interface ConsumerDto
 */
export interface ConsumerDto {
    /**
     * 
     * @type {ConsumerDtoName}
     * @memberof ConsumerDto
     */
    'name': ConsumerDtoName;
    /**
     * The number of pending messages for the client, which are messages that were delivered but are yet to be acknowledged
     * @type {number}
     * @memberof ConsumerDto
     */
    'pending': number;
    /**
     * The number of milliseconds that have passed since the consumer last interacted with the server
     * @type {number}
     * @memberof ConsumerDto
     */
    'idle': number;
}
/**
 * @type ConsumerDtoName
 * The consumer\'s name
 * @export
 */
export type ConsumerDtoName = CreateListWithExpireDtoKeyNameOneOf | string;

/**
 * 
 * @export
 * @interface ConsumerGroupDto
 */
export interface ConsumerGroupDto {
    /**
     * 
     * @type {ConsumerGroupDtoName}
     * @memberof ConsumerGroupDto
     */
    'name': ConsumerGroupDtoName;
    /**
     * Number of consumers
     * @type {number}
     * @memberof ConsumerGroupDto
     */
    'consumers': number;
    /**
     * Number of pending messages
     * @type {number}
     * @memberof ConsumerGroupDto
     */
    'pending': number;
    /**
     * Smallest Id of the message that is pending in the group
     * @type {string}
     * @memberof ConsumerGroupDto
     */
    'smallestPendingId': string;
    /**
     * Greatest Id of the message that is pending in the group
     * @type {string}
     * @memberof ConsumerGroupDto
     */
    'greatestPendingId': string;
    /**
     * Id of last delivered message
     * @type {string}
     * @memberof ConsumerGroupDto
     */
    'lastDeliveredId': string;
}
/**
 * @type ConsumerGroupDtoName
 * Consumer Group name
 * @export
 */
export type ConsumerGroupDtoName = CreateListWithExpireDtoKeyNameOneOf | string;

/**
 * 
 * @export
 * @interface CreateBasicSshOptionsDto
 */
export interface CreateBasicSshOptionsDto {
    /**
     * The hostname of SSH server
     * @type {string}
     * @memberof CreateBasicSshOptionsDto
     */
    'host': string;
    /**
     * The port of SSH server
     * @type {number}
     * @memberof CreateBasicSshOptionsDto
     */
    'port': number;
    /**
     * SSH username
     * @type {string}
     * @memberof CreateBasicSshOptionsDto
     */
    'username'?: string;
    /**
     * The SSH password
     * @type {string}
     * @memberof CreateBasicSshOptionsDto
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface CreateCaCertificateDto
 */
export interface CreateCaCertificateDto {
    /**
     * Certificate name
     * @type {string}
     * @memberof CreateCaCertificateDto
     */
    'name': string;
    /**
     * Certificate body
     * @type {string}
     * @memberof CreateCaCertificateDto
     */
    'certificate': string;
    /**
     * Whether the certificate was created from a file or environment variables at startup
     * @type {boolean}
     * @memberof CreateCaCertificateDto
     */
    'isPreSetup'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateCertSshOptionsDto
 */
export interface CreateCertSshOptionsDto {
    /**
     * The hostname of SSH server
     * @type {string}
     * @memberof CreateCertSshOptionsDto
     */
    'host': string;
    /**
     * The port of SSH server
     * @type {number}
     * @memberof CreateCertSshOptionsDto
     */
    'port': number;
    /**
     * SSH username
     * @type {string}
     * @memberof CreateCertSshOptionsDto
     */
    'username'?: string;
    /**
     * The SSH private key
     * @type {string}
     * @memberof CreateCertSshOptionsDto
     */
    'privateKey'?: string;
    /**
     * The SSH passphrase
     * @type {string}
     * @memberof CreateCertSshOptionsDto
     */
    'passphrase'?: string;
}
/**
 * 
 * @export
 * @interface CreateCliClientResponse
 */
export interface CreateCliClientResponse {
    /**
     * Client uuid
     * @type {string}
     * @memberof CreateCliClientResponse
     */
    'uuid': string;
}
/**
 * 
 * @export
 * @interface CreateClientCertificateDto
 */
export interface CreateClientCertificateDto {
    /**
     * Certificate name
     * @type {string}
     * @memberof CreateClientCertificateDto
     */
    'name': string;
    /**
     * Certificate body
     * @type {string}
     * @memberof CreateClientCertificateDto
     */
    'certificate': string;
    /**
     * Key body
     * @type {string}
     * @memberof CreateClientCertificateDto
     */
    'key': string;
    /**
     * Whether the certificate was created from a file or environment variables at startup
     * @type {boolean}
     * @memberof CreateClientCertificateDto
     */
    'isPreSetup'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateCloudJobDto
 */
export interface CreateCloudJobDto {
    /**
     * Job name to create
     * @type {string}
     * @memberof CreateCloudJobDto
     */
    'name': CreateCloudJobDtoNameEnum;
    /**
     * Mod in which to run the job.
     * @type {string}
     * @memberof CreateCloudJobDto
     */
    'runMode': CreateCloudJobDtoRunModeEnum;
    /**
     * 
     * @type {CreateCloudJobDtoData}
     * @memberof CreateCloudJobDto
     */
    'data'?: CreateCloudJobDtoData;
}

export const CreateCloudJobDtoNameEnum = {
    CreateFreeSubscriptionAndDatabase: 'CREATE_FREE_SUBSCRIPTION_AND_DATABASE',
    CreateFreeDatabase: 'CREATE_FREE_DATABASE',
    CreateFreeSubscription: 'CREATE_FREE_SUBSCRIPTION',
    ImportFreeDatabase: 'IMPORT_FREE_DATABASE',
    WaitForActiveDatabase: 'WAIT_FOR_ACTIVE_DATABASE',
    WaitForActiveSubscription: 'WAIT_FOR_ACTIVE_SUBSCRIPTION',
    WaitForTask: 'WAIT_FOR_TASK',
    Unknown: 'UNKNOWN'
} as const;

export type CreateCloudJobDtoNameEnum = typeof CreateCloudJobDtoNameEnum[keyof typeof CreateCloudJobDtoNameEnum];
export const CreateCloudJobDtoRunModeEnum = {
    Async: 'async',
    Sync: 'sync'
} as const;

export type CreateCloudJobDtoRunModeEnum = typeof CreateCloudJobDtoRunModeEnum[keyof typeof CreateCloudJobDtoRunModeEnum];

/**
 * @type CreateCloudJobDtoData
 * Any data for create a job.
 * @export
 */
export type CreateCloudJobDtoData = CreateDatabaseCloudJobDataDto | CreateSubscriptionAndDatabaseCloudJobDataDto | ImportDatabaseCloudJobDataDto;

/**
 * 
 * @export
 * @interface CreateCommandExecutionDto
 */
export interface CreateCommandExecutionDto {
    /**
     * Redis command
     * @type {string}
     * @memberof CreateCommandExecutionDto
     */
    'command': string;
    /**
     * Workbench mode
     * @type {string}
     * @memberof CreateCommandExecutionDto
     */
    'mode'?: CreateCommandExecutionDtoModeEnum;
    /**
     * Workbench result mode
     * @type {string}
     * @memberof CreateCommandExecutionDto
     */
    'resultsMode'?: CreateCommandExecutionDtoResultsModeEnum;
    /**
     * Command execution type. Used to distinguish between search and workbench
     * @type {string}
     * @memberof CreateCommandExecutionDto
     */
    'type'?: CreateCommandExecutionDtoTypeEnum;
}

export const CreateCommandExecutionDtoModeEnum = {
    Raw: 'RAW',
    Ascii: 'ASCII'
} as const;

export type CreateCommandExecutionDtoModeEnum = typeof CreateCommandExecutionDtoModeEnum[keyof typeof CreateCommandExecutionDtoModeEnum];
export const CreateCommandExecutionDtoResultsModeEnum = {
    Default: 'DEFAULT',
    GroupMode: 'GROUP_MODE',
    Silent: 'SILENT'
} as const;

export type CreateCommandExecutionDtoResultsModeEnum = typeof CreateCommandExecutionDtoResultsModeEnum[keyof typeof CreateCommandExecutionDtoResultsModeEnum];
export const CreateCommandExecutionDtoTypeEnum = {
    Workbench: 'WORKBENCH',
    Search: 'SEARCH'
} as const;

export type CreateCommandExecutionDtoTypeEnum = typeof CreateCommandExecutionDtoTypeEnum[keyof typeof CreateCommandExecutionDtoTypeEnum];

/**
 * 
 * @export
 * @interface CreateCommandExecutionsDto
 */
export interface CreateCommandExecutionsDto {
    /**
     * Workbench mode
     * @type {string}
     * @memberof CreateCommandExecutionsDto
     */
    'mode'?: CreateCommandExecutionsDtoModeEnum;
    /**
     * Workbench result mode
     * @type {string}
     * @memberof CreateCommandExecutionsDto
     */
    'resultsMode'?: CreateCommandExecutionsDtoResultsModeEnum;
    /**
     * Command execution type. Used to distinguish between search and workbench
     * @type {string}
     * @memberof CreateCommandExecutionsDto
     */
    'type'?: CreateCommandExecutionsDtoTypeEnum;
    /**
     * Redis commands
     * @type {Array<string>}
     * @memberof CreateCommandExecutionsDto
     */
    'commands': Array<string>;
}

export const CreateCommandExecutionsDtoModeEnum = {
    Raw: 'RAW',
    Ascii: 'ASCII'
} as const;

export type CreateCommandExecutionsDtoModeEnum = typeof CreateCommandExecutionsDtoModeEnum[keyof typeof CreateCommandExecutionsDtoModeEnum];
export const CreateCommandExecutionsDtoResultsModeEnum = {
    Default: 'DEFAULT',
    GroupMode: 'GROUP_MODE',
    Silent: 'SILENT'
} as const;

export type CreateCommandExecutionsDtoResultsModeEnum = typeof CreateCommandExecutionsDtoResultsModeEnum[keyof typeof CreateCommandExecutionsDtoResultsModeEnum];
export const CreateCommandExecutionsDtoTypeEnum = {
    Workbench: 'WORKBENCH',
    Search: 'SEARCH'
} as const;

export type CreateCommandExecutionsDtoTypeEnum = typeof CreateCommandExecutionsDtoTypeEnum[keyof typeof CreateCommandExecutionsDtoTypeEnum];

/**
 * 
 * @export
 * @interface CreateConsumerGroupDto
 */
export interface CreateConsumerGroupDto {
    /**
     * 
     * @type {GetConsumersDtoGroupName}
     * @memberof CreateConsumerGroupDto
     */
    'name': GetConsumersDtoGroupName;
    /**
     * Id of last delivered message
     * @type {string}
     * @memberof CreateConsumerGroupDto
     */
    'lastDeliveredId': string;
}
/**
 * 
 * @export
 * @interface CreateConsumerGroupsDto
 */
export interface CreateConsumerGroupsDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof CreateConsumerGroupsDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * List of consumer groups to create
     * @type {Array<CreateConsumerGroupDto>}
     * @memberof CreateConsumerGroupsDto
     */
    'consumerGroups': Array<CreateConsumerGroupDto>;
}
/**
 * 
 * @export
 * @interface CreateDatabaseAnalysisDto
 */
export interface CreateDatabaseAnalysisDto {
    /**
     * Namespace delimiter
     * @type {string}
     * @memberof CreateDatabaseAnalysisDto
     */
    'delimiter': string;
    /**
     * Filters for scan operation
     * @type {ScanFilter}
     * @memberof CreateDatabaseAnalysisDto
     */
    'filter': ScanFilter;
}
/**
 * 
 * @export
 * @interface CreateDatabaseCloudJobDataDto
 */
export interface CreateDatabaseCloudJobDataDto {
    /**
     * Subscription id for create a database.
     * @type {number}
     * @memberof CreateDatabaseCloudJobDataDto
     */
    'subscriptionId': number;
}
/**
 * 
 * @export
 * @interface CreateDatabaseDto
 */
export interface CreateDatabaseDto {
    /**
     * The hostname of your Redis database, for example redis.acme.com. If your Redis server is running on your local machine, you can enter either 127.0.0.1 or localhost.
     * @type {string}
     * @memberof CreateDatabaseDto
     */
    'host': string;
    /**
     * The port your Redis database is available on.
     * @type {number}
     * @memberof CreateDatabaseDto
     */
    'port': number;
    /**
     * A name for your Redis database.
     * @type {string}
     * @memberof CreateDatabaseDto
     */
    'name': string;
    /**
     * Logical database number.
     * @type {number}
     * @memberof CreateDatabaseDto
     */
    'db'?: number;
    /**
     * Database username, if your database is ACL enabled, otherwise leave this field empty.
     * @type {string}
     * @memberof CreateDatabaseDto
     */
    'username'?: string;
    /**
     * The password, if any, for your Redis database. If your database doesnt require a password, leave this field empty.
     * @type {string}
     * @memberof CreateDatabaseDto
     */
    'password'?: string;
    /**
     * Connection timeout
     * @type {number}
     * @memberof CreateDatabaseDto
     */
    'timeout'?: number;
    /**
     * The database name from provider
     * @type {string}
     * @memberof CreateDatabaseDto
     */
    'nameFromProvider'?: string;
    /**
     * The redis database hosting provider
     * @type {string}
     * @memberof CreateDatabaseDto
     */
    'provider'?: string;
    /**
     * Redis OSS Sentinel master group.
     * @type {SentinelMaster}
     * @memberof CreateDatabaseDto
     */
    'sentinelMaster'?: SentinelMaster;
    /**
     * Use TLS to connect.
     * @type {boolean}
     * @memberof CreateDatabaseDto
     */
    'tls'?: boolean;
    /**
     * SNI servername
     * @type {string}
     * @memberof CreateDatabaseDto
     */
    'tlsServername'?: string;
    /**
     * The certificate returned by the server needs to be verified.
     * @type {boolean}
     * @memberof CreateDatabaseDto
     */
    'verifyServerCert'?: boolean;
    /**
     * Use SSH tunnel to connect.
     * @type {boolean}
     * @memberof CreateDatabaseDto
     */
    'ssh'?: boolean;
    /**
     * Cloud details
     * @type {CloudDatabaseDetails}
     * @memberof CreateDatabaseDto
     */
    'cloudDetails'?: CloudDatabaseDetails;
    /**
     * Database compressor
     * @type {string}
     * @memberof CreateDatabaseDto
     */
    'compressor'?: CreateDatabaseDtoCompressorEnum;
    /**
     * Key name format
     * @type {string}
     * @memberof CreateDatabaseDto
     */
    'keyNameFormat'?: CreateDatabaseDtoKeyNameFormatEnum;
    /**
     * Force client connection as standalone
     * @type {boolean}
     * @memberof CreateDatabaseDto
     */
    'forceStandalone'?: boolean;
    /**
     * 
     * @type {CreateDatabaseDtoCaCert}
     * @memberof CreateDatabaseDto
     */
    'caCert'?: CreateDatabaseDtoCaCert;
    /**
     * 
     * @type {CreateDatabaseDtoClientCert}
     * @memberof CreateDatabaseDto
     */
    'clientCert'?: CreateDatabaseDtoClientCert;
    /**
     * 
     * @type {CreateDatabaseDtoSshOptions}
     * @memberof CreateDatabaseDto
     */
    'sshOptions'?: CreateDatabaseDtoSshOptions;
    /**
     * Tags associated with the database.
     * @type {Array<CreateTagDto>}
     * @memberof CreateDatabaseDto
     */
    'tags'?: Array<CreateTagDto>;
}

export const CreateDatabaseDtoCompressorEnum = {
    None: 'NONE',
    Gzip: 'GZIP',
    Zstd: 'ZSTD',
    Lz4: 'LZ4',
    Snappy: 'SNAPPY',
    Brotli: 'Brotli',
    PhpgzCompress: 'PHPGZCompress'
} as const;

export type CreateDatabaseDtoCompressorEnum = typeof CreateDatabaseDtoCompressorEnum[keyof typeof CreateDatabaseDtoCompressorEnum];
export const CreateDatabaseDtoKeyNameFormatEnum = {
    Unicode: 'Unicode',
    Hex: 'HEX'
} as const;

export type CreateDatabaseDtoKeyNameFormatEnum = typeof CreateDatabaseDtoKeyNameFormatEnum[keyof typeof CreateDatabaseDtoKeyNameFormatEnum];

/**
 * @type CreateDatabaseDtoCaCert
 * CA Certificate
 * @export
 */
export type CreateDatabaseDtoCaCert = CreateCaCertificateDto | UseCaCertificateDto;

/**
 * @type CreateDatabaseDtoClientCert
 * Client Certificate
 * @export
 */
export type CreateDatabaseDtoClientCert = CreateClientCertificateDto | UseCaCertificateDto;

/**
 * @type CreateDatabaseDtoSshOptions
 * SSH Options
 * @export
 */
export type CreateDatabaseDtoSshOptions = CreateBasicSshOptionsDto | CreateCertSshOptionsDto;

/**
 * 
 * @export
 * @interface CreateHashWithExpireDto
 */
export interface CreateHashWithExpireDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof CreateHashWithExpireDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Hash fields
     * @type {Array<HashFieldDto>}
     * @memberof CreateHashWithExpireDto
     */
    'fields': Array<HashFieldDto>;
    /**
     * Set a timeout on key in seconds. After the timeout has expired, the key will automatically be deleted.
     * @type {number}
     * @memberof CreateHashWithExpireDto
     */
    'expire'?: number;
}
/**
 * 
 * @export
 * @interface CreateListWithExpireDto
 */
export interface CreateListWithExpireDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof CreateListWithExpireDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * List element(s)
     * @type {Array<CreateListWithExpireDtoElementsInner>}
     * @memberof CreateListWithExpireDto
     */
    'elements': Array<CreateListWithExpireDtoElementsInner>;
    /**
     * In order to append elements to the end of the list, use the TAIL value, to prepend use HEAD value. Default: TAIL (when not specified)
     * @type {string}
     * @memberof CreateListWithExpireDto
     */
    'destination'?: CreateListWithExpireDtoDestinationEnum;
    /**
     * Set a timeout on key in seconds. After the timeout has expired, the key will automatically be deleted.
     * @type {number}
     * @memberof CreateListWithExpireDto
     */
    'expire'?: number;
}

export const CreateListWithExpireDtoDestinationEnum = {
    Tail: 'TAIL',
    Head: 'HEAD'
} as const;

export type CreateListWithExpireDtoDestinationEnum = typeof CreateListWithExpireDtoDestinationEnum[keyof typeof CreateListWithExpireDtoDestinationEnum];

/**
 * @type CreateListWithExpireDtoElementsInner
 * @export
 */
export type CreateListWithExpireDtoElementsInner = CreateListWithExpireDtoKeyNameOneOf | string;

/**
 * @type CreateListWithExpireDtoKeyName
 * Key Name
 * @export
 */
export type CreateListWithExpireDtoKeyName = CreateListWithExpireDtoKeyNameOneOf | string;

/**
 * 
 * @export
 * @interface CreateListWithExpireDtoKeyNameOneOf
 */
export interface CreateListWithExpireDtoKeyNameOneOf {
    /**
     * 
     * @type {string}
     * @memberof CreateListWithExpireDtoKeyNameOneOf
     */
    'type': CreateListWithExpireDtoKeyNameOneOfTypeEnum;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateListWithExpireDtoKeyNameOneOf
     */
    'data': Array<number>;
}

export const CreateListWithExpireDtoKeyNameOneOfTypeEnum = {
    Buffer: 'Buffer'
} as const;

export type CreateListWithExpireDtoKeyNameOneOfTypeEnum = typeof CreateListWithExpireDtoKeyNameOneOfTypeEnum[keyof typeof CreateListWithExpireDtoKeyNameOneOfTypeEnum];

/**
 * 
 * @export
 * @interface CreateOrUpdateDatabaseSettingDto
 */
export interface CreateOrUpdateDatabaseSettingDto {
    /**
     * Applied settings by user, by database
     * @type {object}
     * @memberof CreateOrUpdateDatabaseSettingDto
     */
    'data': object;
}
/**
 * 
 * @export
 * @interface CreatePluginStateDto
 */
export interface CreatePluginStateDto {
    /**
     * State can be anything except \"undefined\"
     * @type {string}
     * @memberof CreatePluginStateDto
     */
    'state': string;
}
/**
 * 
 * @export
 * @interface CreateRdiDto
 */
export interface CreateRdiDto {
    /**
     * Base url of API to connect to (for API type only)
     * @type {string}
     * @memberof CreateRdiDto
     */
    'url'?: string;
    /**
     * A name to associate with RDI
     * @type {string}
     * @memberof CreateRdiDto
     */
    'name': string;
    /**
     * RDI or API username
     * @type {string}
     * @memberof CreateRdiDto
     */
    'username'?: string;
    /**
     * RDI or API password
     * @type {string}
     * @memberof CreateRdiDto
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface CreateRedisearchIndexDto
 */
export interface CreateRedisearchIndexDto {
    /**
     * 
     * @type {CreateRedisearchIndexDtoIndex}
     * @memberof CreateRedisearchIndexDto
     */
    'index': CreateRedisearchIndexDtoIndex;
    /**
     * Type of keys to index
     * @type {string}
     * @memberof CreateRedisearchIndexDto
     */
    'type': CreateRedisearchIndexDtoTypeEnum;
    /**
     * Keys prefixes to find keys for index
     * @type {Array<CreateListWithExpireDtoElementsInner>}
     * @memberof CreateRedisearchIndexDto
     */
    'prefixes'?: Array<CreateListWithExpireDtoElementsInner>;
    /**
     * Fields to index
     * @type {Array<CreateRedisearchIndexFieldDto>}
     * @memberof CreateRedisearchIndexDto
     */
    'fields': Array<CreateRedisearchIndexFieldDto>;
}

export const CreateRedisearchIndexDtoTypeEnum = {
    Hash: 'hash',
    Json: 'json'
} as const;

export type CreateRedisearchIndexDtoTypeEnum = typeof CreateRedisearchIndexDtoTypeEnum[keyof typeof CreateRedisearchIndexDtoTypeEnum];

/**
 * @type CreateRedisearchIndexDtoIndex
 * Index Name
 * @export
 */
export type CreateRedisearchIndexDtoIndex = CreateListWithExpireDtoKeyNameOneOf | string;

/**
 * 
 * @export
 * @interface CreateRedisearchIndexFieldDto
 */
export interface CreateRedisearchIndexFieldDto {
    /**
     * 
     * @type {CreateRedisearchIndexFieldDtoName}
     * @memberof CreateRedisearchIndexFieldDto
     */
    'name': CreateRedisearchIndexFieldDtoName;
    /**
     * Type of how data must be indexed
     * @type {string}
     * @memberof CreateRedisearchIndexFieldDto
     */
    'type': CreateRedisearchIndexFieldDtoTypeEnum;
}

export const CreateRedisearchIndexFieldDtoTypeEnum = {
    Text: 'text',
    Tag: 'tag',
    Numeric: 'numeric',
    Geo: 'geo',
    Geoshape: 'geoshape',
    Vector: 'vector'
} as const;

export type CreateRedisearchIndexFieldDtoTypeEnum = typeof CreateRedisearchIndexFieldDtoTypeEnum[keyof typeof CreateRedisearchIndexFieldDtoTypeEnum];

/**
 * @type CreateRedisearchIndexFieldDtoName
 * Name of field to be indexed
 * @export
 */
export type CreateRedisearchIndexFieldDtoName = CreateListWithExpireDtoKeyNameOneOf | string;

/**
 * 
 * @export
 * @interface CreateRejsonRlWithExpireDto
 */
export interface CreateRejsonRlWithExpireDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof CreateRejsonRlWithExpireDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Valid json string
     * @type {string}
     * @memberof CreateRejsonRlWithExpireDto
     */
    'data': string;
    /**
     * Set a timeout on key in seconds. After the timeout has expired, the key will automatically be deleted.
     * @type {number}
     * @memberof CreateRejsonRlWithExpireDto
     */
    'expire'?: number;
}
/**
 * 
 * @export
 * @interface CreateSentinelDatabaseDto
 */
export interface CreateSentinelDatabaseDto {
    /**
     * The name under which the base will be saved in the application.
     * @type {string}
     * @memberof CreateSentinelDatabaseDto
     */
    'alias': string;
    /**
     * Sentinel master group name.
     * @type {string}
     * @memberof CreateSentinelDatabaseDto
     */
    'name': string;
    /**
     * The username, if your database is ACL enabled, otherwise leave this field empty.
     * @type {string}
     * @memberof CreateSentinelDatabaseDto
     */
    'username'?: string;
    /**
     * The password, if any, for your Redis database. If your database doesnt require a password, leave this field empty.
     * @type {string}
     * @memberof CreateSentinelDatabaseDto
     */
    'password'?: string;
    /**
     * Logical database number.
     * @type {number}
     * @memberof CreateSentinelDatabaseDto
     */
    'db'?: number;
}
/**
 * 
 * @export
 * @interface CreateSentinelDatabaseResponse
 */
export interface CreateSentinelDatabaseResponse {
    /**
     * Database instance id.
     * @type {string}
     * @memberof CreateSentinelDatabaseResponse
     */
    'id'?: string;
    /**
     * Sentinel master group name.
     * @type {string}
     * @memberof CreateSentinelDatabaseResponse
     */
    'name': string;
    /**
     * Add Sentinel Master status
     * @type {string}
     * @memberof CreateSentinelDatabaseResponse
     */
    'status': CreateSentinelDatabaseResponseStatusEnum;
    /**
     * Message
     * @type {string}
     * @memberof CreateSentinelDatabaseResponse
     */
    'message': string;
    /**
     * Error
     * @type {object}
     * @memberof CreateSentinelDatabaseResponse
     */
    'error'?: object;
}

export const CreateSentinelDatabaseResponseStatusEnum = {
    Success: 'success',
    Fail: 'fail'
} as const;

export type CreateSentinelDatabaseResponseStatusEnum = typeof CreateSentinelDatabaseResponseStatusEnum[keyof typeof CreateSentinelDatabaseResponseStatusEnum];

/**
 * 
 * @export
 * @interface CreateSentinelDatabasesDto
 */
export interface CreateSentinelDatabasesDto {
    /**
     * The hostname of your Redis database, for example redis.acme.com. If your Redis server is running on your local machine, you can enter either 127.0.0.1 or localhost.
     * @type {string}
     * @memberof CreateSentinelDatabasesDto
     */
    'host': string;
    /**
     * The port your Redis database is available on.
     * @type {number}
     * @memberof CreateSentinelDatabasesDto
     */
    'port': number;
    /**
     * Logical database number.
     * @type {number}
     * @memberof CreateSentinelDatabasesDto
     */
    'db'?: number;
    /**
     * Database username, if your database is ACL enabled, otherwise leave this field empty.
     * @type {string}
     * @memberof CreateSentinelDatabasesDto
     */
    'username'?: string;
    /**
     * The password, if any, for your Redis database. If your database doesnt require a password, leave this field empty.
     * @type {string}
     * @memberof CreateSentinelDatabasesDto
     */
    'password'?: string;
    /**
     * Connection timeout
     * @type {number}
     * @memberof CreateSentinelDatabasesDto
     */
    'timeout'?: number;
    /**
     * The database name from provider
     * @type {string}
     * @memberof CreateSentinelDatabasesDto
     */
    'nameFromProvider'?: string;
    /**
     * The redis database hosting provider
     * @type {string}
     * @memberof CreateSentinelDatabasesDto
     */
    'provider'?: string;
    /**
     * Redis OSS Sentinel master group.
     * @type {SentinelMaster}
     * @memberof CreateSentinelDatabasesDto
     */
    'sentinelMaster'?: SentinelMaster;
    /**
     * Use TLS to connect.
     * @type {boolean}
     * @memberof CreateSentinelDatabasesDto
     */
    'tls'?: boolean;
    /**
     * SNI servername
     * @type {string}
     * @memberof CreateSentinelDatabasesDto
     */
    'tlsServername'?: string;
    /**
     * The certificate returned by the server needs to be verified.
     * @type {boolean}
     * @memberof CreateSentinelDatabasesDto
     */
    'verifyServerCert'?: boolean;
    /**
     * Use SSH tunnel to connect.
     * @type {boolean}
     * @memberof CreateSentinelDatabasesDto
     */
    'ssh'?: boolean;
    /**
     * Cloud details
     * @type {CloudDatabaseDetails}
     * @memberof CreateSentinelDatabasesDto
     */
    'cloudDetails'?: CloudDatabaseDetails;
    /**
     * Database compressor
     * @type {string}
     * @memberof CreateSentinelDatabasesDto
     */
    'compressor'?: CreateSentinelDatabasesDtoCompressorEnum;
    /**
     * Key name format
     * @type {string}
     * @memberof CreateSentinelDatabasesDto
     */
    'keyNameFormat'?: CreateSentinelDatabasesDtoKeyNameFormatEnum;
    /**
     * Force client connection as standalone
     * @type {boolean}
     * @memberof CreateSentinelDatabasesDto
     */
    'forceStandalone'?: boolean;
    /**
     * 
     * @type {CreateDatabaseDtoCaCert}
     * @memberof CreateSentinelDatabasesDto
     */
    'caCert'?: CreateDatabaseDtoCaCert;
    /**
     * 
     * @type {CreateDatabaseDtoClientCert}
     * @memberof CreateSentinelDatabasesDto
     */
    'clientCert'?: CreateDatabaseDtoClientCert;
    /**
     * 
     * @type {CreateDatabaseDtoSshOptions}
     * @memberof CreateSentinelDatabasesDto
     */
    'sshOptions'?: CreateDatabaseDtoSshOptions;
    /**
     * Tags associated with the database.
     * @type {Array<CreateTagDto>}
     * @memberof CreateSentinelDatabasesDto
     */
    'tags'?: Array<CreateTagDto>;
    /**
     * The Sentinel master group list.
     * @type {Array<CreateSentinelDatabaseDto>}
     * @memberof CreateSentinelDatabasesDto
     */
    'masters': Array<CreateSentinelDatabaseDto>;
}

export const CreateSentinelDatabasesDtoCompressorEnum = {
    None: 'NONE',
    Gzip: 'GZIP',
    Zstd: 'ZSTD',
    Lz4: 'LZ4',
    Snappy: 'SNAPPY',
    Brotli: 'Brotli',
    PhpgzCompress: 'PHPGZCompress'
} as const;

export type CreateSentinelDatabasesDtoCompressorEnum = typeof CreateSentinelDatabasesDtoCompressorEnum[keyof typeof CreateSentinelDatabasesDtoCompressorEnum];
export const CreateSentinelDatabasesDtoKeyNameFormatEnum = {
    Unicode: 'Unicode',
    Hex: 'HEX'
} as const;

export type CreateSentinelDatabasesDtoKeyNameFormatEnum = typeof CreateSentinelDatabasesDtoKeyNameFormatEnum[keyof typeof CreateSentinelDatabasesDtoKeyNameFormatEnum];

/**
 * 
 * @export
 * @interface CreateSetWithExpireDto
 */
export interface CreateSetWithExpireDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof CreateSetWithExpireDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Set members
     * @type {Array<CreateListWithExpireDtoElementsInner>}
     * @memberof CreateSetWithExpireDto
     */
    'members': Array<CreateListWithExpireDtoElementsInner>;
    /**
     * Set a timeout on key in seconds. After the timeout has expired, the key will automatically be deleted.
     * @type {number}
     * @memberof CreateSetWithExpireDto
     */
    'expire'?: number;
}
/**
 * 
 * @export
 * @interface CreateStreamDto
 */
export interface CreateStreamDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof CreateStreamDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Entries to push
     * @type {Array<StreamEntryDto>}
     * @memberof CreateStreamDto
     */
    'entries': Array<StreamEntryDto>;
    /**
     * Set a timeout on key in seconds. After the timeout has expired, the key will automatically be deleted.
     * @type {number}
     * @memberof CreateStreamDto
     */
    'expire'?: number;
}
/**
 * 
 * @export
 * @interface CreateSubscriptionAndDatabaseCloudJobDataDto
 */
export interface CreateSubscriptionAndDatabaseCloudJobDataDto {
    /**
     * Plan id for create a subscription.
     * @type {number}
     * @memberof CreateSubscriptionAndDatabaseCloudJobDataDto
     */
    'planId': number;
    /**
     * Use recommended settings
     * @type {boolean}
     * @memberof CreateSubscriptionAndDatabaseCloudJobDataDto
     */
    'isRecommendedSettings'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateTagDto
 */
export interface CreateTagDto {
    /**
     * Key of the tag.
     * @type {string}
     * @memberof CreateTagDto
     */
    'key': string;
    /**
     * Value of the tag.
     * @type {string}
     * @memberof CreateTagDto
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface CreateZSetWithExpireDto
 */
export interface CreateZSetWithExpireDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof CreateZSetWithExpireDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * ZSet members
     * @type {Array<ZSetMemberDto>}
     * @memberof CreateZSetWithExpireDto
     */
    'members': Array<ZSetMemberDto>;
    /**
     * Set a timeout on key in seconds. After the timeout has expired, the key will automatically be deleted.
     * @type {number}
     * @memberof CreateZSetWithExpireDto
     */
    'expire'?: number;
}
/**
 * 
 * @export
 * @interface CustomTutorialManifest
 */
export interface CustomTutorialManifest {
    /**
     * 
     * @type {string}
     * @memberof CustomTutorialManifest
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CustomTutorialManifest
     */
    'type': CustomTutorialManifestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CustomTutorialManifest
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof CustomTutorialManifest
     */
    'summary': string;
    /**
     * 
     * @type {CustomTutorialManifestArgs}
     * @memberof CustomTutorialManifest
     */
    'args'?: CustomTutorialManifestArgs;
    /**
     * 
     * @type {CustomTutorialManifest}
     * @memberof CustomTutorialManifest
     */
    'children'?: CustomTutorialManifest;
}

export const CustomTutorialManifestTypeEnum = {
    CodeButton: 'code-button',
    Group: 'group',
    InternalLink: 'internal-link'
} as const;

export type CustomTutorialManifestTypeEnum = typeof CustomTutorialManifestTypeEnum[keyof typeof CustomTutorialManifestTypeEnum];

/**
 * 
 * @export
 * @interface CustomTutorialManifestArgs
 */
export interface CustomTutorialManifestArgs {
    /**
     * 
     * @type {boolean}
     * @memberof CustomTutorialManifestArgs
     */
    'path'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomTutorialManifestArgs
     */
    'initialIsOpen'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomTutorialManifestArgs
     */
    'withBorder'?: boolean;
}
/**
 * 
 * @export
 * @interface Database
 */
export interface Database {
    /**
     * Database id.
     * @type {string}
     * @memberof Database
     */
    'id': string;
    /**
     * The hostname of your Redis database, for example redis.acme.com. If your Redis server is running on your local machine, you can enter either 127.0.0.1 or localhost.
     * @type {string}
     * @memberof Database
     */
    'host': string;
    /**
     * The port your Redis database is available on.
     * @type {number}
     * @memberof Database
     */
    'port': number;
    /**
     * A name for your Redis database.
     * @type {string}
     * @memberof Database
     */
    'name': string;
    /**
     * Logical database number.
     * @type {number}
     * @memberof Database
     */
    'db'?: number;
    /**
     * Database username, if your database is ACL enabled, otherwise leave this field empty.
     * @type {string}
     * @memberof Database
     */
    'username'?: string;
    /**
     * The password, if any, for your Redis database. If your database doesnt require a password, leave this field empty.
     * @type {string}
     * @memberof Database
     */
    'password'?: string;
    /**
     * Connection timeout
     * @type {number}
     * @memberof Database
     */
    'timeout'?: number;
    /**
     * Connection Type
     * @type {string}
     * @memberof Database
     */
    'connectionType': DatabaseConnectionTypeEnum;
    /**
     * The database name from provider
     * @type {string}
     * @memberof Database
     */
    'nameFromProvider'?: string;
    /**
     * The redis database hosting provider
     * @type {string}
     * @memberof Database
     */
    'provider'?: string;
    /**
     * Time of the last connection to the database.
     * @type {string}
     * @memberof Database
     */
    'lastConnection': string;
    /**
     * Date of creation
     * @type {string}
     * @memberof Database
     */
    'createdAt': string;
    /**
     * Redis OSS Sentinel master group.
     * @type {SentinelMaster}
     * @memberof Database
     */
    'sentinelMaster'?: SentinelMaster;
    /**
     * OSS Cluster Nodes
     * @type {Array<Endpoint>}
     * @memberof Database
     */
    'nodes'?: Array<Endpoint>;
    /**
     * Loaded Redis modules.
     * @type {Array<AdditionalRedisModule>}
     * @memberof Database
     */
    'modules'?: Array<AdditionalRedisModule>;
    /**
     * Use TLS to connect.
     * @type {boolean}
     * @memberof Database
     */
    'tls'?: boolean;
    /**
     * SNI servername
     * @type {string}
     * @memberof Database
     */
    'tlsServername'?: string;
    /**
     * The certificate returned by the server needs to be verified.
     * @type {boolean}
     * @memberof Database
     */
    'verifyServerCert'?: boolean;
    /**
     * CA Certificate
     * @type {CaCertificate}
     * @memberof Database
     */
    'caCert'?: CaCertificate;
    /**
     * Client Certificate
     * @type {ClientCertificate}
     * @memberof Database
     */
    'clientCert'?: ClientCertificate;
    /**
     * A new created connection
     * @type {boolean}
     * @memberof Database
     */
    'new'?: boolean;
    /**
     * Use SSH tunnel to connect.
     * @type {boolean}
     * @memberof Database
     */
    'ssh'?: boolean;
    /**
     * SSH options
     * @type {SshOptions}
     * @memberof Database
     */
    'sshOptions'?: SshOptions;
    /**
     * Cloud details
     * @type {CloudDatabaseDetails}
     * @memberof Database
     */
    'cloudDetails'?: CloudDatabaseDetails;
    /**
     * Database compressor
     * @type {string}
     * @memberof Database
     */
    'compressor'?: DatabaseCompressorEnum;
    /**
     * Key name format
     * @type {string}
     * @memberof Database
     */
    'keyNameFormat'?: DatabaseKeyNameFormatEnum;
    /**
     * The version your Redis server
     * @type {string}
     * @memberof Database
     */
    'version'?: string;
    /**
     * Force client connection as standalone
     * @type {boolean}
     * @memberof Database
     */
    'forceStandalone'?: boolean;
    /**
     * Tags associated with the database.
     * @type {Array<Tag>}
     * @memberof Database
     */
    'tags'?: Array<Tag>;
    /**
     * Whether the database was created from a file or environment variables at startup
     * @type {boolean}
     * @memberof Database
     */
    'isPreSetup'?: boolean;
}

export const DatabaseConnectionTypeEnum = {
    Standalone: 'STANDALONE',
    Cluster: 'CLUSTER',
    Sentinel: 'SENTINEL',
    NotConnected: 'NOT CONNECTED'
} as const;

export type DatabaseConnectionTypeEnum = typeof DatabaseConnectionTypeEnum[keyof typeof DatabaseConnectionTypeEnum];
export const DatabaseCompressorEnum = {
    None: 'NONE',
    Gzip: 'GZIP',
    Zstd: 'ZSTD',
    Lz4: 'LZ4',
    Snappy: 'SNAPPY',
    Brotli: 'Brotli',
    PhpgzCompress: 'PHPGZCompress'
} as const;

export type DatabaseCompressorEnum = typeof DatabaseCompressorEnum[keyof typeof DatabaseCompressorEnum];
export const DatabaseKeyNameFormatEnum = {
    Unicode: 'Unicode',
    Hex: 'HEX'
} as const;

export type DatabaseKeyNameFormatEnum = typeof DatabaseKeyNameFormatEnum[keyof typeof DatabaseKeyNameFormatEnum];

/**
 * 
 * @export
 * @interface DatabaseAnalysis
 */
export interface DatabaseAnalysis {
    /**
     * Analysis id
     * @type {string}
     * @memberof DatabaseAnalysis
     */
    'id': string;
    /**
     * Database id
     * @type {string}
     * @memberof DatabaseAnalysis
     */
    'databaseId': string;
    /**
     * Filters for scan operation
     * @type {ScanFilter}
     * @memberof DatabaseAnalysis
     */
    'filter': ScanFilter;
    /**
     * Namespace delimiter
     * @type {string}
     * @memberof DatabaseAnalysis
     */
    'delimiter': string;
    /**
     * Analysis progress
     * @type {AnalysisProgress}
     * @memberof DatabaseAnalysis
     */
    'progress': AnalysisProgress;
    /**
     * Analysis created date (ISO string)
     * @type {string}
     * @memberof DatabaseAnalysis
     */
    'createdAt': string;
    /**
     * Total keys with details by types
     * @type {SimpleSummary}
     * @memberof DatabaseAnalysis
     */
    'totalKeys': SimpleSummary;
    /**
     * Total memory with details by types
     * @type {SimpleSummary}
     * @memberof DatabaseAnalysis
     */
    'totalMemory': SimpleSummary;
    /**
     * Top namespaces by keys number
     * @type {Array<NspSummary>}
     * @memberof DatabaseAnalysis
     */
    'topKeysNsp': Array<NspSummary>;
    /**
     * Top namespaces by memory
     * @type {Array<NspSummary>}
     * @memberof DatabaseAnalysis
     */
    'topMemoryNsp': Array<NspSummary>;
    /**
     * Top keys by key length (string length, list elements count, etc.)
     * @type {Array<Key>}
     * @memberof DatabaseAnalysis
     */
    'topKeysLength': Array<Key>;
    /**
     * Top keys by memory used
     * @type {Array<Key>}
     * @memberof DatabaseAnalysis
     */
    'topKeysMemory': Array<Key>;
    /**
     * Expiration groups
     * @type {Array<SumGroup>}
     * @memberof DatabaseAnalysis
     */
    'expirationGroups': Array<SumGroup>;
    /**
     * Recommendations
     * @type {Array<Recommendation>}
     * @memberof DatabaseAnalysis
     */
    'recommendations': Array<Recommendation>;
    /**
     * Logical database number.
     * @type {number}
     * @memberof DatabaseAnalysis
     */
    'db'?: number;
}
/**
 * 
 * @export
 * @interface DatabaseImportResponse
 */
export interface DatabaseImportResponse {
    /**
     * Total elements processed from the import file
     * @type {number}
     * @memberof DatabaseImportResponse
     */
    'total': number;
    /**
     * List of successfully imported database
     * @type {DatabaseImportResult}
     * @memberof DatabaseImportResponse
     */
    'success': DatabaseImportResult;
    /**
     * List of partially imported database
     * @type {DatabaseImportResult}
     * @memberof DatabaseImportResponse
     */
    'partial': DatabaseImportResult;
    /**
     * List of databases failed to import
     * @type {DatabaseImportResult}
     * @memberof DatabaseImportResponse
     */
    'fail': DatabaseImportResult;
}
/**
 * 
 * @export
 * @interface DatabaseImportResult
 */
export interface DatabaseImportResult {
    /**
     * Entry index from original json
     * @type {number}
     * @memberof DatabaseImportResult
     */
    'index': number;
    /**
     * Import status
     * @type {string}
     * @memberof DatabaseImportResult
     */
    'status': DatabaseImportResultStatusEnum;
    /**
     * Database host
     * @type {string}
     * @memberof DatabaseImportResult
     */
    'host'?: string;
    /**
     * Database port
     * @type {number}
     * @memberof DatabaseImportResult
     */
    'port'?: number;
    /**
     * Error message if any
     * @type {string}
     * @memberof DatabaseImportResult
     */
    'errors'?: string;
}

export const DatabaseImportResultStatusEnum = {
    Success: 'success',
    Partial: 'partial',
    Fail: 'fail'
} as const;

export type DatabaseImportResultStatusEnum = typeof DatabaseImportResultStatusEnum[keyof typeof DatabaseImportResultStatusEnum];

/**
 * 
 * @export
 * @interface DatabaseOverview
 */
export interface DatabaseOverview {
    /**
     * Redis database version
     * @type {string}
     * @memberof DatabaseOverview
     */
    'version': string;
    /**
     * Total number of bytes allocated by Redis primary shards
     * @type {number}
     * @memberof DatabaseOverview
     */
    'usedMemory'?: number;
    /**
     * Cloud details
     * @type {CloudDatabaseDetails}
     * @memberof DatabaseOverview
     */
    'cloudDetails'?: CloudDatabaseDetails;
    /**
     * Total number of keys inside Redis primary shards
     * @type {number}
     * @memberof DatabaseOverview
     */
    'totalKeys'?: number;
    /**
     * Nested object with total number of keys per logical database
     * @type {number}
     * @memberof DatabaseOverview
     */
    'totalKeysPerDb'?: number;
    /**
     * Median for connected clients in the all shards
     * @type {number}
     * @memberof DatabaseOverview
     */
    'connectedClients'?: number;
    /**
     * Sum of current commands per second in the all shards
     * @type {number}
     * @memberof DatabaseOverview
     */
    'opsPerSecond'?: number;
    /**
     * Sum of current network input in the all shards (kbps)
     * @type {number}
     * @memberof DatabaseOverview
     */
    'networkInKbps'?: number;
    /**
     * Sum of current network out in the all shards (kbps)
     * @type {number}
     * @memberof DatabaseOverview
     */
    'networkOutKbps'?: number;
    /**
     * Sum of current cpu usage in the all shards (%)
     * @type {number}
     * @memberof DatabaseOverview
     */
    'cpuUsagePercentage'?: number;
    /**
     * Database server name
     * @type {string}
     * @memberof DatabaseOverview
     */
    'serverName': string;
}
/**
 * 
 * @export
 * @interface DatabaseRecommendation
 */
export interface DatabaseRecommendation {
    /**
     * Recommendation id
     * @type {string}
     * @memberof DatabaseRecommendation
     */
    'id': string;
    /**
     * Recommendation name
     * @type {string}
     * @memberof DatabaseRecommendation
     */
    'name': string;
    /**
     * Database ID to which recommendation belongs
     * @type {string}
     * @memberof DatabaseRecommendation
     */
    'databaseId': string;
    /**
     * Determines if recommendation was shown to user
     * @type {boolean}
     * @memberof DatabaseRecommendation
     */
    'read'?: boolean;
    /**
     * Should this recommendation shown to user
     * @type {boolean}
     * @memberof DatabaseRecommendation
     */
    'disabled'?: boolean;
    /**
     * Recommendation vote
     * @type {string}
     * @memberof DatabaseRecommendation
     */
    'vote'?: DatabaseRecommendationVoteEnum;
    /**
     * Should this recommendation hidden
     * @type {boolean}
     * @memberof DatabaseRecommendation
     */
    'hide'?: boolean;
    /**
     * Additional recommendation params
     * @type {object}
     * @memberof DatabaseRecommendation
     */
    'params'?: object;
}

export const DatabaseRecommendationVoteEnum = {
    VeryUseful: 'very useful',
    Useful: 'useful',
    NotUseful: 'not useful'
} as const;

export type DatabaseRecommendationVoteEnum = typeof DatabaseRecommendationVoteEnum[keyof typeof DatabaseRecommendationVoteEnum];

/**
 * 
 * @export
 * @interface DatabaseRecommendationsResponse
 */
export interface DatabaseRecommendationsResponse {
    /**
     * Ordered recommendations list
     * @type {Array<DatabaseRecommendation>}
     * @memberof DatabaseRecommendationsResponse
     */
    'recommendations': Array<DatabaseRecommendation>;
    /**
     * Number of unread recommendations
     * @type {number}
     * @memberof DatabaseRecommendationsResponse
     */
    'totalUnread': number;
}
/**
 * 
 * @export
 * @interface DatabaseResponse
 */
export interface DatabaseResponse {
    /**
     * Database id.
     * @type {string}
     * @memberof DatabaseResponse
     */
    'id': string;
    /**
     * The hostname of your Redis database, for example redis.acme.com. If your Redis server is running on your local machine, you can enter either 127.0.0.1 or localhost.
     * @type {string}
     * @memberof DatabaseResponse
     */
    'host': string;
    /**
     * The port your Redis database is available on.
     * @type {number}
     * @memberof DatabaseResponse
     */
    'port': number;
    /**
     * A name for your Redis database.
     * @type {string}
     * @memberof DatabaseResponse
     */
    'name': string;
    /**
     * Logical database number.
     * @type {number}
     * @memberof DatabaseResponse
     */
    'db'?: number;
    /**
     * Database username, if your database is ACL enabled, otherwise leave this field empty.
     * @type {string}
     * @memberof DatabaseResponse
     */
    'username'?: string;
    /**
     * Connection timeout
     * @type {number}
     * @memberof DatabaseResponse
     */
    'timeout'?: number;
    /**
     * Connection Type
     * @type {string}
     * @memberof DatabaseResponse
     */
    'connectionType': DatabaseResponseConnectionTypeEnum;
    /**
     * The database name from provider
     * @type {string}
     * @memberof DatabaseResponse
     */
    'nameFromProvider'?: string;
    /**
     * The redis database hosting provider
     * @type {string}
     * @memberof DatabaseResponse
     */
    'provider'?: string;
    /**
     * Time of the last connection to the database.
     * @type {string}
     * @memberof DatabaseResponse
     */
    'lastConnection': string;
    /**
     * Date of creation
     * @type {string}
     * @memberof DatabaseResponse
     */
    'createdAt': string;
    /**
     * OSS Cluster Nodes
     * @type {Array<Endpoint>}
     * @memberof DatabaseResponse
     */
    'nodes'?: Array<Endpoint>;
    /**
     * Loaded Redis modules.
     * @type {Array<AdditionalRedisModule>}
     * @memberof DatabaseResponse
     */
    'modules'?: Array<AdditionalRedisModule>;
    /**
     * Use TLS to connect.
     * @type {boolean}
     * @memberof DatabaseResponse
     */
    'tls'?: boolean;
    /**
     * SNI servername
     * @type {string}
     * @memberof DatabaseResponse
     */
    'tlsServername'?: string;
    /**
     * The certificate returned by the server needs to be verified.
     * @type {boolean}
     * @memberof DatabaseResponse
     */
    'verifyServerCert'?: boolean;
    /**
     * CA Certificate
     * @type {CaCertificate}
     * @memberof DatabaseResponse
     */
    'caCert'?: CaCertificate;
    /**
     * Client Certificate
     * @type {ClientCertificate}
     * @memberof DatabaseResponse
     */
    'clientCert'?: ClientCertificate;
    /**
     * A new created connection
     * @type {boolean}
     * @memberof DatabaseResponse
     */
    'new'?: boolean;
    /**
     * Use SSH tunnel to connect.
     * @type {boolean}
     * @memberof DatabaseResponse
     */
    'ssh'?: boolean;
    /**
     * Cloud details
     * @type {CloudDatabaseDetails}
     * @memberof DatabaseResponse
     */
    'cloudDetails'?: CloudDatabaseDetails;
    /**
     * Database compressor
     * @type {string}
     * @memberof DatabaseResponse
     */
    'compressor'?: DatabaseResponseCompressorEnum;
    /**
     * Key name format
     * @type {string}
     * @memberof DatabaseResponse
     */
    'keyNameFormat'?: DatabaseResponseKeyNameFormatEnum;
    /**
     * The version your Redis server
     * @type {string}
     * @memberof DatabaseResponse
     */
    'version'?: string;
    /**
     * Force client connection as standalone
     * @type {boolean}
     * @memberof DatabaseResponse
     */
    'forceStandalone'?: boolean;
    /**
     * Tags associated with the database.
     * @type {Array<Tag>}
     * @memberof DatabaseResponse
     */
    'tags'?: Array<Tag>;
    /**
     * Whether the database was created from a file or environment variables at startup
     * @type {boolean}
     * @memberof DatabaseResponse
     */
    'isPreSetup'?: boolean;
    /**
     * The database password flag (true if password was set)
     * @type {boolean}
     * @memberof DatabaseResponse
     */
    'password'?: boolean;
    /**
     * Ssh options
     * @type {SshOptionsResponse}
     * @memberof DatabaseResponse
     */
    'sshOptions'?: SshOptionsResponse;
    /**
     * Sentinel master
     * @type {SentinelMasterResponse}
     * @memberof DatabaseResponse
     */
    'sentinelMaster'?: SentinelMasterResponse;
}

export const DatabaseResponseConnectionTypeEnum = {
    Standalone: 'STANDALONE',
    Cluster: 'CLUSTER',
    Sentinel: 'SENTINEL',
    NotConnected: 'NOT CONNECTED'
} as const;

export type DatabaseResponseConnectionTypeEnum = typeof DatabaseResponseConnectionTypeEnum[keyof typeof DatabaseResponseConnectionTypeEnum];
export const DatabaseResponseCompressorEnum = {
    None: 'NONE',
    Gzip: 'GZIP',
    Zstd: 'ZSTD',
    Lz4: 'LZ4',
    Snappy: 'SNAPPY',
    Brotli: 'Brotli',
    PhpgzCompress: 'PHPGZCompress'
} as const;

export type DatabaseResponseCompressorEnum = typeof DatabaseResponseCompressorEnum[keyof typeof DatabaseResponseCompressorEnum];
export const DatabaseResponseKeyNameFormatEnum = {
    Unicode: 'Unicode',
    Hex: 'HEX'
} as const;

export type DatabaseResponseKeyNameFormatEnum = typeof DatabaseResponseKeyNameFormatEnum[keyof typeof DatabaseResponseKeyNameFormatEnum];

/**
 * 
 * @export
 * @interface DatabaseSettings
 */
export interface DatabaseSettings {
    /**
     * Database id
     * @type {string}
     * @memberof DatabaseSettings
     */
    'databaseId': string;
    /**
     * Applied settings by user, by database
     * @type {object}
     * @memberof DatabaseSettings
     */
    'data': object;
}
/**
 * 
 * @export
 * @interface DeleteBrowserHistoryItemsDto
 */
export interface DeleteBrowserHistoryItemsDto {
    /**
     * The unique ID of the browser history requested
     * @type {Array<string>}
     * @memberof DeleteBrowserHistoryItemsDto
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface DeleteBrowserHistoryItemsResponse
 */
export interface DeleteBrowserHistoryItemsResponse {
    /**
     * Number of affected browser history items
     * @type {number}
     * @memberof DeleteBrowserHistoryItemsResponse
     */
    'affected': number;
}
/**
 * 
 * @export
 * @interface DeleteClientResponse
 */
export interface DeleteClientResponse {
    /**
     * Number of affected clients
     * @type {number}
     * @memberof DeleteClientResponse
     */
    'affected': number;
}
/**
 * 
 * @export
 * @interface DeleteConsumerGroupsDto
 */
export interface DeleteConsumerGroupsDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof DeleteConsumerGroupsDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Consumer group names
     * @type {Array<CreateListWithExpireDtoElementsInner>}
     * @memberof DeleteConsumerGroupsDto
     */
    'consumerGroups': Array<CreateListWithExpireDtoElementsInner>;
}
/**
 * 
 * @export
 * @interface DeleteConsumerGroupsResponse
 */
export interface DeleteConsumerGroupsResponse {
    /**
     * Number of deleted consumer groups
     * @type {number}
     * @memberof DeleteConsumerGroupsResponse
     */
    'affected': number;
}
/**
 * 
 * @export
 * @interface DeleteConsumersDto
 */
export interface DeleteConsumersDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof DeleteConsumersDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * 
     * @type {GetConsumersDtoGroupName}
     * @memberof DeleteConsumersDto
     */
    'groupName': GetConsumersDtoGroupName;
    /**
     * Names of consumers to delete
     * @type {Array<CreateListWithExpireDtoElementsInner>}
     * @memberof DeleteConsumersDto
     */
    'consumerNames': Array<CreateListWithExpireDtoElementsInner>;
}
/**
 * 
 * @export
 * @interface DeleteDatabaseRecommendationDto
 */
export interface DeleteDatabaseRecommendationDto {
    /**
     * The unique IDs of the database recommendation requested
     * @type {Array<string>}
     * @memberof DeleteDatabaseRecommendationDto
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface DeleteDatabaseRecommendationResponse
 */
export interface DeleteDatabaseRecommendationResponse {
    /**
     * Number of affected recommendations
     * @type {number}
     * @memberof DeleteDatabaseRecommendationResponse
     */
    'affected': number;
}
/**
 * 
 * @export
 * @interface DeleteDatabasesDto
 */
export interface DeleteDatabasesDto {
    /**
     * The unique ID of the database requested
     * @type {Array<string>}
     * @memberof DeleteDatabasesDto
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface DeleteFieldsFromHashDto
 */
export interface DeleteFieldsFromHashDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof DeleteFieldsFromHashDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Hash fields
     * @type {Array<CreateListWithExpireDtoElementsInner>}
     * @memberof DeleteFieldsFromHashDto
     */
    'fields': Array<CreateListWithExpireDtoElementsInner>;
}
/**
 * 
 * @export
 * @interface DeleteFieldsFromHashResponse
 */
export interface DeleteFieldsFromHashResponse {
    /**
     * Number of affected fields
     * @type {number}
     * @memberof DeleteFieldsFromHashResponse
     */
    'affected': number;
}
/**
 * 
 * @export
 * @interface DeleteKeysDto
 */
export interface DeleteKeysDto {
    /**
     * Key name
     * @type {Array<CreateListWithExpireDtoElementsInner>}
     * @memberof DeleteKeysDto
     */
    'keyNames': Array<CreateListWithExpireDtoElementsInner>;
}
/**
 * 
 * @export
 * @interface DeleteKeysResponse
 */
export interface DeleteKeysResponse {
    /**
     * Number of affected keys
     * @type {number}
     * @memberof DeleteKeysResponse
     */
    'affected': number;
}
/**
 * 
 * @export
 * @interface DeleteListElementsDto
 */
export interface DeleteListElementsDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof DeleteListElementsDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * In order to remove last elements of the list, use the TAIL value, else HEAD value
     * @type {string}
     * @memberof DeleteListElementsDto
     */
    'destination': DeleteListElementsDtoDestinationEnum;
    /**
     * Specifying the number of elements to remove from list.
     * @type {number}
     * @memberof DeleteListElementsDto
     */
    'count': number;
}

export const DeleteListElementsDtoDestinationEnum = {
    Tail: 'TAIL',
    Head: 'HEAD'
} as const;

export type DeleteListElementsDtoDestinationEnum = typeof DeleteListElementsDtoDestinationEnum[keyof typeof DeleteListElementsDtoDestinationEnum];

/**
 * 
 * @export
 * @interface DeleteListElementsResponse
 */
export interface DeleteListElementsResponse {
    /**
     * Removed elements from list
     * @type {Array<CreateListWithExpireDtoElementsInner>}
     * @memberof DeleteListElementsResponse
     */
    'elements': Array<CreateListWithExpireDtoElementsInner>;
}
/**
 * 
 * @export
 * @interface DeleteMembersFromSetDto
 */
export interface DeleteMembersFromSetDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof DeleteMembersFromSetDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Key members
     * @type {Array<CreateListWithExpireDtoElementsInner>}
     * @memberof DeleteMembersFromSetDto
     */
    'members': Array<CreateListWithExpireDtoElementsInner>;
}
/**
 * 
 * @export
 * @interface DeleteMembersFromSetResponse
 */
export interface DeleteMembersFromSetResponse {
    /**
     * Number of affected members
     * @type {number}
     * @memberof DeleteMembersFromSetResponse
     */
    'affected': number;
}
/**
 * 
 * @export
 * @interface DeleteMembersFromZSetDto
 */
export interface DeleteMembersFromZSetDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof DeleteMembersFromZSetDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Key members
     * @type {Array<CreateListWithExpireDtoElementsInner>}
     * @memberof DeleteMembersFromZSetDto
     */
    'members': Array<CreateListWithExpireDtoElementsInner>;
}
/**
 * 
 * @export
 * @interface DeleteMembersFromZSetResponse
 */
export interface DeleteMembersFromZSetResponse {
    /**
     * Number of affected members
     * @type {number}
     * @memberof DeleteMembersFromZSetResponse
     */
    'affected': number;
}
/**
 * 
 * @export
 * @interface DeleteStreamEntriesDto
 */
export interface DeleteStreamEntriesDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof DeleteStreamEntriesDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Entries IDs
     * @type {Array<string>}
     * @memberof DeleteStreamEntriesDto
     */
    'entries': Array<string>;
}
/**
 * 
 * @export
 * @interface DeleteStreamEntriesResponse
 */
export interface DeleteStreamEntriesResponse {
    /**
     * Number of deleted entries
     * @type {number}
     * @memberof DeleteStreamEntriesResponse
     */
    'affected': number;
}
/**
 * 
 * @export
 * @interface DiscoverCloudDatabasesDto
 */
export interface DiscoverCloudDatabasesDto {
    /**
     * Subscriptions where to discover databases
     * @type {Array<GetCloudSubscriptionDatabasesDto>}
     * @memberof DiscoverCloudDatabasesDto
     */
    'subscriptions': Array<GetCloudSubscriptionDatabasesDto>;
}
/**
 * 
 * @export
 * @interface DiscoverSentinelMastersDto
 */
export interface DiscoverSentinelMastersDto {
    /**
     * The hostname of your Redis database, for example redis.acme.com. If your Redis server is running on your local machine, you can enter either 127.0.0.1 or localhost.
     * @type {string}
     * @memberof DiscoverSentinelMastersDto
     */
    'host': string;
    /**
     * The port your Redis database is available on.
     * @type {number}
     * @memberof DiscoverSentinelMastersDto
     */
    'port': number;
    /**
     * Database username, if your database is ACL enabled, otherwise leave this field empty.
     * @type {string}
     * @memberof DiscoverSentinelMastersDto
     */
    'username'?: string;
    /**
     * The password, if any, for your Redis database. If your database doesnt require a password, leave this field empty.
     * @type {string}
     * @memberof DiscoverSentinelMastersDto
     */
    'password'?: string;
    /**
     * Connection timeout
     * @type {number}
     * @memberof DiscoverSentinelMastersDto
     */
    'timeout'?: number;
    /**
     * The database name from provider
     * @type {string}
     * @memberof DiscoverSentinelMastersDto
     */
    'nameFromProvider'?: string;
    /**
     * The redis database hosting provider
     * @type {string}
     * @memberof DiscoverSentinelMastersDto
     */
    'provider'?: string;
    /**
     * Redis OSS Sentinel master group.
     * @type {SentinelMaster}
     * @memberof DiscoverSentinelMastersDto
     */
    'sentinelMaster'?: SentinelMaster;
    /**
     * Use TLS to connect.
     * @type {boolean}
     * @memberof DiscoverSentinelMastersDto
     */
    'tls'?: boolean;
    /**
     * SNI servername
     * @type {string}
     * @memberof DiscoverSentinelMastersDto
     */
    'tlsServername'?: string;
    /**
     * The certificate returned by the server needs to be verified.
     * @type {boolean}
     * @memberof DiscoverSentinelMastersDto
     */
    'verifyServerCert'?: boolean;
    /**
     * Use SSH tunnel to connect.
     * @type {boolean}
     * @memberof DiscoverSentinelMastersDto
     */
    'ssh'?: boolean;
    /**
     * Cloud details
     * @type {CloudDatabaseDetails}
     * @memberof DiscoverSentinelMastersDto
     */
    'cloudDetails'?: CloudDatabaseDetails;
    /**
     * Database compressor
     * @type {string}
     * @memberof DiscoverSentinelMastersDto
     */
    'compressor'?: DiscoverSentinelMastersDtoCompressorEnum;
    /**
     * Key name format
     * @type {string}
     * @memberof DiscoverSentinelMastersDto
     */
    'keyNameFormat'?: DiscoverSentinelMastersDtoKeyNameFormatEnum;
    /**
     * Force client connection as standalone
     * @type {boolean}
     * @memberof DiscoverSentinelMastersDto
     */
    'forceStandalone'?: boolean;
    /**
     * 
     * @type {CreateDatabaseDtoCaCert}
     * @memberof DiscoverSentinelMastersDto
     */
    'caCert'?: CreateDatabaseDtoCaCert;
    /**
     * 
     * @type {CreateDatabaseDtoClientCert}
     * @memberof DiscoverSentinelMastersDto
     */
    'clientCert'?: CreateDatabaseDtoClientCert;
    /**
     * 
     * @type {CreateDatabaseDtoSshOptions}
     * @memberof DiscoverSentinelMastersDto
     */
    'sshOptions'?: CreateDatabaseDtoSshOptions;
    /**
     * Tags associated with the database.
     * @type {Array<CreateTagDto>}
     * @memberof DiscoverSentinelMastersDto
     */
    'tags'?: Array<CreateTagDto>;
}

export const DiscoverSentinelMastersDtoCompressorEnum = {
    None: 'NONE',
    Gzip: 'GZIP',
    Zstd: 'ZSTD',
    Lz4: 'LZ4',
    Snappy: 'SNAPPY',
    Brotli: 'Brotli',
    PhpgzCompress: 'PHPGZCompress'
} as const;

export type DiscoverSentinelMastersDtoCompressorEnum = typeof DiscoverSentinelMastersDtoCompressorEnum[keyof typeof DiscoverSentinelMastersDtoCompressorEnum];
export const DiscoverSentinelMastersDtoKeyNameFormatEnum = {
    Unicode: 'Unicode',
    Hex: 'HEX'
} as const;

export type DiscoverSentinelMastersDtoKeyNameFormatEnum = typeof DiscoverSentinelMastersDtoKeyNameFormatEnum[keyof typeof DiscoverSentinelMastersDtoKeyNameFormatEnum];

/**
 * 
 * @export
 * @interface Endpoint
 */
export interface Endpoint {
    /**
     * The hostname of your Redis database, for example redis.acme.com. If your Redis server is running on your local machine, you can enter either 127.0.0.1 or localhost.
     * @type {string}
     * @memberof Endpoint
     */
    'host': string;
    /**
     * The port your Redis database is available on.
     * @type {number}
     * @memberof Endpoint
     */
    'port': number;
}
/**
 * 
 * @export
 * @interface ExportDatabase
 */
export interface ExportDatabase {
    /**
     * Database id.
     * @type {string}
     * @memberof ExportDatabase
     */
    'id': string;
    /**
     * The hostname of your Redis database, for example redis.acme.com. If your Redis server is running on your local machine, you can enter either 127.0.0.1 or localhost.
     * @type {string}
     * @memberof ExportDatabase
     */
    'host': string;
    /**
     * The port your Redis database is available on.
     * @type {number}
     * @memberof ExportDatabase
     */
    'port': number;
    /**
     * A name for your Redis database.
     * @type {string}
     * @memberof ExportDatabase
     */
    'name': string;
    /**
     * Logical database number.
     * @type {number}
     * @memberof ExportDatabase
     */
    'db'?: number;
    /**
     * Database username, if your database is ACL enabled, otherwise leave this field empty.
     * @type {string}
     * @memberof ExportDatabase
     */
    'username'?: string;
    /**
     * The password, if any, for your Redis database. If your database doesnt require a password, leave this field empty.
     * @type {string}
     * @memberof ExportDatabase
     */
    'password'?: string;
    /**
     * Connection Type
     * @type {string}
     * @memberof ExportDatabase
     */
    'connectionType': ExportDatabaseConnectionTypeEnum;
    /**
     * The database name from provider
     * @type {string}
     * @memberof ExportDatabase
     */
    'nameFromProvider'?: string;
    /**
     * The redis database hosting provider
     * @type {string}
     * @memberof ExportDatabase
     */
    'provider'?: string;
    /**
     * Time of the last connection to the database.
     * @type {string}
     * @memberof ExportDatabase
     */
    'lastConnection': string;
    /**
     * Redis OSS Sentinel master group.
     * @type {SentinelMaster}
     * @memberof ExportDatabase
     */
    'sentinelMaster'?: SentinelMaster;
    /**
     * Loaded Redis modules.
     * @type {Array<AdditionalRedisModule>}
     * @memberof ExportDatabase
     */
    'modules'?: Array<AdditionalRedisModule>;
    /**
     * Use TLS to connect.
     * @type {boolean}
     * @memberof ExportDatabase
     */
    'tls'?: boolean;
    /**
     * SNI servername
     * @type {string}
     * @memberof ExportDatabase
     */
    'tlsServername'?: string;
    /**
     * The certificate returned by the server needs to be verified.
     * @type {boolean}
     * @memberof ExportDatabase
     */
    'verifyServerCert'?: boolean;
    /**
     * CA Certificate
     * @type {CaCertificate}
     * @memberof ExportDatabase
     */
    'caCert'?: CaCertificate;
    /**
     * Client Certificate
     * @type {ClientCertificate}
     * @memberof ExportDatabase
     */
    'clientCert'?: ClientCertificate;
    /**
     * Use SSH tunnel to connect.
     * @type {boolean}
     * @memberof ExportDatabase
     */
    'ssh'?: boolean;
    /**
     * SSH options
     * @type {SshOptions}
     * @memberof ExportDatabase
     */
    'sshOptions'?: SshOptions;
    /**
     * Database compressor
     * @type {string}
     * @memberof ExportDatabase
     */
    'compressor'?: ExportDatabaseCompressorEnum;
    /**
     * Force client connection as standalone
     * @type {boolean}
     * @memberof ExportDatabase
     */
    'forceStandalone'?: boolean;
    /**
     * Tags associated with the database.
     * @type {Array<Tag>}
     * @memberof ExportDatabase
     */
    'tags'?: Array<Tag>;
}

export const ExportDatabaseConnectionTypeEnum = {
    Standalone: 'STANDALONE',
    Cluster: 'CLUSTER',
    Sentinel: 'SENTINEL',
    NotConnected: 'NOT CONNECTED'
} as const;

export type ExportDatabaseConnectionTypeEnum = typeof ExportDatabaseConnectionTypeEnum[keyof typeof ExportDatabaseConnectionTypeEnum];
export const ExportDatabaseCompressorEnum = {
    None: 'NONE',
    Gzip: 'GZIP',
    Zstd: 'ZSTD',
    Lz4: 'LZ4',
    Snappy: 'SNAPPY',
    Brotli: 'Brotli',
    PhpgzCompress: 'PHPGZCompress'
} as const;

export type ExportDatabaseCompressorEnum = typeof ExportDatabaseCompressorEnum[keyof typeof ExportDatabaseCompressorEnum];

/**
 * 
 * @export
 * @interface ExportDatabasesDto
 */
export interface ExportDatabasesDto {
    /**
     * The unique IDs of the databases requested
     * @type {Array<string>}
     * @memberof ExportDatabasesDto
     */
    'ids': Array<string>;
    /**
     * Export passwords and certificate bodies
     * @type {boolean}
     * @memberof ExportDatabasesDto
     */
    'withSecrets'?: boolean;
}
/**
 * 
 * @export
 * @interface FieldStatisticsDto
 */
export interface FieldStatisticsDto {
    /**
     * Field identifier
     * @type {string}
     * @memberof FieldStatisticsDto
     */
    'identifier': string;
    /**
     * Field attribute
     * @type {string}
     * @memberof FieldStatisticsDto
     */
    'attribute': string;
    /**
     * Field errors
     * @type {object}
     * @memberof FieldStatisticsDto
     */
    'Index Errors': object;
}
/**
 * 
 * @export
 * @interface GetAgreementsSpecResponse
 */
export interface GetAgreementsSpecResponse {
    /**
     * Version of agreements specification.
     * @type {string}
     * @memberof GetAgreementsSpecResponse
     */
    'version': string;
    /**
     * Agreements specification.
     * @type {object}
     * @memberof GetAgreementsSpecResponse
     */
    'agreements': object;
}
/**
 * 
 * @export
 * @interface GetAppSettingsResponse
 */
export interface GetAppSettingsResponse {
    /**
     * Applied application theme.
     * @type {string}
     * @memberof GetAppSettingsResponse
     */
    'theme': string;
    /**
     * Applied application date format
     * @type {string}
     * @memberof GetAppSettingsResponse
     */
    'dateFormat': string;
    /**
     * Applied application timezone
     * @type {string}
     * @memberof GetAppSettingsResponse
     */
    'timezone': GetAppSettingsResponseTimezoneEnum;
    /**
     * Applied the threshold for scan operation.
     * @type {number}
     * @memberof GetAppSettingsResponse
     */
    'scanThreshold': number;
    /**
     * Applied the batch of the commands for workbench.
     * @type {number}
     * @memberof GetAppSettingsResponse
     */
    'batchSize': number;
    /**
     * Flag indicating that terms and conditions are accepted via environment variable
     * @type {boolean}
     * @memberof GetAppSettingsResponse
     */
    'acceptTermsAndConditionsOverwritten': boolean;
    /**
     * Agreements set by the user.
     * @type {GetUserAgreementsResponse}
     * @memberof GetAppSettingsResponse
     */
    'agreements': GetUserAgreementsResponse;
}

export const GetAppSettingsResponseTimezoneEnum = {
    Local: 'local',
    Utc: 'UTC'
} as const;

export type GetAppSettingsResponseTimezoneEnum = typeof GetAppSettingsResponseTimezoneEnum[keyof typeof GetAppSettingsResponseTimezoneEnum];

/**
 * 
 * @export
 * @interface GetCloudSubscriptionDatabasesDto
 */
export interface GetCloudSubscriptionDatabasesDto {
    /**
     * Subscription Id
     * @type {number}
     * @memberof GetCloudSubscriptionDatabasesDto
     */
    'subscriptionId': number;
    /**
     * Subscription Id
     * @type {string}
     * @memberof GetCloudSubscriptionDatabasesDto
     */
    'subscriptionType': GetCloudSubscriptionDatabasesDtoSubscriptionTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof GetCloudSubscriptionDatabasesDto
     */
    'free'?: boolean;
}

export const GetCloudSubscriptionDatabasesDtoSubscriptionTypeEnum = {
    Flexible: 'flexible',
    Fixed: 'fixed'
} as const;

export type GetCloudSubscriptionDatabasesDtoSubscriptionTypeEnum = typeof GetCloudSubscriptionDatabasesDtoSubscriptionTypeEnum[keyof typeof GetCloudSubscriptionDatabasesDtoSubscriptionTypeEnum];

/**
 * 
 * @export
 * @interface GetConsumersDto
 */
export interface GetConsumersDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof GetConsumersDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * 
     * @type {GetConsumersDtoGroupName}
     * @memberof GetConsumersDto
     */
    'groupName': GetConsumersDtoGroupName;
}
/**
 * @type GetConsumersDtoGroupName
 * Consumer group name
 * @export
 */
export type GetConsumersDtoGroupName = CreateListWithExpireDtoKeyNameOneOf | string;

/**
 * 
 * @export
 * @interface GetHashFieldsDto
 */
export interface GetHashFieldsDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof GetHashFieldsDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Iteration cursor. An iteration starts when the cursor is set to 0, and terminates when the cursor returned by the server is 0.
     * @type {number}
     * @memberof GetHashFieldsDto
     */
    'cursor': number;
    /**
     * Specifying the number of elements to return.
     * @type {number}
     * @memberof GetHashFieldsDto
     */
    'count'?: number;
    /**
     * Iterate only elements matching a given pattern.
     * @type {string}
     * @memberof GetHashFieldsDto
     */
    'match'?: string;
}
/**
 * 
 * @export
 * @interface GetHashFieldsResponse
 */
export interface GetHashFieldsResponse {
    /**
     * 
     * @type {PushListElementsResponseKeyName}
     * @memberof GetHashFieldsResponse
     */
    'keyName': PushListElementsResponseKeyName;
    /**
     * The new cursor to use in the next call. If the property has value of 0, then the iteration is completed.
     * @type {number}
     * @memberof GetHashFieldsResponse
     */
    'nextCursor': number;
    /**
     * Array of members.
     * @type {Array<HashFieldDto>}
     * @memberof GetHashFieldsResponse
     */
    'fields': Array<HashFieldDto>;
    /**
     * The number of fields in the currently-selected hash.
     * @type {number}
     * @memberof GetHashFieldsResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface GetKeyInfoDto
 */
export interface GetKeyInfoDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof GetKeyInfoDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Flag to determine if size should be requested and shown in the response
     * @type {boolean}
     * @memberof GetKeyInfoDto
     */
    'includeSize'?: boolean;
}
/**
 * 
 * @export
 * @interface GetKeyInfoResponse
 */
export interface GetKeyInfoResponse {
    /**
     * 
     * @type {CreateListWithExpireDtoElementsInner}
     * @memberof GetKeyInfoResponse
     */
    'name': CreateListWithExpireDtoElementsInner;
    /**
     * 
     * @type {string}
     * @memberof GetKeyInfoResponse
     */
    'type': string;
    /**
     * The remaining time to live of a key. If the property has value of -1, then the key has no expiration time (no limit).
     * @type {number}
     * @memberof GetKeyInfoResponse
     */
    'ttl': number;
    /**
     * The number of bytes that a key and its value require to be stored in RAM.
     * @type {number}
     * @memberof GetKeyInfoResponse
     */
    'size': number;
    /**
     * The length of the value stored in a key.
     * @type {number}
     * @memberof GetKeyInfoResponse
     */
    'length'?: number;
}
/**
 * 
 * @export
 * @interface GetKeysDto
 */
export interface GetKeysDto {
    /**
     * Iteration cursor. An iteration starts when the cursor is set to 0, and terminates when the cursor returned by the server is 0.
     * @type {string}
     * @memberof GetKeysDto
     */
    'cursor': string;
    /**
     * Specifying the number of elements to return.
     * @type {number}
     * @memberof GetKeysDto
     */
    'count'?: number;
    /**
     * Iterate only elements matching a given pattern.
     * @type {string}
     * @memberof GetKeysDto
     */
    'match'?: string;
    /**
     * Iterate through the database looking for keys of a specific type.
     * @type {string}
     * @memberof GetKeysDto
     */
    'type'?: GetKeysDtoTypeEnum;
    /**
     * Fetch keys info (type, size, ttl, length)
     * @type {boolean}
     * @memberof GetKeysDto
     */
    'keysInfo'?: boolean;
    /**
     * The maximum number of keys to scan
     * @type {number}
     * @memberof GetKeysDto
     */
    'scanThreshold'?: number;
}

export const GetKeysDtoTypeEnum = {
    String: 'string',
    Hash: 'hash',
    List: 'list',
    Set: 'set',
    Zset: 'zset',
    Stream: 'stream',
    ReJsonRl: 'ReJSON-RL',
    Graphdata: 'graphdata',
    TsdbType: 'TSDB-TYPE'
} as const;

export type GetKeysDtoTypeEnum = typeof GetKeysDtoTypeEnum[keyof typeof GetKeysDtoTypeEnum];

/**
 * 
 * @export
 * @interface GetKeysInfoDto
 */
export interface GetKeysInfoDto {
    /**
     * List of keys
     * @type {Array<CreateListWithExpireDtoElementsInner>}
     * @memberof GetKeysInfoDto
     */
    'keys': Array<CreateListWithExpireDtoElementsInner>;
    /**
     * Iterate through the database looking for keys of a specific type.
     * @type {string}
     * @memberof GetKeysInfoDto
     */
    'type'?: GetKeysInfoDtoTypeEnum;
    /**
     * Flag to determine if keys should be requested and shown in the response
     * @type {boolean}
     * @memberof GetKeysInfoDto
     */
    'includeSize'?: boolean;
    /**
     * Flag to determine if TTL should be requested and shown in the response
     * @type {boolean}
     * @memberof GetKeysInfoDto
     */
    'includeTTL'?: boolean;
}

export const GetKeysInfoDtoTypeEnum = {
    String: 'string',
    Hash: 'hash',
    List: 'list',
    Set: 'set',
    Zset: 'zset',
    Stream: 'stream',
    ReJsonRl: 'ReJSON-RL',
    Graphdata: 'graphdata',
    TsdbType: 'TSDB-TYPE'
} as const;

export type GetKeysInfoDtoTypeEnum = typeof GetKeysInfoDtoTypeEnum[keyof typeof GetKeysInfoDtoTypeEnum];

/**
 * 
 * @export
 * @interface GetKeysWithDetailsResponse
 */
export interface GetKeysWithDetailsResponse {
    /**
     * The new cursor to use in the next call. If the property has value of 0, then the iteration is completed.
     * @type {number}
     * @memberof GetKeysWithDetailsResponse
     */
    'cursor': number;
    /**
     * The number of keys in the currently-selected database.
     * @type {number}
     * @memberof GetKeysWithDetailsResponse
     */
    'total': number;
    /**
     * The number of keys we tried to scan. Be aware that scanned is sum of COUNT parameters from redis commands
     * @type {number}
     * @memberof GetKeysWithDetailsResponse
     */
    'scanned': number;
    /**
     * Array of Keys.
     * @type {Array<GetKeyInfoResponse>}
     * @memberof GetKeysWithDetailsResponse
     */
    'keys': Array<GetKeyInfoResponse>;
    /**
     * Node host. In case when we are working with cluster
     * @type {string}
     * @memberof GetKeysWithDetailsResponse
     */
    'host'?: string;
    /**
     * Node port. In case when we are working with cluster
     * @type {number}
     * @memberof GetKeysWithDetailsResponse
     */
    'port'?: number;
    /**
     * The maximum number of results. For RediSearch this number is a value from \"FT.CONFIG GET maxsearchresults\" command.
     * @type {number}
     * @memberof GetKeysWithDetailsResponse
     */
    'maxResults'?: number;
}
/**
 * 
 * @export
 * @interface GetListElementResponse
 */
export interface GetListElementResponse {
    /**
     * 
     * @type {PushListElementsResponseKeyName}
     * @memberof GetListElementResponse
     */
    'keyName': PushListElementsResponseKeyName;
    /**
     * 
     * @type {GetListElementResponseValue}
     * @memberof GetListElementResponse
     */
    'value': GetListElementResponseValue;
}
/**
 * @type GetListElementResponseValue
 * Element value
 * @export
 */
export type GetListElementResponseValue = CreateListWithExpireDtoKeyNameOneOf | string;

/**
 * 
 * @export
 * @interface GetListElementsDto
 */
export interface GetListElementsDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof GetListElementsDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Specifying the number of elements to skip.
     * @type {number}
     * @memberof GetListElementsDto
     */
    'offset': number;
    /**
     * Specifying the number of elements to return from starting at offset.
     * @type {number}
     * @memberof GetListElementsDto
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface GetListElementsResponse
 */
export interface GetListElementsResponse {
    /**
     * 
     * @type {PushListElementsResponseKeyName}
     * @memberof GetListElementsResponse
     */
    'keyName': PushListElementsResponseKeyName;
    /**
     * The number of elements in the currently-selected list.
     * @type {number}
     * @memberof GetListElementsResponse
     */
    'total': number;
    /**
     * Elements
     * @type {Array<CreateListWithExpireDtoElementsInner>}
     * @memberof GetListElementsResponse
     */
    'elements': Array<CreateListWithExpireDtoElementsInner>;
}
/**
 * 
 * @export
 * @interface GetPendingEntriesDto
 */
export interface GetPendingEntriesDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof GetPendingEntriesDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * 
     * @type {GetConsumersDtoGroupName}
     * @memberof GetPendingEntriesDto
     */
    'groupName': GetConsumersDtoGroupName;
    /**
     * 
     * @type {GetPendingEntriesDtoConsumerName}
     * @memberof GetPendingEntriesDto
     */
    'consumerName': GetPendingEntriesDtoConsumerName;
    /**
     * Specifying the start id
     * @type {string}
     * @memberof GetPendingEntriesDto
     */
    'start'?: string;
    /**
     * Specifying the end id
     * @type {string}
     * @memberof GetPendingEntriesDto
     */
    'end'?: string;
    /**
     * Specifying the number of pending messages to return.
     * @type {number}
     * @memberof GetPendingEntriesDto
     */
    'count'?: number;
}
/**
 * @type GetPendingEntriesDtoConsumerName
 * Consumer name
 * @export
 */
export type GetPendingEntriesDtoConsumerName = CreateListWithExpireDtoKeyNameOneOf | string;

/**
 * 
 * @export
 * @interface GetRejsonRlDto
 */
export interface GetRejsonRlDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof GetRejsonRlDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Path to look for data
     * @type {string}
     * @memberof GetRejsonRlDto
     */
    'path'?: string;
    /**
     * Don\'t check for json size and return whole json in path when enabled
     * @type {boolean}
     * @memberof GetRejsonRlDto
     */
    'forceRetrieve'?: boolean;
}
/**
 * 
 * @export
 * @interface GetRejsonRlResponseDto
 */
export interface GetRejsonRlResponseDto {
    /**
     * Determines if json value was downloaded
     * @type {boolean}
     * @memberof GetRejsonRlResponseDto
     */
    'downloaded': boolean;
    /**
     * Type of data in the requested path
     * @type {string}
     * @memberof GetRejsonRlResponseDto
     */
    'type'?: string;
    /**
     * Requested path
     * @type {string}
     * @memberof GetRejsonRlResponseDto
     */
    'path'?: string;
    /**
     * 
     * @type {GetRejsonRlResponseDtoData}
     * @memberof GetRejsonRlResponseDto
     */
    'data': GetRejsonRlResponseDtoData | null;
}
/**
 * @type GetRejsonRlResponseDtoData
 * JSON data that can be of various types
 * @export
 */
export type GetRejsonRlResponseDtoData = Array<SafeRejsonRlDataDto> | boolean | number | string;

/**
 * 
 * @export
 * @interface GetServerInfoResponse
 */
export interface GetServerInfoResponse {
    /**
     * Server identifier.
     * @type {string}
     * @memberof GetServerInfoResponse
     */
    'id': string;
    /**
     * Time of the first server launch.
     * @type {string}
     * @memberof GetServerInfoResponse
     */
    'createDateTime': string;
    /**
     * Version of the application.
     * @type {string}
     * @memberof GetServerInfoResponse
     */
    'appVersion': string;
    /**
     * The operating system platform.
     * @type {string}
     * @memberof GetServerInfoResponse
     */
    'osPlatform': string;
    /**
     * Application build type.
     * @type {string}
     * @memberof GetServerInfoResponse
     */
    'buildType': string;
    /**
     * Application package type.
     * @type {string}
     * @memberof GetServerInfoResponse
     */
    'packageType': GetServerInfoResponsePackageTypeEnum;
    /**
     * Application type.
     * @type {string}
     * @memberof GetServerInfoResponse
     */
    'appType': GetServerInfoResponseAppTypeEnum;
    /**
     * Fixed Redis database id.
     * @type {string}
     * @memberof GetServerInfoResponse
     */
    'fixedDatabaseId'?: string;
    /**
     * List of available encryption strategies
     * @type {Array<string>}
     * @memberof GetServerInfoResponse
     */
    'encryptionStrategies': Array<string>;
    /**
     * Server session id.
     * @type {number}
     * @memberof GetServerInfoResponse
     */
    'sessionId': number;
}

export const GetServerInfoResponsePackageTypeEnum = {
    Flatpak: 'flatpak',
    Snap: 'snap',
    UnknownLinux: 'unknown-linux',
    AppImage: 'app-image',
    Mas: 'mas',
    UnknownDarwin: 'unknown-darwin',
    WindowsStore: 'windows-store',
    UnknownWindows: 'unknown-windows',
    Unknown: 'unknown'
} as const;

export type GetServerInfoResponsePackageTypeEnum = typeof GetServerInfoResponsePackageTypeEnum[keyof typeof GetServerInfoResponsePackageTypeEnum];
export const GetServerInfoResponseAppTypeEnum = {
    RedisStackWeb: 'REDIS_STACK_WEB',
    RedisStackElectron: 'REDIS_STACK_ELECTRON',
    Electron: 'ELECTRON',
    ElectronEnterprise: 'ELECTRON_ENTERPRISE',
    Docker: 'DOCKER',
    VsCode: 'VS_CODE',
    VsCodeEnterprise: 'VS_CODE_ENTERPRISE',
    Unknown: 'UNKNOWN'
} as const;

export type GetServerInfoResponseAppTypeEnum = typeof GetServerInfoResponseAppTypeEnum[keyof typeof GetServerInfoResponseAppTypeEnum];

/**
 * 
 * @export
 * @interface GetSetMembersDto
 */
export interface GetSetMembersDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof GetSetMembersDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Iteration cursor. An iteration starts when the cursor is set to 0, and terminates when the cursor returned by the server is 0.
     * @type {number}
     * @memberof GetSetMembersDto
     */
    'cursor': number;
    /**
     * Specifying the number of elements to return.
     * @type {number}
     * @memberof GetSetMembersDto
     */
    'count'?: number;
    /**
     * Iterate only elements matching a given pattern.
     * @type {string}
     * @memberof GetSetMembersDto
     */
    'match'?: string;
}
/**
 * 
 * @export
 * @interface GetSetMembersResponse
 */
export interface GetSetMembersResponse {
    /**
     * 
     * @type {PushListElementsResponseKeyName}
     * @memberof GetSetMembersResponse
     */
    'keyName': PushListElementsResponseKeyName;
    /**
     * The new cursor to use in the next call. If the property has value of 0, then the iteration is completed.
     * @type {number}
     * @memberof GetSetMembersResponse
     */
    'nextCursor': number;
    /**
     * Array of members
     * @type {Array<CreateListWithExpireDtoElementsInner>}
     * @memberof GetSetMembersResponse
     */
    'members': Array<CreateListWithExpireDtoElementsInner>;
    /**
     * The number of members in the currently-selected set.
     * @type {number}
     * @memberof GetSetMembersResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface GetStreamEntriesDto
 */
export interface GetStreamEntriesDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof GetStreamEntriesDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Specifying the start id
     * @type {string}
     * @memberof GetStreamEntriesDto
     */
    'start'?: string;
    /**
     * Specifying the end id
     * @type {string}
     * @memberof GetStreamEntriesDto
     */
    'end'?: string;
    /**
     * Specifying the number of entries to return.
     * @type {number}
     * @memberof GetStreamEntriesDto
     */
    'count'?: number;
    /**
     * Get entries sort by IDs order.
     * @type {string}
     * @memberof GetStreamEntriesDto
     */
    'sortOrder': GetStreamEntriesDtoSortOrderEnum;
}

export const GetStreamEntriesDtoSortOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type GetStreamEntriesDtoSortOrderEnum = typeof GetStreamEntriesDtoSortOrderEnum[keyof typeof GetStreamEntriesDtoSortOrderEnum];

/**
 * 
 * @export
 * @interface GetStreamEntriesResponse
 */
export interface GetStreamEntriesResponse {
    /**
     * 
     * @type {PushListElementsResponseKeyName}
     * @memberof GetStreamEntriesResponse
     */
    'keyName': PushListElementsResponseKeyName;
    /**
     * Total number of entries
     * @type {number}
     * @memberof GetStreamEntriesResponse
     */
    'total': number;
    /**
     * Last generated id in the stream
     * @type {string}
     * @memberof GetStreamEntriesResponse
     */
    'lastGeneratedId': string;
    /**
     * First stream entry
     * @type {StreamEntryDto}
     * @memberof GetStreamEntriesResponse
     */
    'firstEntry': StreamEntryDto;
    /**
     * Last stream entry
     * @type {StreamEntryDto}
     * @memberof GetStreamEntriesResponse
     */
    'lastEntry': StreamEntryDto;
    /**
     * Stream entries
     * @type {Array<StreamEntryDto>}
     * @memberof GetStreamEntriesResponse
     */
    'entries': Array<StreamEntryDto>;
}
/**
 * 
 * @export
 * @interface GetStringInfoDto
 */
export interface GetStringInfoDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof GetStringInfoDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Start of string
     * @type {number}
     * @memberof GetStringInfoDto
     */
    'start': number;
    /**
     * End of string
     * @type {number}
     * @memberof GetStringInfoDto
     */
    'end': number;
}
/**
 * 
 * @export
 * @interface GetStringValueResponse
 */
export interface GetStringValueResponse {
    /**
     * 
     * @type {PushListElementsResponseKeyName}
     * @memberof GetStringValueResponse
     */
    'keyName': PushListElementsResponseKeyName;
    /**
     * 
     * @type {SetStringWithExpireDtoValue}
     * @memberof GetStringValueResponse
     */
    'value': SetStringWithExpireDtoValue;
}
/**
 * 
 * @export
 * @interface GetUserAgreementsResponse
 */
export interface GetUserAgreementsResponse {
    /**
     * Last version on agreements set by the user.
     * @type {string}
     * @memberof GetUserAgreementsResponse
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface GetZSetMembersDto
 */
export interface GetZSetMembersDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof GetZSetMembersDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Specifying the number of elements to skip.
     * @type {number}
     * @memberof GetZSetMembersDto
     */
    'offset': number;
    /**
     * Specifying the number of elements to return from starting at offset.
     * @type {number}
     * @memberof GetZSetMembersDto
     */
    'count': number;
    /**
     * Get elements sorted by score. In order to sort the members from the highest to the lowest score, use the DESC value, else ASC value
     * @type {string}
     * @memberof GetZSetMembersDto
     */
    'sortOrder': GetZSetMembersDtoSortOrderEnum;
}

export const GetZSetMembersDtoSortOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type GetZSetMembersDtoSortOrderEnum = typeof GetZSetMembersDtoSortOrderEnum[keyof typeof GetZSetMembersDtoSortOrderEnum];

/**
 * 
 * @export
 * @interface GetZSetResponse
 */
export interface GetZSetResponse {
    /**
     * 
     * @type {PushListElementsResponseKeyName}
     * @memberof GetZSetResponse
     */
    'keyName': PushListElementsResponseKeyName;
    /**
     * The number of members in the currently-selected z-set.
     * @type {number}
     * @memberof GetZSetResponse
     */
    'total': number;
    /**
     * Array of Members.
     * @type {Array<ZSetMemberDto>}
     * @memberof GetZSetResponse
     */
    'members': Array<ZSetMemberDto>;
}
/**
 * 
 * @export
 * @interface HashFieldDto
 */
export interface HashFieldDto {
    /**
     * 
     * @type {HashFieldDtoField}
     * @memberof HashFieldDto
     */
    'field': HashFieldDtoField;
    /**
     * 
     * @type {HashFieldDtoField}
     * @memberof HashFieldDto
     */
    'value': HashFieldDtoField;
    /**
     * Set timeout on field in seconds
     * @type {number}
     * @memberof HashFieldDto
     */
    'expire'?: number;
}
/**
 * @type HashFieldDtoField
 * Field
 * @export
 */
export type HashFieldDtoField = CreateListWithExpireDtoKeyNameOneOf | string;

/**
 * 
 * @export
 * @interface HashFieldTtlDto
 */
export interface HashFieldTtlDto {
    /**
     * 
     * @type {HashFieldDtoField}
     * @memberof HashFieldTtlDto
     */
    'field': HashFieldDtoField;
    /**
     * Set a timeout on key in seconds. After the timeout has expired, the field will automatically be deleted. If the property has value of -1, then the field timeout will be removed.
     * @type {number}
     * @memberof HashFieldTtlDto
     */
    'expire': number;
}
/**
 * 
 * @export
 * @interface ImportCloudDatabaseDto
 */
export interface ImportCloudDatabaseDto {
    /**
     * Subscription id
     * @type {number}
     * @memberof ImportCloudDatabaseDto
     */
    'subscriptionId': number;
    /**
     * Database id
     * @type {number}
     * @memberof ImportCloudDatabaseDto
     */
    'databaseId': number;
    /**
     * 
     * @type {boolean}
     * @memberof ImportCloudDatabaseDto
     */
    'free'?: boolean;
}
/**
 * 
 * @export
 * @interface ImportCloudDatabaseResponse
 */
export interface ImportCloudDatabaseResponse {
    /**
     * Subscription id
     * @type {number}
     * @memberof ImportCloudDatabaseResponse
     */
    'subscriptionId': number;
    /**
     * Database id
     * @type {number}
     * @memberof ImportCloudDatabaseResponse
     */
    'databaseId': number;
    /**
     * Add Redis Cloud database status
     * @type {string}
     * @memberof ImportCloudDatabaseResponse
     */
    'status': ImportCloudDatabaseResponseStatusEnum;
    /**
     * Message
     * @type {string}
     * @memberof ImportCloudDatabaseResponse
     */
    'message': string;
    /**
     * The database details.
     * @type {CloudDatabase}
     * @memberof ImportCloudDatabaseResponse
     */
    'databaseDetails'?: CloudDatabase;
    /**
     * Error
     * @type {object}
     * @memberof ImportCloudDatabaseResponse
     */
    'error'?: object;
}

export const ImportCloudDatabaseResponseStatusEnum = {
    Success: 'success',
    Fail: 'fail'
} as const;

export type ImportCloudDatabaseResponseStatusEnum = typeof ImportCloudDatabaseResponseStatusEnum[keyof typeof ImportCloudDatabaseResponseStatusEnum];

/**
 * 
 * @export
 * @interface ImportCloudDatabasesDto
 */
export interface ImportCloudDatabasesDto {
    /**
     * Cloud databases list.
     * @type {Array<ImportCloudDatabaseDto>}
     * @memberof ImportCloudDatabasesDto
     */
    'databases': Array<ImportCloudDatabaseDto>;
}
/**
 * 
 * @export
 * @interface ImportDatabaseCloudJobDataDto
 */
export interface ImportDatabaseCloudJobDataDto {
    /**
     * Subscription id of database
     * @type {number}
     * @memberof ImportDatabaseCloudJobDataDto
     */
    'subscriptionId': number;
    /**
     * Database id to import
     * @type {number}
     * @memberof ImportDatabaseCloudJobDataDto
     */
    'databaseId': number;
    /**
     * Subscription region
     * @type {string}
     * @memberof ImportDatabaseCloudJobDataDto
     */
    'region': string;
    /**
     * Subscription provider
     * @type {string}
     * @memberof ImportDatabaseCloudJobDataDto
     */
    'provider': string;
}
/**
 * 
 * @export
 * @interface IndexAttibuteDto
 */
export interface IndexAttibuteDto {
    /**
     * Field identifier
     * @type {string}
     * @memberof IndexAttibuteDto
     */
    'identifier': string;
    /**
     * Field attribute
     * @type {string}
     * @memberof IndexAttibuteDto
     */
    'attribute': string;
    /**
     * Field type
     * @type {string}
     * @memberof IndexAttibuteDto
     */
    'type': string;
    /**
     * Field weight
     * @type {string}
     * @memberof IndexAttibuteDto
     */
    'WEIGHT': string;
    /**
     * Field can be sorted
     * @type {boolean}
     * @memberof IndexAttibuteDto
     */
    'SORTABLE': boolean;
    /**
     * Attributes can have the NOINDEX option, which means they will not be indexed. 
     * @type {boolean}
     * @memberof IndexAttibuteDto
     */
    'NOINDEX': boolean;
    /**
     * Attribute is case sensitive
     * @type {boolean}
     * @memberof IndexAttibuteDto
     */
    'CASESENSITIVE': boolean;
    /**
     * By default, for hashes (not with JSON) SORTABLE applies a normalization to the indexed value       (characters set to lowercase, removal of diacritics).
     * @type {boolean}
     * @memberof IndexAttibuteDto
     */
    'UNF': boolean;
    /**
     * Text attributes can have the NOSTEM argument that disables stemming when indexing its values.       This may be ideal for things like proper names.
     * @type {boolean}
     * @memberof IndexAttibuteDto
     */
    'NOSTEM': boolean;
    /**
     * Indicates how the text contained in the attribute is to be split into individual tags.       The default is ,. The value must be a single character.
     * @type {string}
     * @memberof IndexAttibuteDto
     */
    'SEPARATOR': string;
}
/**
 * 
 * @export
 * @interface IndexDefinitionDto
 */
export interface IndexDefinitionDto {
    /**
     * key_type, hash or JSON
     * @type {string}
     * @memberof IndexDefinitionDto
     */
    'key_type': string;
    /**
     * Index prefixes given during create
     * @type {Array<string>}
     * @memberof IndexDefinitionDto
     */
    'prefixes': Array<string>;
    /**
     * Index default_score
     * @type {string}
     * @memberof IndexDefinitionDto
     */
    'default_score': string;
}
/**
 * 
 * @export
 * @interface IndexInfoDto
 */
export interface IndexInfoDto {
    /**
     * The index name that was defined when index was created
     * @type {string}
     * @memberof IndexInfoDto
     */
    'index_name': string;
    /**
     * The index options selected during FT.CREATE such as FILTER {filter}, LANGUAGE {default_lang}, etc.
     * @type {IndexOptionsDto}
     * @memberof IndexInfoDto
     */
    'index_options': IndexOptionsDto;
    /**
     * Includes key_type, hash or JSON; prefixes, if any; and default_score.
     * @type {IndexDefinitionDto}
     * @memberof IndexInfoDto
     */
    'index_definition': IndexDefinitionDto;
    /**
     * The index schema field names, types, and attributes.
     * @type {Array<IndexAttibuteDto>}
     * @memberof IndexInfoDto
     */
    'attributes': Array<IndexAttibuteDto>;
    /**
     * The number of documents.
     * @type {string}
     * @memberof IndexInfoDto
     */
    'num_docs': string;
    /**
     * The maximum document ID.
     * @type {string}
     * @memberof IndexInfoDto
     */
    'max_doc_id': string;
    /**
     * The number of distinct terms.
     * @type {string}
     * @memberof IndexInfoDto
     */
    'num_terms': string;
    /**
     * The total number of records.
     * @type {string}
     * @memberof IndexInfoDto
     */
    'num_records': string;
    /**
     * The memory used by the inverted index, which is the core data structure       used for searching in RediSearch. The size is given in megabytes.
     * @type {string}
     * @memberof IndexInfoDto
     */
    'inverted_sz_mb': string;
    /**
     * The memory used by the vector index,       which stores any vectors associated with each document.
     * @type {string}
     * @memberof IndexInfoDto
     */
    'vector_index_sz_mb': string;
    /**
     * The total number of blocks in the inverted index.
     * @type {string}
     * @memberof IndexInfoDto
     */
    'total_inverted_index_blocks': string;
    /**
     * The memory used by the offset vectors,       which store positional information for terms in documents.
     * @type {string}
     * @memberof IndexInfoDto
     */
    'offset_vectors_sz_mb': string;
    /**
     * The memory used by the document table,       which contains metadata about each document in the index.
     * @type {string}
     * @memberof IndexInfoDto
     */
    'doc_table_size_mb': string;
    /**
     * The memory used by sortable values,       which are values associated with documents and used for sorting purposes.
     * @type {string}
     * @memberof IndexInfoDto
     */
    'sortable_values_size_mb': string;
    /**
     * Tag overhead memory usage in mb
     * @type {string}
     * @memberof IndexInfoDto
     */
    'tag_overhead_sz_mb': string;
    /**
     * Text overhead memory usage in mb
     * @type {string}
     * @memberof IndexInfoDto
     */
    'text_overhead_sz_mb': string;
    /**
     * Total index memory size in mb
     * @type {string}
     * @memberof IndexInfoDto
     */
    'total_index_memory_sz_mb': string;
    /**
     * The memory used by the key table,       which stores the mapping between document IDs and Redis keys
     * @type {string}
     * @memberof IndexInfoDto
     */
    'key_table_size_mb': string;
    /**
     * The memory used by GEO-related fields.
     * @type {string}
     * @memberof IndexInfoDto
     */
    'geoshapes_sz_mb': string;
    /**
     * The average number of records (including deletions) per document.
     * @type {string}
     * @memberof IndexInfoDto
     */
    'records_per_doc_avg': string;
    /**
     * The average size of each record in bytes.
     * @type {string}
     * @memberof IndexInfoDto
     */
    'bytes_per_record_avg': string;
    /**
     * The average number of offsets (position information) per term.
     * @type {string}
     * @memberof IndexInfoDto
     */
    'offsets_per_term_avg': string;
    /**
     * The average number of bits used for offsets per record.
     * @type {string}
     * @memberof IndexInfoDto
     */
    'offset_bits_per_record_avg': string;
    /**
     * The number of failures encountered during indexing.
     * @type {string}
     * @memberof IndexInfoDto
     */
    'hash_indexing_failures': string;
    /**
     * The total time taken for indexing in seconds.
     * @type {string}
     * @memberof IndexInfoDto
     */
    'total_indexing_time': string;
    /**
     * Indicates whether the index is currently being generated.
     * @type {string}
     * @memberof IndexInfoDto
     */
    'indexing': string;
    /**
     * The percentage of the index that has been successfully generated.
     * @type {string}
     * @memberof IndexInfoDto
     */
    'percent_indexed': string;
    /**
     * The number of times the index has been used.
     * @type {number}
     * @memberof IndexInfoDto
     */
    'number_of_uses': number;
    /**
     * The index deletion flag. A value of 1 indicates index deletion is in progress.
     * @type {number}
     * @memberof IndexInfoDto
     */
    'cleaning': number;
    /**
     * Garbage collection statistics
     * @type {object}
     * @memberof IndexInfoDto
     */
    'gc_stats': object;
    /**
     * Cursor statistics
     * @type {object}
     * @memberof IndexInfoDto
     */
    'cursor_stats': object;
    /**
     * Dialect statistics: the number of times the index was searched using each DIALECT, 1 - 4.
     * @type {object}
     * @memberof IndexInfoDto
     */
    'dialect_stats': object;
    /**
     * Index error statistics, including indexing failures, last indexing error,       and last indexing error key.
     * @type {object}
     * @memberof IndexInfoDto
     */
    'Index Errors': object;
    /**
     * Dialect statistics: the number of times the index was searched using each DIALECT, 1 - 4.
     * @type {Array<FieldStatisticsDto>}
     * @memberof IndexInfoDto
     */
    'field statistics': Array<FieldStatisticsDto>;
}
/**
 * 
 * @export
 * @interface IndexInfoRequestBodyDto
 */
export interface IndexInfoRequestBodyDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof IndexInfoRequestBodyDto
     */
    'index': CreateListWithExpireDtoKeyName;
}
/**
 * 
 * @export
 * @interface IndexOptionsDto
 */
export interface IndexOptionsDto {
    /**
     * is a filter expression with the full RediSearch aggregation expression language.
     * @type {string}
     * @memberof IndexOptionsDto
     */
    'filter': string;
    /**
     * if set, indicates the default language for documents in the index. Default is English.
     * @type {string}
     * @memberof IndexOptionsDto
     */
    'default_lang': string;
}
/**
 * 
 * @export
 * @interface Key
 */
export interface Key {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof Key
     */
    'name': CreateListWithExpireDtoKeyName;
    /**
     * Key type
     * @type {string}
     * @memberof Key
     */
    'type': string;
    /**
     * Memory used by key in bytes
     * @type {number}
     * @memberof Key
     */
    'memory': number;
    /**
     * Number of characters, elements, etc. based on type
     * @type {number}
     * @memberof Key
     */
    'length': number;
    /**
     * Key ttl
     * @type {number}
     * @memberof Key
     */
    'ttl': number;
}
/**
 * 
 * @export
 * @interface KeyDto
 */
export interface KeyDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof KeyDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
}
/**
 * 
 * @export
 * @interface KeyTtlResponse
 */
export interface KeyTtlResponse {
    /**
     * The remaining time to live of a key that has a timeout. If value equals -2 then the key does not exist or has deleted. If value equals -1 then the key has no associated expire (No limit).
     * @type {number}
     * @memberof KeyTtlResponse
     */
    'ttl': number;
}
/**
 * 
 * @export
 * @interface ListRedisearchIndexesResponse
 */
export interface ListRedisearchIndexesResponse {
    /**
     * Indexes names
     * @type {Array<CreateListWithExpireDtoElementsInner>}
     * @memberof ListRedisearchIndexesResponse
     */
    'indexes': Array<CreateListWithExpireDtoElementsInner>;
}
/**
 * 
 * @export
 * @interface ModifyDatabaseRecommendationDto
 */
export interface ModifyDatabaseRecommendationDto {
    /**
     * Recommendation vote
     * @type {string}
     * @memberof ModifyDatabaseRecommendationDto
     */
    'vote'?: ModifyDatabaseRecommendationDtoVoteEnum;
    /**
     * Hide recommendation
     * @type {boolean}
     * @memberof ModifyDatabaseRecommendationDto
     */
    'hide'?: boolean;
}

export const ModifyDatabaseRecommendationDtoVoteEnum = {
    VeryUseful: 'very useful',
    Useful: 'useful',
    NotUseful: 'not useful'
} as const;

export type ModifyDatabaseRecommendationDtoVoteEnum = typeof ModifyDatabaseRecommendationDtoVoteEnum[keyof typeof ModifyDatabaseRecommendationDtoVoteEnum];

/**
 * 
 * @export
 * @interface ModifyRejsonRlArrAppendDto
 */
export interface ModifyRejsonRlArrAppendDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof ModifyRejsonRlArrAppendDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Path of the json field
     * @type {string}
     * @memberof ModifyRejsonRlArrAppendDto
     */
    'path': string;
    /**
     * Array of valid serialized jsons
     * @type {Array<string>}
     * @memberof ModifyRejsonRlArrAppendDto
     */
    'data': Array<string>;
}
/**
 * 
 * @export
 * @interface ModifyRejsonRlSetDto
 */
export interface ModifyRejsonRlSetDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof ModifyRejsonRlSetDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Path of the json field
     * @type {string}
     * @memberof ModifyRejsonRlSetDto
     */
    'path': string;
    /**
     * Array of valid serialized jsons
     * @type {string}
     * @memberof ModifyRejsonRlSetDto
     */
    'data': string;
}
/**
 * 
 * @export
 * @interface NotificationsDto
 */
export interface NotificationsDto {
    /**
     * Ordered notifications list
     * @type {Array<object>}
     * @memberof NotificationsDto
     */
    'notifications': Array<object>;
    /**
     * Number of unread notifications
     * @type {number}
     * @memberof NotificationsDto
     */
    'totalUnread': number;
}
/**
 * 
 * @export
 * @interface NspSummary
 */
export interface NspSummary {
    /**
     * 
     * @type {NspSummaryNsp}
     * @memberof NspSummary
     */
    'nsp': NspSummaryNsp;
    /**
     * Total memory used by namespace in bytes
     * @type {number}
     * @memberof NspSummary
     */
    'memory': number;
    /**
     * Total keys inside namespace
     * @type {number}
     * @memberof NspSummary
     */
    'keys': number;
    /**
     * Top namespaces by keys number
     * @type {Array<NspTypeSummary>}
     * @memberof NspSummary
     */
    'types': Array<NspTypeSummary>;
}
/**
 * @type NspSummaryNsp
 * Namespace
 * @export
 */
export type NspSummaryNsp = CreateListWithExpireDtoKeyNameOneOf | string;

/**
 * 
 * @export
 * @interface NspTypeSummary
 */
export interface NspTypeSummary {
    /**
     * Type name
     * @type {string}
     * @memberof NspTypeSummary
     */
    'type': string;
    /**
     * Total memory in bytes inside particular data type
     * @type {number}
     * @memberof NspTypeSummary
     */
    'memory': number;
    /**
     * Total keys inside particular data type
     * @type {number}
     * @memberof NspTypeSummary
     */
    'keys': number;
}
/**
 * 
 * @export
 * @interface PendingEntryDto
 */
export interface PendingEntryDto {
    /**
     * Entry ID
     * @type {string}
     * @memberof PendingEntryDto
     */
    'id': string;
    /**
     * 
     * @type {GetPendingEntriesDtoConsumerName}
     * @memberof PendingEntryDto
     */
    'consumerName': GetPendingEntriesDtoConsumerName;
    /**
     * The number of milliseconds that elapsed since the last time this message was delivered to this consumer
     * @type {number}
     * @memberof PendingEntryDto
     */
    'idle': number;
    /**
     * The number of times this message was delivered
     * @type {number}
     * @memberof PendingEntryDto
     */
    'delivered': number;
}
/**
 * 
 * @export
 * @interface PickTypeClass
 */
export interface PickTypeClass {
    /**
     * 
     * @type {string}
     * @memberof PickTypeClass
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface Plugin
 */
export interface Plugin {
    /**
     * Determine if plugin is built into Redisinsight
     * @type {boolean}
     * @memberof Plugin
     */
    'internal'?: boolean;
    /**
     * Module name from manifest
     * @type {string}
     * @memberof Plugin
     */
    'name': string;
    /**
     * Plugins base url
     * @type {string}
     * @memberof Plugin
     */
    'baseUrl': string;
    /**
     * Uri to main js file on the local server
     * @type {string}
     * @memberof Plugin
     */
    'main': string;
    /**
     * Uri to css file on the local server
     * @type {string}
     * @memberof Plugin
     */
    'styles': string;
    /**
     * Visualization field from manifest
     * @type {Array<PluginVisualization>}
     * @memberof Plugin
     */
    'visualizations': Array<PluginVisualization>;
}
/**
 * 
 * @export
 * @interface PluginCommandExecution
 */
export interface PluginCommandExecution {
    /**
     * Database id
     * @type {string}
     * @memberof PluginCommandExecution
     */
    'databaseId'?: string;
    /**
     * Redis command
     * @type {string}
     * @memberof PluginCommandExecution
     */
    'command'?: string;
    /**
     * Workbench mode
     * @type {string}
     * @memberof PluginCommandExecution
     */
    'mode'?: PluginCommandExecutionModeEnum;
    /**
     * Workbench result mode
     * @type {string}
     * @memberof PluginCommandExecution
     */
    'resultsMode'?: PluginCommandExecutionResultsModeEnum;
    /**
     * Workbench executions summary
     * @type {ResultsSummary}
     * @memberof PluginCommandExecution
     */
    'summary'?: ResultsSummary;
    /**
     * Command execution result
     * @type {Array<CommandExecutionResult>}
     * @memberof PluginCommandExecution
     */
    'result'?: Array<CommandExecutionResult>;
    /**
     * Result did not stored in db
     * @type {boolean}
     * @memberof PluginCommandExecution
     */
    'isNotStored'?: boolean;
    /**
     * Workbench command execution time
     * @type {number}
     * @memberof PluginCommandExecution
     */
    'executionTime'?: number;
    /**
     * Logical database number.
     * @type {number}
     * @memberof PluginCommandExecution
     */
    'db'?: number;
    /**
     * Command execution type. Used to distinguish between search and workbench
     * @type {string}
     * @memberof PluginCommandExecution
     */
    'type'?: PluginCommandExecutionTypeEnum;
}

export const PluginCommandExecutionModeEnum = {
    Raw: 'RAW',
    Ascii: 'ASCII'
} as const;

export type PluginCommandExecutionModeEnum = typeof PluginCommandExecutionModeEnum[keyof typeof PluginCommandExecutionModeEnum];
export const PluginCommandExecutionResultsModeEnum = {
    Default: 'DEFAULT',
    GroupMode: 'GROUP_MODE',
    Silent: 'SILENT'
} as const;

export type PluginCommandExecutionResultsModeEnum = typeof PluginCommandExecutionResultsModeEnum[keyof typeof PluginCommandExecutionResultsModeEnum];
export const PluginCommandExecutionTypeEnum = {
    Workbench: 'WORKBENCH',
    Search: 'SEARCH'
} as const;

export type PluginCommandExecutionTypeEnum = typeof PluginCommandExecutionTypeEnum[keyof typeof PluginCommandExecutionTypeEnum];

/**
 * 
 * @export
 * @interface PluginState
 */
export interface PluginState {
    /**
     * Plugin visualization id. Should be unique per all plugins
     * @type {string}
     * @memberof PluginState
     */
    'visualizationId': string;
    /**
     * Command Execution id
     * @type {string}
     * @memberof PluginState
     */
    'commandExecutionId': string;
    /**
     * Stored state
     * @type {string}
     * @memberof PluginState
     */
    'state': string;
    /**
     * Date of creation
     * @type {string}
     * @memberof PluginState
     */
    'createdAt': string;
    /**
     * Date of updating
     * @type {string}
     * @memberof PluginState
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface PluginVisualization
 */
export interface PluginVisualization {
    /**
     * 
     * @type {string}
     * @memberof PluginVisualization
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PluginVisualization
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PluginVisualization
     */
    'activationMethod': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PluginVisualization
     */
    'matchCommands': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof PluginVisualization
     */
    'default': boolean;
    /**
     * 
     * @type {string}
     * @memberof PluginVisualization
     */
    'iconDark': string;
    /**
     * 
     * @type {string}
     * @memberof PluginVisualization
     */
    'iconLight': string;
}
/**
 * 
 * @export
 * @interface PluginsResponse
 */
export interface PluginsResponse {
    /**
     * Uri to static resources required for plugins
     * @type {string}
     * @memberof PluginsResponse
     */
    'static': string;
    /**
     * List of available plugins
     * @type {Array<Plugin>}
     * @memberof PluginsResponse
     */
    'plugins': Array<Plugin>;
}
/**
 * 
 * @export
 * @interface PublishDto
 */
export interface PublishDto {
    /**
     * Message to send
     * @type {string}
     * @memberof PublishDto
     */
    'message': string;
    /**
     * Chanel name
     * @type {string}
     * @memberof PublishDto
     */
    'channel': string;
}
/**
 * 
 * @export
 * @interface PublishResponse
 */
export interface PublishResponse {
    /**
     * Number of clients message ws delivered
     * @type {number}
     * @memberof PublishResponse
     */
    'affected': number;
}
/**
 * 
 * @export
 * @interface PushElementToListDto
 */
export interface PushElementToListDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof PushElementToListDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * List element(s)
     * @type {Array<CreateListWithExpireDtoElementsInner>}
     * @memberof PushElementToListDto
     */
    'elements': Array<CreateListWithExpireDtoElementsInner>;
    /**
     * In order to append elements to the end of the list, use the TAIL value, to prepend use HEAD value. Default: TAIL (when not specified)
     * @type {string}
     * @memberof PushElementToListDto
     */
    'destination'?: PushElementToListDtoDestinationEnum;
}

export const PushElementToListDtoDestinationEnum = {
    Tail: 'TAIL',
    Head: 'HEAD'
} as const;

export type PushElementToListDtoDestinationEnum = typeof PushElementToListDtoDestinationEnum[keyof typeof PushElementToListDtoDestinationEnum];

/**
 * 
 * @export
 * @interface PushListElementsResponse
 */
export interface PushListElementsResponse {
    /**
     * 
     * @type {PushListElementsResponseKeyName}
     * @memberof PushListElementsResponse
     */
    'keyName': PushListElementsResponseKeyName;
    /**
     * The number of elements in the list after current operation.
     * @type {number}
     * @memberof PushListElementsResponse
     */
    'total': number;
}
/**
 * @type PushListElementsResponseKeyName
 * keyName
 * @export
 */
export type PushListElementsResponseKeyName = CreateListWithExpireDtoKeyNameOneOf | string;

/**
 * 
 * @export
 * @interface Rdi
 */
export interface Rdi {
    /**
     * RDI id.
     * @type {string}
     * @memberof Rdi
     */
    'id': string;
    /**
     * Base url of API to connect to (for API type only)
     * @type {string}
     * @memberof Rdi
     */
    'url'?: string;
    /**
     * A name to associate with RDI
     * @type {string}
     * @memberof Rdi
     */
    'name': string;
    /**
     * RDI or API username
     * @type {string}
     * @memberof Rdi
     */
    'username'?: string;
    /**
     * RDI or API password
     * @type {string}
     * @memberof Rdi
     */
    'password'?: string;
    /**
     * Time of the last connection to RDI.
     * @type {string}
     * @memberof Rdi
     */
    'lastConnection': string;
    /**
     * The version of RDI being used
     * @type {string}
     * @memberof Rdi
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface RdiDryRunJobDto
 */
export interface RdiDryRunJobDto {
    /**
     * Input data
     * @type {object}
     * @memberof RdiDryRunJobDto
     */
    'input_data': object;
    /**
     * Job file
     * @type {object}
     * @memberof RdiDryRunJobDto
     */
    'job': object;
}
/**
 * 
 * @export
 * @interface RdiDryRunJobResponseDto
 */
export interface RdiDryRunJobResponseDto {
    /**
     * Dry run job transformations result
     * @type {object}
     * @memberof RdiDryRunJobResponseDto
     */
    'transformations': object;
    /**
     * Dry run job commands result 
     * @type {object}
     * @memberof RdiDryRunJobResponseDto
     */
    'commands': object;
}
/**
 * 
 * @export
 * @interface RdiTemplateResponseDto
 */
export interface RdiTemplateResponseDto {
    /**
     * Template for rdi file
     * @type {string}
     * @memberof RdiTemplateResponseDto
     */
    'template': string;
}
/**
 * 
 * @export
 * @interface RdiTestConnectionsResponseDto
 */
export interface RdiTestConnectionsResponseDto {
    /**
     * Sources connection results
     * @type {object}
     * @memberof RdiTestConnectionsResponseDto
     */
    'sources': object;
    /**
     * Targets connection results
     * @type {object}
     * @memberof RdiTestConnectionsResponseDto
     */
    'targets': object;
}
/**
 * 
 * @export
 * @interface ReadNotificationsDto
 */
export interface ReadNotificationsDto {
    /**
     * Timestamp of notification
     * @type {number}
     * @memberof ReadNotificationsDto
     */
    'timestamp'?: number;
    /**
     * Type of notification
     * @type {string}
     * @memberof ReadNotificationsDto
     */
    'type'?: ReadNotificationsDtoTypeEnum;
}

export const ReadNotificationsDtoTypeEnum = {
    Global: 'global'
} as const;

export type ReadNotificationsDtoTypeEnum = typeof ReadNotificationsDtoTypeEnum[keyof typeof ReadNotificationsDtoTypeEnum];

/**
 * 
 * @export
 * @interface Recommendation
 */
export interface Recommendation {
    /**
     * Recommendation name
     * @type {string}
     * @memberof Recommendation
     */
    'name': string;
    /**
     * Additional recommendation params
     * @type {object}
     * @memberof Recommendation
     */
    'params'?: object;
    /**
     * User vote
     * @type {string}
     * @memberof Recommendation
     */
    'vote'?: string;
}
/**
 * 
 * @export
 * @interface RecommendationVoteDto
 */
export interface RecommendationVoteDto {
    /**
     * Recommendation name
     * @type {string}
     * @memberof RecommendationVoteDto
     */
    'name': string;
    /**
     * User vote
     * @type {string}
     * @memberof RecommendationVoteDto
     */
    'vote': string;
}
/**
 * 
 * @export
 * @interface RedisDatabaseInfoResponse
 */
export interface RedisDatabaseInfoResponse {
    /**
     * Redis database version
     * @type {string}
     * @memberof RedisDatabaseInfoResponse
     */
    'version': string;
    /**
     * Value is \"master\" if the instance is replica of no one, or \"slave\" if the instance is a replica of some master instance
     * @type {string}
     * @memberof RedisDatabaseInfoResponse
     */
    'role'?: RedisDatabaseInfoResponseRoleEnum;
    /**
     * Redis database info from server section
     * @type {object}
     * @memberof RedisDatabaseInfoResponse
     */
    'server'?: object;
    /**
     * Various Redis stats
     * @type {RedisDatabaseStatsDto}
     * @memberof RedisDatabaseInfoResponse
     */
    'stats'?: RedisDatabaseStatsDto;
    /**
     * The number of Redis databases
     * @type {number}
     * @memberof RedisDatabaseInfoResponse
     */
    'databases'?: number;
    /**
     * Total number of bytes allocated by Redis using
     * @type {number}
     * @memberof RedisDatabaseInfoResponse
     */
    'usedMemory'?: number;
    /**
     * Total number of keys inside Redis database
     * @type {number}
     * @memberof RedisDatabaseInfoResponse
     */
    'totalKeys'?: number;
    /**
     * Number of client connections (excluding connections from replicas)
     * @type {number}
     * @memberof RedisDatabaseInfoResponse
     */
    'connectedClients'?: number;
    /**
     * Number of seconds since Redis server start
     * @type {number}
     * @memberof RedisDatabaseInfoResponse
     */
    'uptimeInSeconds'?: number;
    /**
     * The cache hit ratio represents the efficiency of cache usage
     * @type {number}
     * @memberof RedisDatabaseInfoResponse
     */
    'hitRatio'?: number;
    /**
     * The number of the cached lua scripts
     * @type {number}
     * @memberof RedisDatabaseInfoResponse
     */
    'cashedScripts'?: number;
    /**
     * Nodes info
     * @type {Array<RedisNodeInfoResponse>}
     * @memberof RedisDatabaseInfoResponse
     */
    'nodes'?: Array<RedisNodeInfoResponse>;
}

export const RedisDatabaseInfoResponseRoleEnum = {
    Master: 'master',
    Slave: 'slave'
} as const;

export type RedisDatabaseInfoResponseRoleEnum = typeof RedisDatabaseInfoResponseRoleEnum[keyof typeof RedisDatabaseInfoResponseRoleEnum];

/**
 * 
 * @export
 * @interface RedisDatabaseStatsDto
 */
export interface RedisDatabaseStatsDto {
    /**
     * 
     * @type {string}
     * @memberof RedisDatabaseStatsDto
     */
    'instantaneous_input_kbps': string;
    /**
     * 
     * @type {string}
     * @memberof RedisDatabaseStatsDto
     */
    'instantaneous_ops_per_sec': string;
    /**
     * 
     * @type {string}
     * @memberof RedisDatabaseStatsDto
     */
    'instantaneous_output_kbps': string;
    /**
     * 
     * @type {number}
     * @memberof RedisDatabaseStatsDto
     */
    'maxmemory_policy': number;
    /**
     * Redis database mode
     * @type {string}
     * @memberof RedisDatabaseStatsDto
     */
    'numberOfKeysRange': string;
    /**
     * Redis database role
     * @type {string}
     * @memberof RedisDatabaseStatsDto
     */
    'uptime_in_days': string;
}
/**
 * 
 * @export
 * @interface RedisEnterpriseDatabase
 */
export interface RedisEnterpriseDatabase {
    /**
     * The unique ID of the database.
     * @type {number}
     * @memberof RedisEnterpriseDatabase
     */
    'uid': number;
    /**
     * Name of database in cluster.
     * @type {string}
     * @memberof RedisEnterpriseDatabase
     */
    'name': string;
    /**
     * DNS name your Redis Enterprise cluster database is available on.
     * @type {string}
     * @memberof RedisEnterpriseDatabase
     */
    'dnsName': string;
    /**
     * Address your Redis Enterprise cluster database is available on.
     * @type {string}
     * @memberof RedisEnterpriseDatabase
     */
    'address': string;
    /**
     * The port your Redis Enterprise cluster database is available on.
     * @type {number}
     * @memberof RedisEnterpriseDatabase
     */
    'port': number;
    /**
     * Database status
     * @type {string}
     * @memberof RedisEnterpriseDatabase
     */
    'status': RedisEnterpriseDatabaseStatusEnum;
    /**
     * Information about the modules loaded to the database
     * @type {Array<string>}
     * @memberof RedisEnterpriseDatabase
     */
    'modules': Array<string>;
    /**
     * Is TLS mode enabled?
     * @type {boolean}
     * @memberof RedisEnterpriseDatabase
     */
    'tls': boolean;
    /**
     * Additional database options
     * @type {object}
     * @memberof RedisEnterpriseDatabase
     */
    'options': object;
    /**
     * Tags associated with the database.
     * @type {Array<CreateTagDto>}
     * @memberof RedisEnterpriseDatabase
     */
    'tags': Array<CreateTagDto>;
}

export const RedisEnterpriseDatabaseStatusEnum = {
    Pending: 'pending',
    CreationFailed: 'creation-failed',
    Active: 'active',
    ActiveChangePending: 'active-change-pending',
    ImportPending: 'import-pending',
    DeletePending: 'delete-pending',
    Recovery: 'recovery'
} as const;

export type RedisEnterpriseDatabaseStatusEnum = typeof RedisEnterpriseDatabaseStatusEnum[keyof typeof RedisEnterpriseDatabaseStatusEnum];

/**
 * 
 * @export
 * @interface RedisNodeInfoResponse
 */
export interface RedisNodeInfoResponse {
    /**
     * Redis database version
     * @type {string}
     * @memberof RedisNodeInfoResponse
     */
    'version': string;
    /**
     * Value is \"master\" if the instance is replica of no one, or \"slave\" if the instance is a replica of some master instance
     * @type {string}
     * @memberof RedisNodeInfoResponse
     */
    'role'?: RedisNodeInfoResponseRoleEnum;
    /**
     * Redis database info from server section
     * @type {object}
     * @memberof RedisNodeInfoResponse
     */
    'server'?: object;
    /**
     * Various Redis stats
     * @type {RedisDatabaseStatsDto}
     * @memberof RedisNodeInfoResponse
     */
    'stats'?: RedisDatabaseStatsDto;
    /**
     * The number of Redis databases
     * @type {number}
     * @memberof RedisNodeInfoResponse
     */
    'databases'?: number;
    /**
     * Total number of bytes allocated by Redis using
     * @type {number}
     * @memberof RedisNodeInfoResponse
     */
    'usedMemory'?: number;
    /**
     * Total number of keys inside Redis database
     * @type {number}
     * @memberof RedisNodeInfoResponse
     */
    'totalKeys'?: number;
    /**
     * Number of client connections (excluding connections from replicas)
     * @type {number}
     * @memberof RedisNodeInfoResponse
     */
    'connectedClients'?: number;
    /**
     * Number of seconds since Redis server start
     * @type {number}
     * @memberof RedisNodeInfoResponse
     */
    'uptimeInSeconds'?: number;
    /**
     * The cache hit ratio represents the efficiency of cache usage
     * @type {number}
     * @memberof RedisNodeInfoResponse
     */
    'hitRatio'?: number;
    /**
     * The number of the cached lua scripts
     * @type {number}
     * @memberof RedisNodeInfoResponse
     */
    'cashedScripts'?: number;
}

export const RedisNodeInfoResponseRoleEnum = {
    Master: 'master',
    Slave: 'slave'
} as const;

export type RedisNodeInfoResponseRoleEnum = typeof RedisNodeInfoResponseRoleEnum[keyof typeof RedisNodeInfoResponseRoleEnum];

/**
 * 
 * @export
 * @interface RemoveRejsonRlDto
 */
export interface RemoveRejsonRlDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof RemoveRejsonRlDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Path of the json field
     * @type {string}
     * @memberof RemoveRejsonRlDto
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface RemoveRejsonRlResponse
 */
export interface RemoveRejsonRlResponse {
    /**
     * Integer , specifically the number of paths deleted (0 or 1).
     * @type {number}
     * @memberof RemoveRejsonRlResponse
     */
    'affected': number;
}
/**
 * 
 * @export
 * @interface RenameKeyDto
 */
export interface RenameKeyDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof RenameKeyDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * 
     * @type {RenameKeyDtoNewKeyName}
     * @memberof RenameKeyDto
     */
    'newKeyName': RenameKeyDtoNewKeyName;
}
/**
 * @type RenameKeyDtoNewKeyName
 * New key name
 * @export
 */
export type RenameKeyDtoNewKeyName = CreateListWithExpireDtoKeyNameOneOf | string;

/**
 * 
 * @export
 * @interface RenameKeyResponse
 */
export interface RenameKeyResponse {
    /**
     * 
     * @type {PushListElementsResponseKeyName}
     * @memberof RenameKeyResponse
     */
    'keyName': PushListElementsResponseKeyName;
}
/**
 * 
 * @export
 * @interface ResultsSummary
 */
export interface ResultsSummary {
    /**
     * Total number of commands executed
     * @type {number}
     * @memberof ResultsSummary
     */
    'total': number;
    /**
     * Total number of successful commands executed
     * @type {number}
     * @memberof ResultsSummary
     */
    'success': number;
    /**
     * Total number of failed commands executed
     * @type {number}
     * @memberof ResultsSummary
     */
    'fail': number;
}
/**
 * 
 * @export
 * @interface RootCustomTutorialManifest
 */
export interface RootCustomTutorialManifest {
    /**
     * 
     * @type {string}
     * @memberof RootCustomTutorialManifest
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RootCustomTutorialManifest
     */
    'type': RootCustomTutorialManifestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RootCustomTutorialManifest
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof RootCustomTutorialManifest
     */
    'summary': string;
    /**
     * 
     * @type {CustomTutorialManifestArgs}
     * @memberof RootCustomTutorialManifest
     */
    'args'?: CustomTutorialManifestArgs;
    /**
     * 
     * @type {CustomTutorialManifest}
     * @memberof RootCustomTutorialManifest
     */
    'children'?: CustomTutorialManifest;
    /**
     * 
     * @type {string}
     * @memberof RootCustomTutorialManifest
     */
    '_actions'?: RootCustomTutorialManifestActionsEnum;
    /**
     * 
     * @type {string}
     * @memberof RootCustomTutorialManifest
     */
    '_path'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RootCustomTutorialManifest
     */
    'keywords'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RootCustomTutorialManifest
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof RootCustomTutorialManifest
     */
    'url'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RootCustomTutorialManifest
     */
    'industry'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RootCustomTutorialManifest
     */
    'description'?: string;
}

export const RootCustomTutorialManifestTypeEnum = {
    CodeButton: 'code-button',
    Group: 'group',
    InternalLink: 'internal-link'
} as const;

export type RootCustomTutorialManifestTypeEnum = typeof RootCustomTutorialManifestTypeEnum[keyof typeof RootCustomTutorialManifestTypeEnum];
export const RootCustomTutorialManifestActionsEnum = {
    Create: 'create',
    Delete: 'delete',
    Sync: 'sync'
} as const;

export type RootCustomTutorialManifestActionsEnum = typeof RootCustomTutorialManifestActionsEnum[keyof typeof RootCustomTutorialManifestActionsEnum];

/**
 * 
 * @export
 * @interface SafeRejsonRlDataDto
 */
export interface SafeRejsonRlDataDto {
    /**
     * Key inside json data
     * @type {string}
     * @memberof SafeRejsonRlDataDto
     */
    'key': string;
    /**
     * Path of the json field
     * @type {string}
     * @memberof SafeRejsonRlDataDto
     */
    'path': string;
    /**
     * Number of properties/elements inside field (for object and arrays only)
     * @type {number}
     * @memberof SafeRejsonRlDataDto
     */
    'cardinality'?: number;
    /**
     * Type of the field
     * @type {string}
     * @memberof SafeRejsonRlDataDto
     */
    'type': SafeRejsonRlDataDtoTypeEnum;
    /**
     * Any value
     * @type {string}
     * @memberof SafeRejsonRlDataDto
     */
    'value'?: string;
}

export const SafeRejsonRlDataDtoTypeEnum = {
    String: 'string',
    Number: 'number',
    Integer: 'integer',
    Boolean: 'boolean',
    Null: 'null',
    Array: 'array',
    Object: 'object'
} as const;

export type SafeRejsonRlDataDtoTypeEnum = typeof SafeRejsonRlDataDtoTypeEnum[keyof typeof SafeRejsonRlDataDtoTypeEnum];

/**
 * 
 * @export
 * @interface ScanFilter
 */
export interface ScanFilter {
    /**
     * Key type
     * @type {string}
     * @memberof ScanFilter
     */
    'type': string;
    /**
     * Match glob patterns
     * @type {string}
     * @memberof ScanFilter
     */
    'match': string;
}
/**
 * 
 * @export
 * @interface SearchRedisearchDto
 */
export interface SearchRedisearchDto {
    /**
     * 
     * @type {CreateRedisearchIndexDtoIndex}
     * @memberof SearchRedisearchDto
     */
    'index': CreateRedisearchIndexDtoIndex;
    /**
     * Query to search inside data fields
     * @type {string}
     * @memberof SearchRedisearchDto
     */
    'query': string;
    /**
     * Limit number of results to be returned
     * @type {number}
     * @memberof SearchRedisearchDto
     */
    'limit': number;
    /**
     * Offset position to start searching
     * @type {number}
     * @memberof SearchRedisearchDto
     */
    'offset': number;
}
/**
 * 
 * @export
 * @interface SearchZSetMembersDto
 */
export interface SearchZSetMembersDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof SearchZSetMembersDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Iteration cursor. An iteration starts when the cursor is set to 0, and terminates when the cursor returned by the server is 0.
     * @type {number}
     * @memberof SearchZSetMembersDto
     */
    'cursor': number;
    /**
     * Specifying the number of elements to return.
     * @type {number}
     * @memberof SearchZSetMembersDto
     */
    'count'?: number;
    /**
     * Iterate only elements matching a given pattern.
     * @type {string}
     * @memberof SearchZSetMembersDto
     */
    'match': string;
}
/**
 * 
 * @export
 * @interface SearchZSetMembersResponse
 */
export interface SearchZSetMembersResponse {
    /**
     * 
     * @type {PushListElementsResponseKeyName}
     * @memberof SearchZSetMembersResponse
     */
    'keyName': PushListElementsResponseKeyName;
    /**
     * The new cursor to use in the next call. If the property has value of 0, then the iteration is completed.
     * @type {number}
     * @memberof SearchZSetMembersResponse
     */
    'nextCursor': number;
    /**
     * Array of Members.
     * @type {Array<ZSetMemberDto>}
     * @memberof SearchZSetMembersResponse
     */
    'members': Array<ZSetMemberDto>;
    /**
     * The number of members in the currently-selected z-set.
     * @type {number}
     * @memberof SearchZSetMembersResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface SendAiChatMessageDto
 */
export interface SendAiChatMessageDto {
    /**
     * Message content
     * @type {string}
     * @memberof SendAiChatMessageDto
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface SendAiQueryMessageDto
 */
export interface SendAiQueryMessageDto {
    /**
     * Message content
     * @type {string}
     * @memberof SendAiQueryMessageDto
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface SendCommandDto
 */
export interface SendCommandDto {
    /**
     * Redis CLI command
     * @type {string}
     * @memberof SendCommandDto
     */
    'command': string;
    /**
     * Define output format
     * @type {string}
     * @memberof SendCommandDto
     */
    'outputFormat'?: SendCommandDtoOutputFormatEnum;
}

export const SendCommandDtoOutputFormatEnum = {
    Text: 'TEXT',
    Raw: 'RAW'
} as const;

export type SendCommandDtoOutputFormatEnum = typeof SendCommandDtoOutputFormatEnum[keyof typeof SendCommandDtoOutputFormatEnum];

/**
 * 
 * @export
 * @interface SendCommandResponse
 */
export interface SendCommandResponse {
    /**
     * Redis CLI response
     * @type {string}
     * @memberof SendCommandResponse
     */
    'response': string;
    /**
     * Redis CLI command execution status
     * @type {string}
     * @memberof SendCommandResponse
     */
    'status': SendCommandResponseStatusEnum;
}

export const SendCommandResponseStatusEnum = {
    Success: 'success',
    Fail: 'fail'
} as const;

export type SendCommandResponseStatusEnum = typeof SendCommandResponseStatusEnum[keyof typeof SendCommandResponseStatusEnum];

/**
 * 
 * @export
 * @interface SendEventDto
 */
export interface SendEventDto {
    /**
     * Telemetry event name.
     * @type {string}
     * @memberof SendEventDto
     */
    'event': string;
    /**
     * Telemetry event data.
     * @type {object}
     * @memberof SendEventDto
     */
    'eventData'?: object;
    /**
     * Does not track the specific user in any way?
     * @type {boolean}
     * @memberof SendEventDto
     */
    'nonTracking'?: boolean;
    /**
     * User data.
     * @type {object}
     * @memberof SendEventDto
     */
    'traits'?: object;
}
/**
 * 
 * @export
 * @interface SentinelMaster
 */
export interface SentinelMaster {
    /**
     * Sentinel master group name. Identifies a group of Redis instances composed of a master and one or more slaves.
     * @type {string}
     * @memberof SentinelMaster
     */
    'name': string;
    /**
     * Sentinel username, if your database is ACL enabled, otherwise leave this field empty.
     * @type {string}
     * @memberof SentinelMaster
     */
    'username'?: string;
    /**
     * The password for your Redis Sentinel master. If your master doesnt require a password, leave this field empty.
     * @type {string}
     * @memberof SentinelMaster
     */
    'password'?: string;
    /**
     * The hostname of Sentinel master.
     * @type {string}
     * @memberof SentinelMaster
     */
    'host'?: string;
    /**
     * The port Sentinel master.
     * @type {number}
     * @memberof SentinelMaster
     */
    'port'?: number;
    /**
     * Sentinel master status
     * @type {string}
     * @memberof SentinelMaster
     */
    'status'?: SentinelMasterStatusEnum;
    /**
     * The number of slaves.
     * @type {number}
     * @memberof SentinelMaster
     */
    'numberOfSlaves'?: number;
    /**
     * Sentinel master endpoints.
     * @type {Array<Endpoint>}
     * @memberof SentinelMaster
     */
    'nodes'?: Array<Endpoint>;
}

export const SentinelMasterStatusEnum = {
    Active: 'active',
    Down: 'down'
} as const;

export type SentinelMasterStatusEnum = typeof SentinelMasterStatusEnum[keyof typeof SentinelMasterStatusEnum];

/**
 * 
 * @export
 * @interface SentinelMasterResponse
 */
export interface SentinelMasterResponse {
    /**
     * Sentinel master group name. Identifies a group of Redis instances composed of a master and one or more slaves.
     * @type {string}
     * @memberof SentinelMasterResponse
     */
    'name': string;
    /**
     * Sentinel username, if your database is ACL enabled, otherwise leave this field empty.
     * @type {string}
     * @memberof SentinelMasterResponse
     */
    'username'?: string;
    /**
     * The hostname of Sentinel master.
     * @type {string}
     * @memberof SentinelMasterResponse
     */
    'host'?: string;
    /**
     * The port Sentinel master.
     * @type {number}
     * @memberof SentinelMasterResponse
     */
    'port'?: number;
    /**
     * Sentinel master status
     * @type {string}
     * @memberof SentinelMasterResponse
     */
    'status'?: SentinelMasterResponseStatusEnum;
    /**
     * The number of slaves.
     * @type {number}
     * @memberof SentinelMasterResponse
     */
    'numberOfSlaves'?: number;
    /**
     * Sentinel master endpoints.
     * @type {Array<Endpoint>}
     * @memberof SentinelMasterResponse
     */
    'nodes'?: Array<Endpoint>;
    /**
     * The password for your Redis Sentinel master. If your master doesnt require a password, leave this field empty.
     * @type {boolean}
     * @memberof SentinelMasterResponse
     */
    'password'?: boolean;
}

export const SentinelMasterResponseStatusEnum = {
    Active: 'active',
    Down: 'down'
} as const;

export type SentinelMasterResponseStatusEnum = typeof SentinelMasterResponseStatusEnum[keyof typeof SentinelMasterResponseStatusEnum];

/**
 * 
 * @export
 * @interface SetListElementDto
 */
export interface SetListElementDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof SetListElementDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * 
     * @type {SetListElementDtoElement}
     * @memberof SetListElementDto
     */
    'element': SetListElementDtoElement;
    /**
     * Element index
     * @type {number}
     * @memberof SetListElementDto
     */
    'index': number;
}
/**
 * @type SetListElementDtoElement
 * List element
 * @export
 */
export type SetListElementDtoElement = CreateListWithExpireDtoKeyNameOneOf | string;

/**
 * 
 * @export
 * @interface SetListElementResponse
 */
export interface SetListElementResponse {
    /**
     * Element index
     * @type {number}
     * @memberof SetListElementResponse
     */
    'index': number;
    /**
     * 
     * @type {SetListElementDtoElement}
     * @memberof SetListElementResponse
     */
    'element': SetListElementDtoElement;
}
/**
 * 
 * @export
 * @interface SetStringDto
 */
export interface SetStringDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof SetStringDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * 
     * @type {SetStringWithExpireDtoValue}
     * @memberof SetStringDto
     */
    'value': SetStringWithExpireDtoValue;
}
/**
 * 
 * @export
 * @interface SetStringWithExpireDto
 */
export interface SetStringWithExpireDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof SetStringWithExpireDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * 
     * @type {SetStringWithExpireDtoValue}
     * @memberof SetStringWithExpireDto
     */
    'value': SetStringWithExpireDtoValue;
    /**
     * Set a timeout on key in seconds. After the timeout has expired, the key will automatically be deleted.
     * @type {number}
     * @memberof SetStringWithExpireDto
     */
    'expire'?: number;
}
/**
 * @type SetStringWithExpireDtoValue
 * Key value
 * @export
 */
export type SetStringWithExpireDtoValue = CreateListWithExpireDtoKeyNameOneOf | string;

/**
 * 
 * @export
 * @interface ShortCommandExecution
 */
export interface ShortCommandExecution {
    /**
     * Command execution id
     * @type {string}
     * @memberof ShortCommandExecution
     */
    'id'?: string;
    /**
     * Database id
     * @type {string}
     * @memberof ShortCommandExecution
     */
    'databaseId'?: string;
    /**
     * Redis command
     * @type {string}
     * @memberof ShortCommandExecution
     */
    'command'?: string;
    /**
     * Workbench mode
     * @type {string}
     * @memberof ShortCommandExecution
     */
    'mode'?: ShortCommandExecutionModeEnum;
    /**
     * Workbench result mode
     * @type {string}
     * @memberof ShortCommandExecution
     */
    'resultsMode'?: ShortCommandExecutionResultsModeEnum;
    /**
     * Workbench executions summary
     * @type {ResultsSummary}
     * @memberof ShortCommandExecution
     */
    'summary'?: ResultsSummary;
    /**
     * Result did not stored in db
     * @type {boolean}
     * @memberof ShortCommandExecution
     */
    'isNotStored'?: boolean;
    /**
     * Date of command execution
     * @type {string}
     * @memberof ShortCommandExecution
     */
    'createdAt'?: string;
    /**
     * Workbench command execution time
     * @type {number}
     * @memberof ShortCommandExecution
     */
    'executionTime'?: number;
    /**
     * Logical database number.
     * @type {number}
     * @memberof ShortCommandExecution
     */
    'db'?: number;
    /**
     * Command execution type. Used to distinguish between search and workbench
     * @type {string}
     * @memberof ShortCommandExecution
     */
    'type'?: ShortCommandExecutionTypeEnum;
}

export const ShortCommandExecutionModeEnum = {
    Raw: 'RAW',
    Ascii: 'ASCII'
} as const;

export type ShortCommandExecutionModeEnum = typeof ShortCommandExecutionModeEnum[keyof typeof ShortCommandExecutionModeEnum];
export const ShortCommandExecutionResultsModeEnum = {
    Default: 'DEFAULT',
    GroupMode: 'GROUP_MODE',
    Silent: 'SILENT'
} as const;

export type ShortCommandExecutionResultsModeEnum = typeof ShortCommandExecutionResultsModeEnum[keyof typeof ShortCommandExecutionResultsModeEnum];
export const ShortCommandExecutionTypeEnum = {
    Workbench: 'WORKBENCH',
    Search: 'SEARCH'
} as const;

export type ShortCommandExecutionTypeEnum = typeof ShortCommandExecutionTypeEnum[keyof typeof ShortCommandExecutionTypeEnum];

/**
 * 
 * @export
 * @interface ShortDatabaseAnalysis
 */
export interface ShortDatabaseAnalysis {
    /**
     * Analysis id
     * @type {string}
     * @memberof ShortDatabaseAnalysis
     */
    'id'?: string;
    /**
     * Analysis created date (ISO string)
     * @type {string}
     * @memberof ShortDatabaseAnalysis
     */
    'createdAt'?: string;
    /**
     * Logical database number.
     * @type {number}
     * @memberof ShortDatabaseAnalysis
     */
    'db'?: number;
}
/**
 * 
 * @export
 * @interface SimpleSummary
 */
export interface SimpleSummary {
    /**
     * Total number
     * @type {number}
     * @memberof SimpleSummary
     */
    'total': number;
    /**
     * Array with totals by type
     * @type {Array<SimpleTypeSummary>}
     * @memberof SimpleSummary
     */
    'types': Array<SimpleTypeSummary>;
}
/**
 * 
 * @export
 * @interface SimpleTypeSummary
 */
export interface SimpleTypeSummary {
    /**
     * Type name
     * @type {string}
     * @memberof SimpleTypeSummary
     */
    'type': string;
    /**
     * Total inside this type of data
     * @type {number}
     * @memberof SimpleTypeSummary
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface SlowLog
 */
export interface SlowLog {
    /**
     * Unique slowlog Id calculated by Redis
     * @type {number}
     * @memberof SlowLog
     */
    'id': number;
    /**
     * Time when command was executed
     * @type {number}
     * @memberof SlowLog
     */
    'time': number;
    /**
     * Time needed to execute this command in microseconds
     * @type {number}
     * @memberof SlowLog
     */
    'durationUs': number;
    /**
     * Command with args
     * @type {string}
     * @memberof SlowLog
     */
    'args': string;
    /**
     * Client that executed this command
     * @type {string}
     * @memberof SlowLog
     */
    'source': string;
    /**
     * Client name if defined
     * @type {string}
     * @memberof SlowLog
     */
    'client'?: string;
}
/**
 * 
 * @export
 * @interface SlowLogConfig
 */
export interface SlowLogConfig {
    /**
     * Max logs to store inside Redis slowlog
     * @type {number}
     * @memberof SlowLogConfig
     */
    'slowlogMaxLen'?: number;
    /**
     * Store logs with execution time greater than this value (in microseconds)
     * @type {number}
     * @memberof SlowLogConfig
     */
    'slowlogLogSlowerThan'?: number;
}
/**
 * 
 * @export
 * @interface SshOptions
 */
export interface SshOptions {
    /**
     * The hostname of SSH server
     * @type {string}
     * @memberof SshOptions
     */
    'host': string;
    /**
     * The port of SSH server
     * @type {number}
     * @memberof SshOptions
     */
    'port': number;
    /**
     * SSH username
     * @type {string}
     * @memberof SshOptions
     */
    'username'?: string;
    /**
     * The SSH password
     * @type {string}
     * @memberof SshOptions
     */
    'password'?: string;
    /**
     * The SSH private key
     * @type {string}
     * @memberof SshOptions
     */
    'privateKey'?: string;
    /**
     * The SSH passphrase
     * @type {string}
     * @memberof SshOptions
     */
    'passphrase'?: string;
}
/**
 * 
 * @export
 * @interface SshOptionsResponse
 */
export interface SshOptionsResponse {
    /**
     * The hostname of SSH server
     * @type {string}
     * @memberof SshOptionsResponse
     */
    'host': string;
    /**
     * The port of SSH server
     * @type {number}
     * @memberof SshOptionsResponse
     */
    'port': number;
    /**
     * SSH username
     * @type {string}
     * @memberof SshOptionsResponse
     */
    'username'?: string;
    /**
     * The SSH password flag (true if password was set)
     * @type {boolean}
     * @memberof SshOptionsResponse
     */
    'password'?: boolean;
    /**
     * The SSH passphrase flag (true if password was set)
     * @type {boolean}
     * @memberof SshOptionsResponse
     */
    'passphrase'?: boolean;
    /**
     * The SSH private key
     * @type {boolean}
     * @memberof SshOptionsResponse
     */
    'privateKey'?: boolean;
}
/**
 * 
 * @export
 * @interface StreamEntryDto
 */
export interface StreamEntryDto {
    /**
     * Entry ID
     * @type {string}
     * @memberof StreamEntryDto
     */
    'id': string;
    /**
     * Entry fields
     * @type {Array<StreamEntryFieldDto>}
     * @memberof StreamEntryDto
     */
    'fields': Array<StreamEntryFieldDto>;
}
/**
 * 
 * @export
 * @interface StreamEntryFieldDto
 */
export interface StreamEntryFieldDto {
    /**
     * 
     * @type {StreamEntryFieldDtoName}
     * @memberof StreamEntryFieldDto
     */
    'name': StreamEntryFieldDtoName;
    /**
     * 
     * @type {StreamEntryFieldDtoValue}
     * @memberof StreamEntryFieldDto
     */
    'value': StreamEntryFieldDtoValue;
}
/**
 * @type StreamEntryFieldDtoName
 * Entry field name
 * @export
 */
export type StreamEntryFieldDtoName = CreateListWithExpireDtoKeyNameOneOf | string;

/**
 * @type StreamEntryFieldDtoValue
 * Entry value
 * @export
 */
export type StreamEntryFieldDtoValue = CreateListWithExpireDtoKeyNameOneOf | string;

/**
 * 
 * @export
 * @interface SumGroup
 */
export interface SumGroup {
    /**
     * Group Label
     * @type {string}
     * @memberof SumGroup
     */
    'label': string;
    /**
     * Sum of data (e.g. memory, or number of keys)
     * @type {number}
     * @memberof SumGroup
     */
    'total': number;
    /**
     * Group threshold during analyzing (all values less then (<) threshold)
     * @type {number}
     * @memberof SumGroup
     */
    'threshold': number;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * Tag id.
     * @type {string}
     * @memberof Tag
     */
    'id': string;
    /**
     * Key of the tag.
     * @type {string}
     * @memberof Tag
     */
    'key': string;
    /**
     * Value of the tag.
     * @type {string}
     * @memberof Tag
     */
    'value': string;
    /**
     * Creation date of the tag.
     * @type {string}
     * @memberof Tag
     */
    'createdAt': string;
    /**
     * Last update date of the tag.
     * @type {string}
     * @memberof Tag
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface UpdateConsumerGroupDto
 */
export interface UpdateConsumerGroupDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof UpdateConsumerGroupDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * 
     * @type {GetConsumersDtoGroupName}
     * @memberof UpdateConsumerGroupDto
     */
    'name': GetConsumersDtoGroupName;
    /**
     * Id of last delivered message
     * @type {string}
     * @memberof UpdateConsumerGroupDto
     */
    'lastDeliveredId': string;
}
/**
 * 
 * @export
 * @interface UpdateDatabaseDto
 */
export interface UpdateDatabaseDto {
    /**
     * The hostname of your Redis database, for example redis.acme.com. If your Redis server is running on your local machine, you can enter either 127.0.0.1 or localhost.
     * @type {string}
     * @memberof UpdateDatabaseDto
     */
    'host'?: string;
    /**
     * The port your Redis database is available on.
     * @type {number}
     * @memberof UpdateDatabaseDto
     */
    'port'?: number;
    /**
     * A name for your Redis database.
     * @type {string}
     * @memberof UpdateDatabaseDto
     */
    'name'?: string;
    /**
     * Logical database number.
     * @type {number}
     * @memberof UpdateDatabaseDto
     */
    'db'?: number;
    /**
     * Database username, if your database is ACL enabled, otherwise leave this field empty.
     * @type {string}
     * @memberof UpdateDatabaseDto
     */
    'username'?: string;
    /**
     * The password, if any, for your Redis database. If your database doesnt require a password, leave this field empty.
     * @type {string}
     * @memberof UpdateDatabaseDto
     */
    'password'?: string;
    /**
     * The database name from provider
     * @type {string}
     * @memberof UpdateDatabaseDto
     */
    'nameFromProvider'?: string;
    /**
     * The redis database hosting provider
     * @type {string}
     * @memberof UpdateDatabaseDto
     */
    'provider'?: string;
    /**
     * Use TLS to connect.
     * @type {boolean}
     * @memberof UpdateDatabaseDto
     */
    'tls'?: boolean;
    /**
     * SNI servername
     * @type {string}
     * @memberof UpdateDatabaseDto
     */
    'tlsServername'?: string;
    /**
     * The certificate returned by the server needs to be verified.
     * @type {boolean}
     * @memberof UpdateDatabaseDto
     */
    'verifyServerCert'?: boolean;
    /**
     * Use SSH tunnel to connect.
     * @type {boolean}
     * @memberof UpdateDatabaseDto
     */
    'ssh'?: boolean;
    /**
     * Cloud details
     * @type {CloudDatabaseDetails}
     * @memberof UpdateDatabaseDto
     */
    'cloudDetails'?: CloudDatabaseDetails;
    /**
     * Database compressor
     * @type {string}
     * @memberof UpdateDatabaseDto
     */
    'compressor'?: UpdateDatabaseDtoCompressorEnum;
    /**
     * Key name format
     * @type {string}
     * @memberof UpdateDatabaseDto
     */
    'keyNameFormat'?: UpdateDatabaseDtoKeyNameFormatEnum;
    /**
     * Force client connection as standalone
     * @type {boolean}
     * @memberof UpdateDatabaseDto
     */
    'forceStandalone'?: boolean;
    /**
     * 
     * @type {CreateDatabaseDtoCaCert}
     * @memberof UpdateDatabaseDto
     */
    'caCert'?: CreateDatabaseDtoCaCert;
    /**
     * 
     * @type {CreateDatabaseDtoClientCert}
     * @memberof UpdateDatabaseDto
     */
    'clientCert'?: CreateDatabaseDtoClientCert;
    /**
     * Tags associated with the database.
     * @type {Array<CreateTagDto>}
     * @memberof UpdateDatabaseDto
     */
    'tags'?: Array<CreateTagDto>;
    /**
     * Updated ssh options fields
     * @type {UpdateSshOptionsDto}
     * @memberof UpdateDatabaseDto
     */
    'sshOptions'?: UpdateSshOptionsDto;
    /**
     * Connection timeout
     * @type {number}
     * @memberof UpdateDatabaseDto
     */
    'timeout'?: number;
    /**
     * Updated sentinel master fields
     * @type {UpdateSentinelMasterDto}
     * @memberof UpdateDatabaseDto
     */
    'sentinelMaster'?: UpdateSentinelMasterDto;
}

export const UpdateDatabaseDtoCompressorEnum = {
    None: 'NONE',
    Gzip: 'GZIP',
    Zstd: 'ZSTD',
    Lz4: 'LZ4',
    Snappy: 'SNAPPY',
    Brotli: 'Brotli',
    PhpgzCompress: 'PHPGZCompress'
} as const;

export type UpdateDatabaseDtoCompressorEnum = typeof UpdateDatabaseDtoCompressorEnum[keyof typeof UpdateDatabaseDtoCompressorEnum];
export const UpdateDatabaseDtoKeyNameFormatEnum = {
    Unicode: 'Unicode',
    Hex: 'HEX'
} as const;

export type UpdateDatabaseDtoKeyNameFormatEnum = typeof UpdateDatabaseDtoKeyNameFormatEnum[keyof typeof UpdateDatabaseDtoKeyNameFormatEnum];

/**
 * 
 * @export
 * @interface UpdateHashFieldsTtlDto
 */
export interface UpdateHashFieldsTtlDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof UpdateHashFieldsTtlDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Hash fields
     * @type {Array<HashFieldTtlDto>}
     * @memberof UpdateHashFieldsTtlDto
     */
    'fields': Array<HashFieldTtlDto>;
}
/**
 * 
 * @export
 * @interface UpdateKeyTtlDto
 */
export interface UpdateKeyTtlDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof UpdateKeyTtlDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * Set a timeout on key in seconds. After the timeout has expired, the key will automatically be deleted. If the property has value of -1, then the key timeout will be removed.
     * @type {number}
     * @memberof UpdateKeyTtlDto
     */
    'ttl': number;
}
/**
 * 
 * @export
 * @interface UpdateMemberInZSetDto
 */
export interface UpdateMemberInZSetDto {
    /**
     * 
     * @type {CreateListWithExpireDtoKeyName}
     * @memberof UpdateMemberInZSetDto
     */
    'keyName': CreateListWithExpireDtoKeyName;
    /**
     * ZSet member
     * @type {ZSetMemberDto}
     * @memberof UpdateMemberInZSetDto
     */
    'member': ZSetMemberDto;
}
/**
 * 
 * @export
 * @interface UpdateRdiDto
 */
export interface UpdateRdiDto {
    /**
     * A name to associate with RDI
     * @type {string}
     * @memberof UpdateRdiDto
     */
    'name'?: string;
    /**
     * RDI or API username
     * @type {string}
     * @memberof UpdateRdiDto
     */
    'username'?: string;
    /**
     * RDI or API password
     * @type {string}
     * @memberof UpdateRdiDto
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface UpdateSentinelMasterDto
 */
export interface UpdateSentinelMasterDto {
    /**
     * Sentinel username, if your database is ACL enabled, otherwise leave this field empty.
     * @type {string}
     * @memberof UpdateSentinelMasterDto
     */
    'username'?: string;
    /**
     * The password for your Redis Sentinel master. If your master doesnt require a password, leave this field empty.
     * @type {string}
     * @memberof UpdateSentinelMasterDto
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface UpdateSettingsDto
 */
export interface UpdateSettingsDto {
    /**
     * Application theme.
     * @type {string}
     * @memberof UpdateSettingsDto
     */
    'theme'?: string;
    /**
     * Application date format.
     * @type {string}
     * @memberof UpdateSettingsDto
     */
    'dateFormat'?: string;
    /**
     * Application timezone.
     * @type {string}
     * @memberof UpdateSettingsDto
     */
    'timezone'?: string;
    /**
     * Threshold for scan operation.
     * @type {number}
     * @memberof UpdateSettingsDto
     */
    'scanThreshold'?: number;
    /**
     * Batch for workbench pipeline.
     * @type {number}
     * @memberof UpdateSettingsDto
     */
    'batchSize'?: number;
    /**
     * Agreements
     * @type {object}
     * @memberof UpdateSettingsDto
     */
    'agreements'?: object;
    /**
     * Reason describing why analytics are enabled
     * @type {string}
     * @memberof UpdateSettingsDto
     */
    'analyticsReason'?: string;
}
/**
 * 
 * @export
 * @interface UpdateSlowLogConfigDto
 */
export interface UpdateSlowLogConfigDto {
    /**
     * Max logs to store inside Redis slowlog
     * @type {number}
     * @memberof UpdateSlowLogConfigDto
     */
    'slowlogMaxLen'?: number;
    /**
     * Store logs with execution time greater than this value (in microseconds)
     * @type {number}
     * @memberof UpdateSlowLogConfigDto
     */
    'slowlogLogSlowerThan'?: number;
}
/**
 * 
 * @export
 * @interface UpdateSshOptionsDto
 */
export interface UpdateSshOptionsDto {
    /**
     * The hostname of SSH server
     * @type {string}
     * @memberof UpdateSshOptionsDto
     */
    'host'?: string;
    /**
     * The port of SSH server
     * @type {number}
     * @memberof UpdateSshOptionsDto
     */
    'port'?: number;
    /**
     * SSH username
     * @type {string}
     * @memberof UpdateSshOptionsDto
     */
    'username'?: string;
    /**
     * The SSH password
     * @type {string}
     * @memberof UpdateSshOptionsDto
     */
    'password'?: string;
    /**
     * The SSH private key
     * @type {string}
     * @memberof UpdateSshOptionsDto
     */
    'privateKey'?: string;
    /**
     * The SSH passphrase
     * @type {string}
     * @memberof UpdateSshOptionsDto
     */
    'passphrase'?: string;
}
/**
 * 
 * @export
 * @interface UpdateTagDto
 */
export interface UpdateTagDto {
    /**
     * Key of the tag.
     * @type {string}
     * @memberof UpdateTagDto
     */
    'key'?: string;
    /**
     * Value of the tag.
     * @type {string}
     * @memberof UpdateTagDto
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface UploadImportFileByPathDto
 */
export interface UploadImportFileByPathDto {
    /**
     * Internal path to data file
     * @type {string}
     * @memberof UploadImportFileByPathDto
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface UseCaCertificateDto
 */
export interface UseCaCertificateDto {
    /**
     * Certificate id
     * @type {string}
     * @memberof UseCaCertificateDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface UseClientCertificateDto
 */
export interface UseClientCertificateDto {
    /**
     * Certificate id
     * @type {string}
     * @memberof UseClientCertificateDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ZSetMemberDto
 */
export interface ZSetMemberDto {
    /**
     * 
     * @type {ZSetMemberDtoName}
     * @memberof ZSetMemberDto
     */
    'name': ZSetMemberDtoName;
    /**
     * Member score value.
     * @type {number}
     * @memberof ZSetMemberDto
     */
    'score': number;
}
/**
 * @type ZSetMemberDtoName
 * Member name value
 * @export
 */
export type ZSetMemberDtoName = CreateListWithExpireDtoKeyNameOneOf | string;


/**
 * AIApi - axios parameter creator
 * @export
 */
export const AIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new chat
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatControllerCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/ai/assistant/chats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset chat
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatControllerDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('aiChatControllerDelete', 'id', id)
            const localVarPath = `/api/ai/assistant/chats/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get chat history
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatControllerGetHistory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('aiChatControllerGetHistory', 'id', id)
            const localVarPath = `/api/ai/assistant/chats/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post a message
         * @summary 
         * @param {string} id 
         * @param {SendAiChatMessageDto} sendAiChatMessageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatControllerPostMessage: async (id: string, sendAiChatMessageDto: SendAiChatMessageDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('aiChatControllerPostMessage', 'id', id)
            // verify required parameter 'sendAiChatMessageDto' is not null or undefined
            assertParamExists('aiChatControllerPostMessage', 'sendAiChatMessageDto', sendAiChatMessageDto)
            const localVarPath = `/api/ai/assistant/chats/{id}/messages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendAiChatMessageDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate new query
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiQueryControllerClearHistory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('aiQueryControllerClearHistory', 'id', id)
            const localVarPath = `/api/ai/expert/{id}/messages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate new query
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiQueryControllerGetHistory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('aiQueryControllerGetHistory', 'id', id)
            const localVarPath = `/api/ai/expert/{id}/messages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate new query
         * @summary 
         * @param {string} id 
         * @param {SendAiQueryMessageDto} sendAiQueryMessageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiQueryControllerStreamQuestion: async (id: string, sendAiQueryMessageDto: SendAiQueryMessageDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('aiQueryControllerStreamQuestion', 'id', id)
            // verify required parameter 'sendAiQueryMessageDto' is not null or undefined
            assertParamExists('aiQueryControllerStreamQuestion', 'sendAiQueryMessageDto', sendAiQueryMessageDto)
            const localVarPath = `/api/ai/expert/{id}/messages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendAiQueryMessageDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AIApi - functional programming interface
 * @export
 */
export const AIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AIApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new chat
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiChatControllerCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickTypeClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiChatControllerCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIApi.aiChatControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reset chat
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiChatControllerDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiChatControllerDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIApi.aiChatControllerDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get chat history
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiChatControllerGetHistory(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AiChat>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiChatControllerGetHistory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIApi.aiChatControllerGetHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Post a message
         * @summary 
         * @param {string} id 
         * @param {SendAiChatMessageDto} sendAiChatMessageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiChatControllerPostMessage(id: string, sendAiChatMessageDto: SendAiChatMessageDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiChatControllerPostMessage(id, sendAiChatMessageDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIApi.aiChatControllerPostMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate new query
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiQueryControllerClearHistory(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiQueryControllerClearHistory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIApi.aiQueryControllerClearHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate new query
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiQueryControllerGetHistory(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiQueryControllerGetHistory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIApi.aiQueryControllerGetHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate new query
         * @summary 
         * @param {string} id 
         * @param {SendAiQueryMessageDto} sendAiQueryMessageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiQueryControllerStreamQuestion(id: string, sendAiQueryMessageDto: SendAiQueryMessageDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiQueryControllerStreamQuestion(id, sendAiQueryMessageDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIApi.aiQueryControllerStreamQuestion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AIApi - factory interface
 * @export
 */
export const AIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AIApiFp(configuration)
    return {
        /**
         * Create a new chat
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatControllerCreate(options?: RawAxiosRequestConfig): AxiosPromise<PickTypeClass> {
            return localVarFp.aiChatControllerCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * Reset chat
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatControllerDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.aiChatControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get chat history
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatControllerGetHistory(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AiChat> {
            return localVarFp.aiChatControllerGetHistory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Post a message
         * @summary 
         * @param {string} id 
         * @param {SendAiChatMessageDto} sendAiChatMessageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatControllerPostMessage(id: string, sendAiChatMessageDto: SendAiChatMessageDto, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.aiChatControllerPostMessage(id, sendAiChatMessageDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate new query
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiQueryControllerClearHistory(id: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.aiQueryControllerClearHistory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate new query
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiQueryControllerGetHistory(id: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.aiQueryControllerGetHistory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate new query
         * @summary 
         * @param {string} id 
         * @param {SendAiQueryMessageDto} sendAiQueryMessageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiQueryControllerStreamQuestion(id: string, sendAiQueryMessageDto: SendAiQueryMessageDto, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.aiQueryControllerStreamQuestion(id, sendAiQueryMessageDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AIApi - object-oriented interface
 * @export
 * @class AIApi
 * @extends {BaseAPI}
 */
export class AIApi extends BaseAPI {
    /**
     * Create a new chat
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    public aiChatControllerCreate(options?: RawAxiosRequestConfig) {
        return AIApiFp(this.configuration).aiChatControllerCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset chat
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    public aiChatControllerDelete(id: string, options?: RawAxiosRequestConfig) {
        return AIApiFp(this.configuration).aiChatControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get chat history
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    public aiChatControllerGetHistory(id: string, options?: RawAxiosRequestConfig) {
        return AIApiFp(this.configuration).aiChatControllerGetHistory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Post a message
     * @summary 
     * @param {string} id 
     * @param {SendAiChatMessageDto} sendAiChatMessageDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    public aiChatControllerPostMessage(id: string, sendAiChatMessageDto: SendAiChatMessageDto, options?: RawAxiosRequestConfig) {
        return AIApiFp(this.configuration).aiChatControllerPostMessage(id, sendAiChatMessageDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate new query
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    public aiQueryControllerClearHistory(id: string, options?: RawAxiosRequestConfig) {
        return AIApiFp(this.configuration).aiQueryControllerClearHistory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate new query
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    public aiQueryControllerGetHistory(id: string, options?: RawAxiosRequestConfig) {
        return AIApiFp(this.configuration).aiQueryControllerGetHistory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate new query
     * @summary 
     * @param {string} id 
     * @param {SendAiQueryMessageDto} sendAiQueryMessageDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    public aiQueryControllerStreamQuestion(id: string, sendAiQueryMessageDto: SendAiQueryMessageDto, options?: RawAxiosRequestConfig) {
        return AIApiFp(this.configuration).aiQueryControllerStreamQuestion(id, sendAiQueryMessageDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Send telemetry event
         * @summary 
         * @param {SendEventDto} sendEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsControllerSendEvent: async (sendEventDto: SendEventDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendEventDto' is not null or undefined
            assertParamExists('analyticsControllerSendEvent', 'sendEventDto', sendEventDto)
            const localVarPath = `/api/analytics/send-event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendEventDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send telemetry page
         * @summary 
         * @param {SendEventDto} sendEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsControllerSendPage: async (sendEventDto: SendEventDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendEventDto' is not null or undefined
            assertParamExists('analyticsControllerSendPage', 'sendEventDto', sendEventDto)
            const localVarPath = `/api/analytics/send-page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendEventDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Send telemetry event
         * @summary 
         * @param {SendEventDto} sendEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsControllerSendEvent(sendEventDto: SendEventDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsControllerSendEvent(sendEventDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.analyticsControllerSendEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send telemetry page
         * @summary 
         * @param {SendEventDto} sendEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsControllerSendPage(sendEventDto: SendEventDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsControllerSendPage(sendEventDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.analyticsControllerSendPage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * Send telemetry event
         * @summary 
         * @param {SendEventDto} sendEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsControllerSendEvent(sendEventDto: SendEventDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.analyticsControllerSendEvent(sendEventDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Send telemetry page
         * @summary 
         * @param {SendEventDto} sendEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsControllerSendPage(sendEventDto: SendEventDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.analyticsControllerSendPage(sendEventDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * Send telemetry event
     * @summary 
     * @param {SendEventDto} sendEventDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public analyticsControllerSendEvent(sendEventDto: SendEventDto, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).analyticsControllerSendEvent(sendEventDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send telemetry page
     * @summary 
     * @param {SendEventDto} sendEventDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public analyticsControllerSendPage(sendEventDto: SendEventDto, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).analyticsControllerSendPage(sendEventDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BrowserBrowserHistoryApi - axios parameter creator
 * @export
 */
export const BrowserBrowserHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete bulk browser history items
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {string} mode Search mode
         * @param {DeleteBrowserHistoryItemsDto} deleteBrowserHistoryItemsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        browserHistoryControllerBulkDelete: async (dbInstance: string, mode: string, deleteBrowserHistoryItemsDto: DeleteBrowserHistoryItemsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('browserHistoryControllerBulkDelete', 'dbInstance', dbInstance)
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('browserHistoryControllerBulkDelete', 'mode', mode)
            // verify required parameter 'deleteBrowserHistoryItemsDto' is not null or undefined
            assertParamExists('browserHistoryControllerBulkDelete', 'deleteBrowserHistoryItemsDto', deleteBrowserHistoryItemsDto)
            const localVarPath = `/api/databases/{dbInstance}/history`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteBrowserHistoryItemsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete browser history item by id
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {string} mode Search mode
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        browserHistoryControllerDelete: async (dbInstance: string, mode: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('browserHistoryControllerDelete', 'dbInstance', dbInstance)
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('browserHistoryControllerDelete', 'mode', mode)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('browserHistoryControllerDelete', 'id', id)
            const localVarPath = `/api/databases/{dbInstance}/history/{id}`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get browser history
         * @summary 
         * @param {string} dbInstance 
         * @param {BrowserHistoryControllerListModeEnum} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        browserHistoryControllerList: async (dbInstance: string, mode: BrowserHistoryControllerListModeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('browserHistoryControllerList', 'dbInstance', dbInstance)
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('browserHistoryControllerList', 'mode', mode)
            const localVarPath = `/api/databases/{dbInstance}/history`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrowserBrowserHistoryApi - functional programming interface
 * @export
 */
export const BrowserBrowserHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrowserBrowserHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete bulk browser history items
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {string} mode Search mode
         * @param {DeleteBrowserHistoryItemsDto} deleteBrowserHistoryItemsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async browserHistoryControllerBulkDelete(dbInstance: string, mode: string, deleteBrowserHistoryItemsDto: DeleteBrowserHistoryItemsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteBrowserHistoryItemsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.browserHistoryControllerBulkDelete(dbInstance, mode, deleteBrowserHistoryItemsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserBrowserHistoryApi.browserHistoryControllerBulkDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete browser history item by id
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {string} mode Search mode
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async browserHistoryControllerDelete(dbInstance: string, mode: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.browserHistoryControllerDelete(dbInstance, mode, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserBrowserHistoryApi.browserHistoryControllerDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get browser history
         * @summary 
         * @param {string} dbInstance 
         * @param {BrowserHistoryControllerListModeEnum} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async browserHistoryControllerList(dbInstance: string, mode: BrowserHistoryControllerListModeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrowserHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.browserHistoryControllerList(dbInstance, mode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserBrowserHistoryApi.browserHistoryControllerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BrowserBrowserHistoryApi - factory interface
 * @export
 */
export const BrowserBrowserHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrowserBrowserHistoryApiFp(configuration)
    return {
        /**
         * Delete bulk browser history items
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {string} mode Search mode
         * @param {DeleteBrowserHistoryItemsDto} deleteBrowserHistoryItemsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        browserHistoryControllerBulkDelete(dbInstance: string, mode: string, deleteBrowserHistoryItemsDto: DeleteBrowserHistoryItemsDto, options?: RawAxiosRequestConfig): AxiosPromise<DeleteBrowserHistoryItemsResponse> {
            return localVarFp.browserHistoryControllerBulkDelete(dbInstance, mode, deleteBrowserHistoryItemsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete browser history item by id
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {string} mode Search mode
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        browserHistoryControllerDelete(dbInstance: string, mode: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.browserHistoryControllerDelete(dbInstance, mode, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get browser history
         * @summary 
         * @param {string} dbInstance 
         * @param {BrowserHistoryControllerListModeEnum} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        browserHistoryControllerList(dbInstance: string, mode: BrowserHistoryControllerListModeEnum, options?: RawAxiosRequestConfig): AxiosPromise<BrowserHistory> {
            return localVarFp.browserHistoryControllerList(dbInstance, mode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrowserBrowserHistoryApi - object-oriented interface
 * @export
 * @class BrowserBrowserHistoryApi
 * @extends {BaseAPI}
 */
export class BrowserBrowserHistoryApi extends BaseAPI {
    /**
     * Delete bulk browser history items
     * @summary 
     * @param {string} dbInstance Database instance id.
     * @param {string} mode Search mode
     * @param {DeleteBrowserHistoryItemsDto} deleteBrowserHistoryItemsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserBrowserHistoryApi
     */
    public browserHistoryControllerBulkDelete(dbInstance: string, mode: string, deleteBrowserHistoryItemsDto: DeleteBrowserHistoryItemsDto, options?: RawAxiosRequestConfig) {
        return BrowserBrowserHistoryApiFp(this.configuration).browserHistoryControllerBulkDelete(dbInstance, mode, deleteBrowserHistoryItemsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete browser history item by id
     * @summary 
     * @param {string} dbInstance Database instance id.
     * @param {string} mode Search mode
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserBrowserHistoryApi
     */
    public browserHistoryControllerDelete(dbInstance: string, mode: string, id: string, options?: RawAxiosRequestConfig) {
        return BrowserBrowserHistoryApiFp(this.configuration).browserHistoryControllerDelete(dbInstance, mode, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get browser history
     * @summary 
     * @param {string} dbInstance 
     * @param {BrowserHistoryControllerListModeEnum} mode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserBrowserHistoryApi
     */
    public browserHistoryControllerList(dbInstance: string, mode: BrowserHistoryControllerListModeEnum, options?: RawAxiosRequestConfig) {
        return BrowserBrowserHistoryApiFp(this.configuration).browserHistoryControllerList(dbInstance, mode, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const BrowserHistoryControllerListModeEnum = {
    Pattern: 'pattern',
    Redisearch: 'redisearch'
} as const;
export type BrowserHistoryControllerListModeEnum = typeof BrowserHistoryControllerListModeEnum[keyof typeof BrowserHistoryControllerListModeEnum];


/**
 * BrowserHashApi - axios parameter creator
 * @export
 */
export const BrowserHashApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add the specified fields to the Hash stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {HashControllerAddMemberEncodingEnum} encoding 
         * @param {AddFieldsToHashDto} addFieldsToHashDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashControllerAddMember: async (dbInstance: string, encoding: HashControllerAddMemberEncodingEnum, addFieldsToHashDto: AddFieldsToHashDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('hashControllerAddMember', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('hashControllerAddMember', 'encoding', encoding)
            // verify required parameter 'addFieldsToHashDto' is not null or undefined
            assertParamExists('hashControllerAddMember', 'addFieldsToHashDto', addFieldsToHashDto)
            const localVarPath = `/api/databases/{dbInstance}/hash`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addFieldsToHashDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set key to hold Hash data type
         * @summary 
         * @param {string} dbInstance 
         * @param {HashControllerCreateHashEncodingEnum} encoding 
         * @param {CreateHashWithExpireDto} createHashWithExpireDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashControllerCreateHash: async (dbInstance: string, encoding: HashControllerCreateHashEncodingEnum, createHashWithExpireDto: CreateHashWithExpireDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('hashControllerCreateHash', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('hashControllerCreateHash', 'encoding', encoding)
            // verify required parameter 'createHashWithExpireDto' is not null or undefined
            assertParamExists('hashControllerCreateHash', 'createHashWithExpireDto', createHashWithExpireDto)
            const localVarPath = `/api/databases/{dbInstance}/hash`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createHashWithExpireDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the specified fields from the Hash stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {HashControllerDeleteFieldsEncodingEnum} encoding 
         * @param {DeleteFieldsFromHashDto} deleteFieldsFromHashDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashControllerDeleteFields: async (dbInstance: string, encoding: HashControllerDeleteFieldsEncodingEnum, deleteFieldsFromHashDto: DeleteFieldsFromHashDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('hashControllerDeleteFields', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('hashControllerDeleteFields', 'encoding', encoding)
            // verify required parameter 'deleteFieldsFromHashDto' is not null or undefined
            assertParamExists('hashControllerDeleteFields', 'deleteFieldsFromHashDto', deleteFieldsFromHashDto)
            const localVarPath = `/api/databases/{dbInstance}/hash/fields`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteFieldsFromHashDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get specified fields of the hash stored at key by cursor position
         * @summary 
         * @param {string} dbInstance 
         * @param {HashControllerGetMembersEncodingEnum} encoding 
         * @param {GetHashFieldsDto} getHashFieldsDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashControllerGetMembers: async (dbInstance: string, encoding: HashControllerGetMembersEncodingEnum, getHashFieldsDto: GetHashFieldsDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('hashControllerGetMembers', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('hashControllerGetMembers', 'encoding', encoding)
            // verify required parameter 'getHashFieldsDto' is not null or undefined
            assertParamExists('hashControllerGetMembers', 'getHashFieldsDto', getHashFieldsDto)
            const localVarPath = `/api/databases/{dbInstance}/hash/get-fields`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getHashFieldsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update hash fields ttl
         * @summary 
         * @param {string} dbInstance 
         * @param {HashControllerUpdateTtlEncodingEnum} encoding 
         * @param {UpdateHashFieldsTtlDto} updateHashFieldsTtlDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashControllerUpdateTtl: async (dbInstance: string, encoding: HashControllerUpdateTtlEncodingEnum, updateHashFieldsTtlDto: UpdateHashFieldsTtlDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('hashControllerUpdateTtl', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('hashControllerUpdateTtl', 'encoding', encoding)
            // verify required parameter 'updateHashFieldsTtlDto' is not null or undefined
            assertParamExists('hashControllerUpdateTtl', 'updateHashFieldsTtlDto', updateHashFieldsTtlDto)
            const localVarPath = `/api/databases/{dbInstance}/hash/ttl`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateHashFieldsTtlDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrowserHashApi - functional programming interface
 * @export
 */
export const BrowserHashApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrowserHashApiAxiosParamCreator(configuration)
    return {
        /**
         * Add the specified fields to the Hash stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {HashControllerAddMemberEncodingEnum} encoding 
         * @param {AddFieldsToHashDto} addFieldsToHashDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hashControllerAddMember(dbInstance: string, encoding: HashControllerAddMemberEncodingEnum, addFieldsToHashDto: AddFieldsToHashDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hashControllerAddMember(dbInstance, encoding, addFieldsToHashDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserHashApi.hashControllerAddMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set key to hold Hash data type
         * @summary 
         * @param {string} dbInstance 
         * @param {HashControllerCreateHashEncodingEnum} encoding 
         * @param {CreateHashWithExpireDto} createHashWithExpireDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hashControllerCreateHash(dbInstance: string, encoding: HashControllerCreateHashEncodingEnum, createHashWithExpireDto: CreateHashWithExpireDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hashControllerCreateHash(dbInstance, encoding, createHashWithExpireDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserHashApi.hashControllerCreateHash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove the specified fields from the Hash stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {HashControllerDeleteFieldsEncodingEnum} encoding 
         * @param {DeleteFieldsFromHashDto} deleteFieldsFromHashDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hashControllerDeleteFields(dbInstance: string, encoding: HashControllerDeleteFieldsEncodingEnum, deleteFieldsFromHashDto: DeleteFieldsFromHashDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteFieldsFromHashResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hashControllerDeleteFields(dbInstance, encoding, deleteFieldsFromHashDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserHashApi.hashControllerDeleteFields']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get specified fields of the hash stored at key by cursor position
         * @summary 
         * @param {string} dbInstance 
         * @param {HashControllerGetMembersEncodingEnum} encoding 
         * @param {GetHashFieldsDto} getHashFieldsDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hashControllerGetMembers(dbInstance: string, encoding: HashControllerGetMembersEncodingEnum, getHashFieldsDto: GetHashFieldsDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetHashFieldsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hashControllerGetMembers(dbInstance, encoding, getHashFieldsDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserHashApi.hashControllerGetMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update hash fields ttl
         * @summary 
         * @param {string} dbInstance 
         * @param {HashControllerUpdateTtlEncodingEnum} encoding 
         * @param {UpdateHashFieldsTtlDto} updateHashFieldsTtlDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hashControllerUpdateTtl(dbInstance: string, encoding: HashControllerUpdateTtlEncodingEnum, updateHashFieldsTtlDto: UpdateHashFieldsTtlDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hashControllerUpdateTtl(dbInstance, encoding, updateHashFieldsTtlDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserHashApi.hashControllerUpdateTtl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BrowserHashApi - factory interface
 * @export
 */
export const BrowserHashApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrowserHashApiFp(configuration)
    return {
        /**
         * Add the specified fields to the Hash stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {HashControllerAddMemberEncodingEnum} encoding 
         * @param {AddFieldsToHashDto} addFieldsToHashDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashControllerAddMember(dbInstance: string, encoding: HashControllerAddMemberEncodingEnum, addFieldsToHashDto: AddFieldsToHashDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.hashControllerAddMember(dbInstance, encoding, addFieldsToHashDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Set key to hold Hash data type
         * @summary 
         * @param {string} dbInstance 
         * @param {HashControllerCreateHashEncodingEnum} encoding 
         * @param {CreateHashWithExpireDto} createHashWithExpireDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashControllerCreateHash(dbInstance: string, encoding: HashControllerCreateHashEncodingEnum, createHashWithExpireDto: CreateHashWithExpireDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.hashControllerCreateHash(dbInstance, encoding, createHashWithExpireDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove the specified fields from the Hash stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {HashControllerDeleteFieldsEncodingEnum} encoding 
         * @param {DeleteFieldsFromHashDto} deleteFieldsFromHashDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashControllerDeleteFields(dbInstance: string, encoding: HashControllerDeleteFieldsEncodingEnum, deleteFieldsFromHashDto: DeleteFieldsFromHashDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteFieldsFromHashResponse> {
            return localVarFp.hashControllerDeleteFields(dbInstance, encoding, deleteFieldsFromHashDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get specified fields of the hash stored at key by cursor position
         * @summary 
         * @param {string} dbInstance 
         * @param {HashControllerGetMembersEncodingEnum} encoding 
         * @param {GetHashFieldsDto} getHashFieldsDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashControllerGetMembers(dbInstance: string, encoding: HashControllerGetMembersEncodingEnum, getHashFieldsDto: GetHashFieldsDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetHashFieldsResponse> {
            return localVarFp.hashControllerGetMembers(dbInstance, encoding, getHashFieldsDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Update hash fields ttl
         * @summary 
         * @param {string} dbInstance 
         * @param {HashControllerUpdateTtlEncodingEnum} encoding 
         * @param {UpdateHashFieldsTtlDto} updateHashFieldsTtlDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashControllerUpdateTtl(dbInstance: string, encoding: HashControllerUpdateTtlEncodingEnum, updateHashFieldsTtlDto: UpdateHashFieldsTtlDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.hashControllerUpdateTtl(dbInstance, encoding, updateHashFieldsTtlDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrowserHashApi - object-oriented interface
 * @export
 * @class BrowserHashApi
 * @extends {BaseAPI}
 */
export class BrowserHashApi extends BaseAPI {
    /**
     * Add the specified fields to the Hash stored at key
     * @summary 
     * @param {string} dbInstance 
     * @param {HashControllerAddMemberEncodingEnum} encoding 
     * @param {AddFieldsToHashDto} addFieldsToHashDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserHashApi
     */
    public hashControllerAddMember(dbInstance: string, encoding: HashControllerAddMemberEncodingEnum, addFieldsToHashDto: AddFieldsToHashDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserHashApiFp(this.configuration).hashControllerAddMember(dbInstance, encoding, addFieldsToHashDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set key to hold Hash data type
     * @summary 
     * @param {string} dbInstance 
     * @param {HashControllerCreateHashEncodingEnum} encoding 
     * @param {CreateHashWithExpireDto} createHashWithExpireDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserHashApi
     */
    public hashControllerCreateHash(dbInstance: string, encoding: HashControllerCreateHashEncodingEnum, createHashWithExpireDto: CreateHashWithExpireDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserHashApiFp(this.configuration).hashControllerCreateHash(dbInstance, encoding, createHashWithExpireDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove the specified fields from the Hash stored at key
     * @summary 
     * @param {string} dbInstance 
     * @param {HashControllerDeleteFieldsEncodingEnum} encoding 
     * @param {DeleteFieldsFromHashDto} deleteFieldsFromHashDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserHashApi
     */
    public hashControllerDeleteFields(dbInstance: string, encoding: HashControllerDeleteFieldsEncodingEnum, deleteFieldsFromHashDto: DeleteFieldsFromHashDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserHashApiFp(this.configuration).hashControllerDeleteFields(dbInstance, encoding, deleteFieldsFromHashDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get specified fields of the hash stored at key by cursor position
     * @summary 
     * @param {string} dbInstance 
     * @param {HashControllerGetMembersEncodingEnum} encoding 
     * @param {GetHashFieldsDto} getHashFieldsDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserHashApi
     */
    public hashControllerGetMembers(dbInstance: string, encoding: HashControllerGetMembersEncodingEnum, getHashFieldsDto: GetHashFieldsDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserHashApiFp(this.configuration).hashControllerGetMembers(dbInstance, encoding, getHashFieldsDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update hash fields ttl
     * @summary 
     * @param {string} dbInstance 
     * @param {HashControllerUpdateTtlEncodingEnum} encoding 
     * @param {UpdateHashFieldsTtlDto} updateHashFieldsTtlDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserHashApi
     */
    public hashControllerUpdateTtl(dbInstance: string, encoding: HashControllerUpdateTtlEncodingEnum, updateHashFieldsTtlDto: UpdateHashFieldsTtlDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserHashApiFp(this.configuration).hashControllerUpdateTtl(dbInstance, encoding, updateHashFieldsTtlDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const HashControllerAddMemberEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type HashControllerAddMemberEncodingEnum = typeof HashControllerAddMemberEncodingEnum[keyof typeof HashControllerAddMemberEncodingEnum];
/**
 * @export
 */
export const HashControllerCreateHashEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type HashControllerCreateHashEncodingEnum = typeof HashControllerCreateHashEncodingEnum[keyof typeof HashControllerCreateHashEncodingEnum];
/**
 * @export
 */
export const HashControllerDeleteFieldsEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type HashControllerDeleteFieldsEncodingEnum = typeof HashControllerDeleteFieldsEncodingEnum[keyof typeof HashControllerDeleteFieldsEncodingEnum];
/**
 * @export
 */
export const HashControllerGetMembersEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type HashControllerGetMembersEncodingEnum = typeof HashControllerGetMembersEncodingEnum[keyof typeof HashControllerGetMembersEncodingEnum];
/**
 * @export
 */
export const HashControllerUpdateTtlEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type HashControllerUpdateTtlEncodingEnum = typeof HashControllerUpdateTtlEncodingEnum[keyof typeof HashControllerUpdateTtlEncodingEnum];


/**
 * BrowserKeysApi - axios parameter creator
 * @export
 */
export const BrowserKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete key
         * @summary 
         * @param {string} dbInstance 
         * @param {KeysControllerDeleteKeyEncodingEnum} encoding 
         * @param {DeleteKeysDto} deleteKeysDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysControllerDeleteKey: async (dbInstance: string, encoding: KeysControllerDeleteKeyEncodingEnum, deleteKeysDto: DeleteKeysDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('keysControllerDeleteKey', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('keysControllerDeleteKey', 'encoding', encoding)
            // verify required parameter 'deleteKeysDto' is not null or undefined
            assertParamExists('keysControllerDeleteKey', 'deleteKeysDto', deleteKeysDto)
            const localVarPath = `/api/databases/{dbInstance}/keys`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteKeysDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get key info
         * @summary 
         * @param {string} dbInstance 
         * @param {KeysControllerGetKeyInfoEncodingEnum} encoding 
         * @param {GetKeyInfoDto} getKeyInfoDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysControllerGetKeyInfo: async (dbInstance: string, encoding: KeysControllerGetKeyInfoEncodingEnum, getKeyInfoDto: GetKeyInfoDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('keysControllerGetKeyInfo', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('keysControllerGetKeyInfo', 'encoding', encoding)
            // verify required parameter 'getKeyInfoDto' is not null or undefined
            assertParamExists('keysControllerGetKeyInfo', 'getKeyInfoDto', getKeyInfoDto)
            const localVarPath = `/api/databases/{dbInstance}/keys/get-info`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getKeyInfoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get keys by cursor position
         * @summary 
         * @param {string} dbInstance 
         * @param {KeysControllerGetKeysEncodingEnum} encoding 
         * @param {GetKeysDto} getKeysDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysControllerGetKeys: async (dbInstance: string, encoding: KeysControllerGetKeysEncodingEnum, getKeysDto: GetKeysDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('keysControllerGetKeys', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('keysControllerGetKeys', 'encoding', encoding)
            // verify required parameter 'getKeysDto' is not null or undefined
            assertParamExists('keysControllerGetKeys', 'getKeysDto', getKeysDto)
            const localVarPath = `/api/databases/{dbInstance}/keys`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getKeysDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get info for multiple keys
         * @summary 
         * @param {string} dbInstance 
         * @param {KeysControllerGetKeysInfoEncodingEnum} encoding 
         * @param {GetKeysInfoDto} getKeysInfoDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysControllerGetKeysInfo: async (dbInstance: string, encoding: KeysControllerGetKeysInfoEncodingEnum, getKeysInfoDto: GetKeysInfoDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('keysControllerGetKeysInfo', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('keysControllerGetKeysInfo', 'encoding', encoding)
            // verify required parameter 'getKeysInfoDto' is not null or undefined
            assertParamExists('keysControllerGetKeysInfo', 'getKeysInfoDto', getKeysInfoDto)
            const localVarPath = `/api/databases/{dbInstance}/keys/get-metadata`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getKeysInfoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rename key
         * @summary 
         * @param {string} dbInstance 
         * @param {KeysControllerRenameKeyEncodingEnum} encoding 
         * @param {RenameKeyDto} renameKeyDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysControllerRenameKey: async (dbInstance: string, encoding: KeysControllerRenameKeyEncodingEnum, renameKeyDto: RenameKeyDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('keysControllerRenameKey', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('keysControllerRenameKey', 'encoding', encoding)
            // verify required parameter 'renameKeyDto' is not null or undefined
            assertParamExists('keysControllerRenameKey', 'renameKeyDto', renameKeyDto)
            const localVarPath = `/api/databases/{dbInstance}/keys/name`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renameKeyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the remaining time to live of a key
         * @summary 
         * @param {string} dbInstance 
         * @param {KeysControllerUpdateTtlEncodingEnum} encoding 
         * @param {UpdateKeyTtlDto} updateKeyTtlDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysControllerUpdateTtl: async (dbInstance: string, encoding: KeysControllerUpdateTtlEncodingEnum, updateKeyTtlDto: UpdateKeyTtlDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('keysControllerUpdateTtl', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('keysControllerUpdateTtl', 'encoding', encoding)
            // verify required parameter 'updateKeyTtlDto' is not null or undefined
            assertParamExists('keysControllerUpdateTtl', 'updateKeyTtlDto', updateKeyTtlDto)
            const localVarPath = `/api/databases/{dbInstance}/keys/ttl`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateKeyTtlDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrowserKeysApi - functional programming interface
 * @export
 */
export const BrowserKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrowserKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete key
         * @summary 
         * @param {string} dbInstance 
         * @param {KeysControllerDeleteKeyEncodingEnum} encoding 
         * @param {DeleteKeysDto} deleteKeysDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keysControllerDeleteKey(dbInstance: string, encoding: KeysControllerDeleteKeyEncodingEnum, deleteKeysDto: DeleteKeysDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteKeysResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keysControllerDeleteKey(dbInstance, encoding, deleteKeysDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserKeysApi.keysControllerDeleteKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get key info
         * @summary 
         * @param {string} dbInstance 
         * @param {KeysControllerGetKeyInfoEncodingEnum} encoding 
         * @param {GetKeyInfoDto} getKeyInfoDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keysControllerGetKeyInfo(dbInstance: string, encoding: KeysControllerGetKeyInfoEncodingEnum, getKeyInfoDto: GetKeyInfoDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetKeyInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keysControllerGetKeyInfo(dbInstance, encoding, getKeyInfoDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserKeysApi.keysControllerGetKeyInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get keys by cursor position
         * @summary 
         * @param {string} dbInstance 
         * @param {KeysControllerGetKeysEncodingEnum} encoding 
         * @param {GetKeysDto} getKeysDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keysControllerGetKeys(dbInstance: string, encoding: KeysControllerGetKeysEncodingEnum, getKeysDto: GetKeysDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetKeysWithDetailsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keysControllerGetKeys(dbInstance, encoding, getKeysDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserKeysApi.keysControllerGetKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get info for multiple keys
         * @summary 
         * @param {string} dbInstance 
         * @param {KeysControllerGetKeysInfoEncodingEnum} encoding 
         * @param {GetKeysInfoDto} getKeysInfoDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keysControllerGetKeysInfo(dbInstance: string, encoding: KeysControllerGetKeysInfoEncodingEnum, getKeysInfoDto: GetKeysInfoDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetKeyInfoResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keysControllerGetKeysInfo(dbInstance, encoding, getKeysInfoDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserKeysApi.keysControllerGetKeysInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Rename key
         * @summary 
         * @param {string} dbInstance 
         * @param {KeysControllerRenameKeyEncodingEnum} encoding 
         * @param {RenameKeyDto} renameKeyDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keysControllerRenameKey(dbInstance: string, encoding: KeysControllerRenameKeyEncodingEnum, renameKeyDto: RenameKeyDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RenameKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keysControllerRenameKey(dbInstance, encoding, renameKeyDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserKeysApi.keysControllerRenameKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the remaining time to live of a key
         * @summary 
         * @param {string} dbInstance 
         * @param {KeysControllerUpdateTtlEncodingEnum} encoding 
         * @param {UpdateKeyTtlDto} updateKeyTtlDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keysControllerUpdateTtl(dbInstance: string, encoding: KeysControllerUpdateTtlEncodingEnum, updateKeyTtlDto: UpdateKeyTtlDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyTtlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keysControllerUpdateTtl(dbInstance, encoding, updateKeyTtlDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserKeysApi.keysControllerUpdateTtl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BrowserKeysApi - factory interface
 * @export
 */
export const BrowserKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrowserKeysApiFp(configuration)
    return {
        /**
         * Delete key
         * @summary 
         * @param {string} dbInstance 
         * @param {KeysControllerDeleteKeyEncodingEnum} encoding 
         * @param {DeleteKeysDto} deleteKeysDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysControllerDeleteKey(dbInstance: string, encoding: KeysControllerDeleteKeyEncodingEnum, deleteKeysDto: DeleteKeysDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteKeysResponse> {
            return localVarFp.keysControllerDeleteKey(dbInstance, encoding, deleteKeysDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get key info
         * @summary 
         * @param {string} dbInstance 
         * @param {KeysControllerGetKeyInfoEncodingEnum} encoding 
         * @param {GetKeyInfoDto} getKeyInfoDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysControllerGetKeyInfo(dbInstance: string, encoding: KeysControllerGetKeyInfoEncodingEnum, getKeyInfoDto: GetKeyInfoDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetKeyInfoResponse> {
            return localVarFp.keysControllerGetKeyInfo(dbInstance, encoding, getKeyInfoDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get keys by cursor position
         * @summary 
         * @param {string} dbInstance 
         * @param {KeysControllerGetKeysEncodingEnum} encoding 
         * @param {GetKeysDto} getKeysDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysControllerGetKeys(dbInstance: string, encoding: KeysControllerGetKeysEncodingEnum, getKeysDto: GetKeysDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetKeysWithDetailsResponse>> {
            return localVarFp.keysControllerGetKeys(dbInstance, encoding, getKeysDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get info for multiple keys
         * @summary 
         * @param {string} dbInstance 
         * @param {KeysControllerGetKeysInfoEncodingEnum} encoding 
         * @param {GetKeysInfoDto} getKeysInfoDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysControllerGetKeysInfo(dbInstance: string, encoding: KeysControllerGetKeysInfoEncodingEnum, getKeysInfoDto: GetKeysInfoDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetKeyInfoResponse>> {
            return localVarFp.keysControllerGetKeysInfo(dbInstance, encoding, getKeysInfoDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Rename key
         * @summary 
         * @param {string} dbInstance 
         * @param {KeysControllerRenameKeyEncodingEnum} encoding 
         * @param {RenameKeyDto} renameKeyDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysControllerRenameKey(dbInstance: string, encoding: KeysControllerRenameKeyEncodingEnum, renameKeyDto: RenameKeyDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<RenameKeyResponse> {
            return localVarFp.keysControllerRenameKey(dbInstance, encoding, renameKeyDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the remaining time to live of a key
         * @summary 
         * @param {string} dbInstance 
         * @param {KeysControllerUpdateTtlEncodingEnum} encoding 
         * @param {UpdateKeyTtlDto} updateKeyTtlDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysControllerUpdateTtl(dbInstance: string, encoding: KeysControllerUpdateTtlEncodingEnum, updateKeyTtlDto: UpdateKeyTtlDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<KeyTtlResponse> {
            return localVarFp.keysControllerUpdateTtl(dbInstance, encoding, updateKeyTtlDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrowserKeysApi - object-oriented interface
 * @export
 * @class BrowserKeysApi
 * @extends {BaseAPI}
 */
export class BrowserKeysApi extends BaseAPI {
    /**
     * Delete key
     * @summary 
     * @param {string} dbInstance 
     * @param {KeysControllerDeleteKeyEncodingEnum} encoding 
     * @param {DeleteKeysDto} deleteKeysDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserKeysApi
     */
    public keysControllerDeleteKey(dbInstance: string, encoding: KeysControllerDeleteKeyEncodingEnum, deleteKeysDto: DeleteKeysDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserKeysApiFp(this.configuration).keysControllerDeleteKey(dbInstance, encoding, deleteKeysDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get key info
     * @summary 
     * @param {string} dbInstance 
     * @param {KeysControllerGetKeyInfoEncodingEnum} encoding 
     * @param {GetKeyInfoDto} getKeyInfoDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserKeysApi
     */
    public keysControllerGetKeyInfo(dbInstance: string, encoding: KeysControllerGetKeyInfoEncodingEnum, getKeyInfoDto: GetKeyInfoDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserKeysApiFp(this.configuration).keysControllerGetKeyInfo(dbInstance, encoding, getKeyInfoDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get keys by cursor position
     * @summary 
     * @param {string} dbInstance 
     * @param {KeysControllerGetKeysEncodingEnum} encoding 
     * @param {GetKeysDto} getKeysDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserKeysApi
     */
    public keysControllerGetKeys(dbInstance: string, encoding: KeysControllerGetKeysEncodingEnum, getKeysDto: GetKeysDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserKeysApiFp(this.configuration).keysControllerGetKeys(dbInstance, encoding, getKeysDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get info for multiple keys
     * @summary 
     * @param {string} dbInstance 
     * @param {KeysControllerGetKeysInfoEncodingEnum} encoding 
     * @param {GetKeysInfoDto} getKeysInfoDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserKeysApi
     */
    public keysControllerGetKeysInfo(dbInstance: string, encoding: KeysControllerGetKeysInfoEncodingEnum, getKeysInfoDto: GetKeysInfoDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserKeysApiFp(this.configuration).keysControllerGetKeysInfo(dbInstance, encoding, getKeysInfoDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rename key
     * @summary 
     * @param {string} dbInstance 
     * @param {KeysControllerRenameKeyEncodingEnum} encoding 
     * @param {RenameKeyDto} renameKeyDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserKeysApi
     */
    public keysControllerRenameKey(dbInstance: string, encoding: KeysControllerRenameKeyEncodingEnum, renameKeyDto: RenameKeyDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserKeysApiFp(this.configuration).keysControllerRenameKey(dbInstance, encoding, renameKeyDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the remaining time to live of a key
     * @summary 
     * @param {string} dbInstance 
     * @param {KeysControllerUpdateTtlEncodingEnum} encoding 
     * @param {UpdateKeyTtlDto} updateKeyTtlDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserKeysApi
     */
    public keysControllerUpdateTtl(dbInstance: string, encoding: KeysControllerUpdateTtlEncodingEnum, updateKeyTtlDto: UpdateKeyTtlDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserKeysApiFp(this.configuration).keysControllerUpdateTtl(dbInstance, encoding, updateKeyTtlDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const KeysControllerDeleteKeyEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type KeysControllerDeleteKeyEncodingEnum = typeof KeysControllerDeleteKeyEncodingEnum[keyof typeof KeysControllerDeleteKeyEncodingEnum];
/**
 * @export
 */
export const KeysControllerGetKeyInfoEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type KeysControllerGetKeyInfoEncodingEnum = typeof KeysControllerGetKeyInfoEncodingEnum[keyof typeof KeysControllerGetKeyInfoEncodingEnum];
/**
 * @export
 */
export const KeysControllerGetKeysEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type KeysControllerGetKeysEncodingEnum = typeof KeysControllerGetKeysEncodingEnum[keyof typeof KeysControllerGetKeysEncodingEnum];
/**
 * @export
 */
export const KeysControllerGetKeysInfoEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type KeysControllerGetKeysInfoEncodingEnum = typeof KeysControllerGetKeysInfoEncodingEnum[keyof typeof KeysControllerGetKeysInfoEncodingEnum];
/**
 * @export
 */
export const KeysControllerRenameKeyEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type KeysControllerRenameKeyEncodingEnum = typeof KeysControllerRenameKeyEncodingEnum[keyof typeof KeysControllerRenameKeyEncodingEnum];
/**
 * @export
 */
export const KeysControllerUpdateTtlEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type KeysControllerUpdateTtlEncodingEnum = typeof KeysControllerUpdateTtlEncodingEnum[keyof typeof KeysControllerUpdateTtlEncodingEnum];


/**
 * BrowserListApi - axios parameter creator
 * @export
 */
export const BrowserListApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Set key to hold list data type
         * @summary 
         * @param {string} dbInstance 
         * @param {ListControllerCreateListEncodingEnum} encoding 
         * @param {CreateListWithExpireDto} createListWithExpireDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listControllerCreateList: async (dbInstance: string, encoding: ListControllerCreateListEncodingEnum, createListWithExpireDto: CreateListWithExpireDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('listControllerCreateList', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('listControllerCreateList', 'encoding', encoding)
            // verify required parameter 'createListWithExpireDto' is not null or undefined
            assertParamExists('listControllerCreateList', 'createListWithExpireDto', createListWithExpireDto)
            const localVarPath = `/api/databases/{dbInstance}/list`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createListWithExpireDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove and return the elements from the tail/head of list stored at key.
         * @summary 
         * @param {string} dbInstance 
         * @param {ListControllerDeleteElementEncodingEnum} encoding 
         * @param {DeleteListElementsDto} deleteListElementsDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listControllerDeleteElement: async (dbInstance: string, encoding: ListControllerDeleteElementEncodingEnum, deleteListElementsDto: DeleteListElementsDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('listControllerDeleteElement', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('listControllerDeleteElement', 'encoding', encoding)
            // verify required parameter 'deleteListElementsDto' is not null or undefined
            assertParamExists('listControllerDeleteElement', 'deleteListElementsDto', deleteListElementsDto)
            const localVarPath = `/api/databases/{dbInstance}/list/elements`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteListElementsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get specified List element by index
         * @summary 
         * @param {number} index Zero-based index. 0 - first element, 1 - second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, -1 means the last element
         * @param {string} dbInstance 
         * @param {ListControllerGetElementEncodingEnum} encoding 
         * @param {KeyDto} keyDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listControllerGetElement: async (index: number, dbInstance: string, encoding: ListControllerGetElementEncodingEnum, keyDto: KeyDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'index' is not null or undefined
            assertParamExists('listControllerGetElement', 'index', index)
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('listControllerGetElement', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('listControllerGetElement', 'encoding', encoding)
            // verify required parameter 'keyDto' is not null or undefined
            assertParamExists('listControllerGetElement', 'keyDto', keyDto)
            const localVarPath = `/api/databases/{dbInstance}/list/get-elements/{index}`
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get specified elements of the list stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {ListControllerGetElementsEncodingEnum} encoding 
         * @param {GetListElementsDto} getListElementsDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listControllerGetElements: async (dbInstance: string, encoding: ListControllerGetElementsEncodingEnum, getListElementsDto: GetListElementsDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('listControllerGetElements', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('listControllerGetElements', 'encoding', encoding)
            // verify required parameter 'getListElementsDto' is not null or undefined
            assertParamExists('listControllerGetElements', 'getListElementsDto', getListElementsDto)
            const localVarPath = `/api/databases/{dbInstance}/list/get-elements`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getListElementsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Insert element at the head/tail of the List data type
         * @summary 
         * @param {string} dbInstance 
         * @param {ListControllerPushElementEncodingEnum} encoding 
         * @param {PushElementToListDto} pushElementToListDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listControllerPushElement: async (dbInstance: string, encoding: ListControllerPushElementEncodingEnum, pushElementToListDto: PushElementToListDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('listControllerPushElement', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('listControllerPushElement', 'encoding', encoding)
            // verify required parameter 'pushElementToListDto' is not null or undefined
            assertParamExists('listControllerPushElement', 'pushElementToListDto', pushElementToListDto)
            const localVarPath = `/api/databases/{dbInstance}/list`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pushElementToListDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update list element by index.
         * @summary 
         * @param {string} dbInstance 
         * @param {ListControllerUpdateElementEncodingEnum} encoding 
         * @param {SetListElementDto} setListElementDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listControllerUpdateElement: async (dbInstance: string, encoding: ListControllerUpdateElementEncodingEnum, setListElementDto: SetListElementDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('listControllerUpdateElement', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('listControllerUpdateElement', 'encoding', encoding)
            // verify required parameter 'setListElementDto' is not null or undefined
            assertParamExists('listControllerUpdateElement', 'setListElementDto', setListElementDto)
            const localVarPath = `/api/databases/{dbInstance}/list`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setListElementDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrowserListApi - functional programming interface
 * @export
 */
export const BrowserListApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrowserListApiAxiosParamCreator(configuration)
    return {
        /**
         * Set key to hold list data type
         * @summary 
         * @param {string} dbInstance 
         * @param {ListControllerCreateListEncodingEnum} encoding 
         * @param {CreateListWithExpireDto} createListWithExpireDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listControllerCreateList(dbInstance: string, encoding: ListControllerCreateListEncodingEnum, createListWithExpireDto: CreateListWithExpireDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listControllerCreateList(dbInstance, encoding, createListWithExpireDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserListApi.listControllerCreateList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove and return the elements from the tail/head of list stored at key.
         * @summary 
         * @param {string} dbInstance 
         * @param {ListControllerDeleteElementEncodingEnum} encoding 
         * @param {DeleteListElementsDto} deleteListElementsDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listControllerDeleteElement(dbInstance: string, encoding: ListControllerDeleteElementEncodingEnum, deleteListElementsDto: DeleteListElementsDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteListElementsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listControllerDeleteElement(dbInstance, encoding, deleteListElementsDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserListApi.listControllerDeleteElement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get specified List element by index
         * @summary 
         * @param {number} index Zero-based index. 0 - first element, 1 - second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, -1 means the last element
         * @param {string} dbInstance 
         * @param {ListControllerGetElementEncodingEnum} encoding 
         * @param {KeyDto} keyDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listControllerGetElement(index: number, dbInstance: string, encoding: ListControllerGetElementEncodingEnum, keyDto: KeyDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetListElementResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listControllerGetElement(index, dbInstance, encoding, keyDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserListApi.listControllerGetElement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get specified elements of the list stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {ListControllerGetElementsEncodingEnum} encoding 
         * @param {GetListElementsDto} getListElementsDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listControllerGetElements(dbInstance: string, encoding: ListControllerGetElementsEncodingEnum, getListElementsDto: GetListElementsDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetListElementsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listControllerGetElements(dbInstance, encoding, getListElementsDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserListApi.listControllerGetElements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Insert element at the head/tail of the List data type
         * @summary 
         * @param {string} dbInstance 
         * @param {ListControllerPushElementEncodingEnum} encoding 
         * @param {PushElementToListDto} pushElementToListDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listControllerPushElement(dbInstance: string, encoding: ListControllerPushElementEncodingEnum, pushElementToListDto: PushElementToListDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PushListElementsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listControllerPushElement(dbInstance, encoding, pushElementToListDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserListApi.listControllerPushElement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update list element by index.
         * @summary 
         * @param {string} dbInstance 
         * @param {ListControllerUpdateElementEncodingEnum} encoding 
         * @param {SetListElementDto} setListElementDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listControllerUpdateElement(dbInstance: string, encoding: ListControllerUpdateElementEncodingEnum, setListElementDto: SetListElementDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetListElementResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listControllerUpdateElement(dbInstance, encoding, setListElementDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserListApi.listControllerUpdateElement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BrowserListApi - factory interface
 * @export
 */
export const BrowserListApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrowserListApiFp(configuration)
    return {
        /**
         * Set key to hold list data type
         * @summary 
         * @param {string} dbInstance 
         * @param {ListControllerCreateListEncodingEnum} encoding 
         * @param {CreateListWithExpireDto} createListWithExpireDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listControllerCreateList(dbInstance: string, encoding: ListControllerCreateListEncodingEnum, createListWithExpireDto: CreateListWithExpireDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.listControllerCreateList(dbInstance, encoding, createListWithExpireDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove and return the elements from the tail/head of list stored at key.
         * @summary 
         * @param {string} dbInstance 
         * @param {ListControllerDeleteElementEncodingEnum} encoding 
         * @param {DeleteListElementsDto} deleteListElementsDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listControllerDeleteElement(dbInstance: string, encoding: ListControllerDeleteElementEncodingEnum, deleteListElementsDto: DeleteListElementsDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteListElementsResponse> {
            return localVarFp.listControllerDeleteElement(dbInstance, encoding, deleteListElementsDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get specified List element by index
         * @summary 
         * @param {number} index Zero-based index. 0 - first element, 1 - second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, -1 means the last element
         * @param {string} dbInstance 
         * @param {ListControllerGetElementEncodingEnum} encoding 
         * @param {KeyDto} keyDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listControllerGetElement(index: number, dbInstance: string, encoding: ListControllerGetElementEncodingEnum, keyDto: KeyDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetListElementResponse> {
            return localVarFp.listControllerGetElement(index, dbInstance, encoding, keyDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get specified elements of the list stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {ListControllerGetElementsEncodingEnum} encoding 
         * @param {GetListElementsDto} getListElementsDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listControllerGetElements(dbInstance: string, encoding: ListControllerGetElementsEncodingEnum, getListElementsDto: GetListElementsDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetListElementsResponse> {
            return localVarFp.listControllerGetElements(dbInstance, encoding, getListElementsDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Insert element at the head/tail of the List data type
         * @summary 
         * @param {string} dbInstance 
         * @param {ListControllerPushElementEncodingEnum} encoding 
         * @param {PushElementToListDto} pushElementToListDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listControllerPushElement(dbInstance: string, encoding: ListControllerPushElementEncodingEnum, pushElementToListDto: PushElementToListDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<PushListElementsResponse> {
            return localVarFp.listControllerPushElement(dbInstance, encoding, pushElementToListDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Update list element by index.
         * @summary 
         * @param {string} dbInstance 
         * @param {ListControllerUpdateElementEncodingEnum} encoding 
         * @param {SetListElementDto} setListElementDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listControllerUpdateElement(dbInstance: string, encoding: ListControllerUpdateElementEncodingEnum, setListElementDto: SetListElementDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<SetListElementResponse> {
            return localVarFp.listControllerUpdateElement(dbInstance, encoding, setListElementDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrowserListApi - object-oriented interface
 * @export
 * @class BrowserListApi
 * @extends {BaseAPI}
 */
export class BrowserListApi extends BaseAPI {
    /**
     * Set key to hold list data type
     * @summary 
     * @param {string} dbInstance 
     * @param {ListControllerCreateListEncodingEnum} encoding 
     * @param {CreateListWithExpireDto} createListWithExpireDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserListApi
     */
    public listControllerCreateList(dbInstance: string, encoding: ListControllerCreateListEncodingEnum, createListWithExpireDto: CreateListWithExpireDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserListApiFp(this.configuration).listControllerCreateList(dbInstance, encoding, createListWithExpireDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove and return the elements from the tail/head of list stored at key.
     * @summary 
     * @param {string} dbInstance 
     * @param {ListControllerDeleteElementEncodingEnum} encoding 
     * @param {DeleteListElementsDto} deleteListElementsDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserListApi
     */
    public listControllerDeleteElement(dbInstance: string, encoding: ListControllerDeleteElementEncodingEnum, deleteListElementsDto: DeleteListElementsDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserListApiFp(this.configuration).listControllerDeleteElement(dbInstance, encoding, deleteListElementsDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get specified List element by index
     * @summary 
     * @param {number} index Zero-based index. 0 - first element, 1 - second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, -1 means the last element
     * @param {string} dbInstance 
     * @param {ListControllerGetElementEncodingEnum} encoding 
     * @param {KeyDto} keyDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserListApi
     */
    public listControllerGetElement(index: number, dbInstance: string, encoding: ListControllerGetElementEncodingEnum, keyDto: KeyDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserListApiFp(this.configuration).listControllerGetElement(index, dbInstance, encoding, keyDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get specified elements of the list stored at key
     * @summary 
     * @param {string} dbInstance 
     * @param {ListControllerGetElementsEncodingEnum} encoding 
     * @param {GetListElementsDto} getListElementsDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserListApi
     */
    public listControllerGetElements(dbInstance: string, encoding: ListControllerGetElementsEncodingEnum, getListElementsDto: GetListElementsDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserListApiFp(this.configuration).listControllerGetElements(dbInstance, encoding, getListElementsDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Insert element at the head/tail of the List data type
     * @summary 
     * @param {string} dbInstance 
     * @param {ListControllerPushElementEncodingEnum} encoding 
     * @param {PushElementToListDto} pushElementToListDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserListApi
     */
    public listControllerPushElement(dbInstance: string, encoding: ListControllerPushElementEncodingEnum, pushElementToListDto: PushElementToListDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserListApiFp(this.configuration).listControllerPushElement(dbInstance, encoding, pushElementToListDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update list element by index.
     * @summary 
     * @param {string} dbInstance 
     * @param {ListControllerUpdateElementEncodingEnum} encoding 
     * @param {SetListElementDto} setListElementDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserListApi
     */
    public listControllerUpdateElement(dbInstance: string, encoding: ListControllerUpdateElementEncodingEnum, setListElementDto: SetListElementDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserListApiFp(this.configuration).listControllerUpdateElement(dbInstance, encoding, setListElementDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListControllerCreateListEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type ListControllerCreateListEncodingEnum = typeof ListControllerCreateListEncodingEnum[keyof typeof ListControllerCreateListEncodingEnum];
/**
 * @export
 */
export const ListControllerDeleteElementEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type ListControllerDeleteElementEncodingEnum = typeof ListControllerDeleteElementEncodingEnum[keyof typeof ListControllerDeleteElementEncodingEnum];
/**
 * @export
 */
export const ListControllerGetElementEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type ListControllerGetElementEncodingEnum = typeof ListControllerGetElementEncodingEnum[keyof typeof ListControllerGetElementEncodingEnum];
/**
 * @export
 */
export const ListControllerGetElementsEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type ListControllerGetElementsEncodingEnum = typeof ListControllerGetElementsEncodingEnum[keyof typeof ListControllerGetElementsEncodingEnum];
/**
 * @export
 */
export const ListControllerPushElementEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type ListControllerPushElementEncodingEnum = typeof ListControllerPushElementEncodingEnum[keyof typeof ListControllerPushElementEncodingEnum];
/**
 * @export
 */
export const ListControllerUpdateElementEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type ListControllerUpdateElementEncodingEnum = typeof ListControllerUpdateElementEncodingEnum[keyof typeof ListControllerUpdateElementEncodingEnum];


/**
 * BrowserREJSONRLApi - axios parameter creator
 * @export
 */
export const BrowserREJSONRLApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Append item inside REJSON-RL array
         * @summary 
         * @param {string} dbInstance 
         * @param {ModifyRejsonRlArrAppendDto} modifyRejsonRlArrAppendDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejsonRlControllerArrAppend: async (dbInstance: string, modifyRejsonRlArrAppendDto: ModifyRejsonRlArrAppendDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('rejsonRlControllerArrAppend', 'dbInstance', dbInstance)
            // verify required parameter 'modifyRejsonRlArrAppendDto' is not null or undefined
            assertParamExists('rejsonRlControllerArrAppend', 'modifyRejsonRlArrAppendDto', modifyRejsonRlArrAppendDto)
            const localVarPath = `/api/databases/{dbInstance}/rejson-rl/arrappend`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyRejsonRlArrAppendDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new REJSON-RL data type
         * @summary 
         * @param {string} dbInstance 
         * @param {CreateRejsonRlWithExpireDto} createRejsonRlWithExpireDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejsonRlControllerCreateJson: async (dbInstance: string, createRejsonRlWithExpireDto: CreateRejsonRlWithExpireDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('rejsonRlControllerCreateJson', 'dbInstance', dbInstance)
            // verify required parameter 'createRejsonRlWithExpireDto' is not null or undefined
            assertParamExists('rejsonRlControllerCreateJson', 'createRejsonRlWithExpireDto', createRejsonRlWithExpireDto)
            const localVarPath = `/api/databases/{dbInstance}/rejson-rl`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRejsonRlWithExpireDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get json properties by path
         * @summary 
         * @param {string} dbInstance 
         * @param {GetRejsonRlDto} getRejsonRlDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejsonRlControllerGetJson: async (dbInstance: string, getRejsonRlDto: GetRejsonRlDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('rejsonRlControllerGetJson', 'dbInstance', dbInstance)
            // verify required parameter 'getRejsonRlDto' is not null or undefined
            assertParamExists('rejsonRlControllerGetJson', 'getRejsonRlDto', getRejsonRlDto)
            const localVarPath = `/api/databases/{dbInstance}/rejson-rl/get`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getRejsonRlDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify REJSON-RL data type by path
         * @summary 
         * @param {string} dbInstance 
         * @param {ModifyRejsonRlSetDto} modifyRejsonRlSetDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejsonRlControllerJsonSet: async (dbInstance: string, modifyRejsonRlSetDto: ModifyRejsonRlSetDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('rejsonRlControllerJsonSet', 'dbInstance', dbInstance)
            // verify required parameter 'modifyRejsonRlSetDto' is not null or undefined
            assertParamExists('rejsonRlControllerJsonSet', 'modifyRejsonRlSetDto', modifyRejsonRlSetDto)
            const localVarPath = `/api/databases/{dbInstance}/rejson-rl/set`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyRejsonRlSetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes path in the REJSON-RL
         * @summary 
         * @param {string} dbInstance 
         * @param {RemoveRejsonRlDto} removeRejsonRlDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejsonRlControllerRemove: async (dbInstance: string, removeRejsonRlDto: RemoveRejsonRlDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('rejsonRlControllerRemove', 'dbInstance', dbInstance)
            // verify required parameter 'removeRejsonRlDto' is not null or undefined
            assertParamExists('rejsonRlControllerRemove', 'removeRejsonRlDto', removeRejsonRlDto)
            const localVarPath = `/api/databases/{dbInstance}/rejson-rl`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeRejsonRlDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrowserREJSONRLApi - functional programming interface
 * @export
 */
export const BrowserREJSONRLApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrowserREJSONRLApiAxiosParamCreator(configuration)
    return {
        /**
         * Append item inside REJSON-RL array
         * @summary 
         * @param {string} dbInstance 
         * @param {ModifyRejsonRlArrAppendDto} modifyRejsonRlArrAppendDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejsonRlControllerArrAppend(dbInstance: string, modifyRejsonRlArrAppendDto: ModifyRejsonRlArrAppendDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejsonRlControllerArrAppend(dbInstance, modifyRejsonRlArrAppendDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserREJSONRLApi.rejsonRlControllerArrAppend']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create new REJSON-RL data type
         * @summary 
         * @param {string} dbInstance 
         * @param {CreateRejsonRlWithExpireDto} createRejsonRlWithExpireDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejsonRlControllerCreateJson(dbInstance: string, createRejsonRlWithExpireDto: CreateRejsonRlWithExpireDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejsonRlControllerCreateJson(dbInstance, createRejsonRlWithExpireDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserREJSONRLApi.rejsonRlControllerCreateJson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get json properties by path
         * @summary 
         * @param {string} dbInstance 
         * @param {GetRejsonRlDto} getRejsonRlDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejsonRlControllerGetJson(dbInstance: string, getRejsonRlDto: GetRejsonRlDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRejsonRlResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejsonRlControllerGetJson(dbInstance, getRejsonRlDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserREJSONRLApi.rejsonRlControllerGetJson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify REJSON-RL data type by path
         * @summary 
         * @param {string} dbInstance 
         * @param {ModifyRejsonRlSetDto} modifyRejsonRlSetDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejsonRlControllerJsonSet(dbInstance: string, modifyRejsonRlSetDto: ModifyRejsonRlSetDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejsonRlControllerJsonSet(dbInstance, modifyRejsonRlSetDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserREJSONRLApi.rejsonRlControllerJsonSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes path in the REJSON-RL
         * @summary 
         * @param {string} dbInstance 
         * @param {RemoveRejsonRlDto} removeRejsonRlDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejsonRlControllerRemove(dbInstance: string, removeRejsonRlDto: RemoveRejsonRlDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoveRejsonRlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejsonRlControllerRemove(dbInstance, removeRejsonRlDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserREJSONRLApi.rejsonRlControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BrowserREJSONRLApi - factory interface
 * @export
 */
export const BrowserREJSONRLApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrowserREJSONRLApiFp(configuration)
    return {
        /**
         * Append item inside REJSON-RL array
         * @summary 
         * @param {string} dbInstance 
         * @param {ModifyRejsonRlArrAppendDto} modifyRejsonRlArrAppendDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejsonRlControllerArrAppend(dbInstance: string, modifyRejsonRlArrAppendDto: ModifyRejsonRlArrAppendDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rejsonRlControllerArrAppend(dbInstance, modifyRejsonRlArrAppendDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new REJSON-RL data type
         * @summary 
         * @param {string} dbInstance 
         * @param {CreateRejsonRlWithExpireDto} createRejsonRlWithExpireDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejsonRlControllerCreateJson(dbInstance: string, createRejsonRlWithExpireDto: CreateRejsonRlWithExpireDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rejsonRlControllerCreateJson(dbInstance, createRejsonRlWithExpireDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get json properties by path
         * @summary 
         * @param {string} dbInstance 
         * @param {GetRejsonRlDto} getRejsonRlDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejsonRlControllerGetJson(dbInstance: string, getRejsonRlDto: GetRejsonRlDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetRejsonRlResponseDto> {
            return localVarFp.rejsonRlControllerGetJson(dbInstance, getRejsonRlDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify REJSON-RL data type by path
         * @summary 
         * @param {string} dbInstance 
         * @param {ModifyRejsonRlSetDto} modifyRejsonRlSetDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejsonRlControllerJsonSet(dbInstance: string, modifyRejsonRlSetDto: ModifyRejsonRlSetDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rejsonRlControllerJsonSet(dbInstance, modifyRejsonRlSetDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes path in the REJSON-RL
         * @summary 
         * @param {string} dbInstance 
         * @param {RemoveRejsonRlDto} removeRejsonRlDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejsonRlControllerRemove(dbInstance: string, removeRejsonRlDto: RemoveRejsonRlDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<RemoveRejsonRlResponse> {
            return localVarFp.rejsonRlControllerRemove(dbInstance, removeRejsonRlDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrowserREJSONRLApi - object-oriented interface
 * @export
 * @class BrowserREJSONRLApi
 * @extends {BaseAPI}
 */
export class BrowserREJSONRLApi extends BaseAPI {
    /**
     * Append item inside REJSON-RL array
     * @summary 
     * @param {string} dbInstance 
     * @param {ModifyRejsonRlArrAppendDto} modifyRejsonRlArrAppendDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserREJSONRLApi
     */
    public rejsonRlControllerArrAppend(dbInstance: string, modifyRejsonRlArrAppendDto: ModifyRejsonRlArrAppendDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserREJSONRLApiFp(this.configuration).rejsonRlControllerArrAppend(dbInstance, modifyRejsonRlArrAppendDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new REJSON-RL data type
     * @summary 
     * @param {string} dbInstance 
     * @param {CreateRejsonRlWithExpireDto} createRejsonRlWithExpireDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserREJSONRLApi
     */
    public rejsonRlControllerCreateJson(dbInstance: string, createRejsonRlWithExpireDto: CreateRejsonRlWithExpireDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserREJSONRLApiFp(this.configuration).rejsonRlControllerCreateJson(dbInstance, createRejsonRlWithExpireDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get json properties by path
     * @summary 
     * @param {string} dbInstance 
     * @param {GetRejsonRlDto} getRejsonRlDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserREJSONRLApi
     */
    public rejsonRlControllerGetJson(dbInstance: string, getRejsonRlDto: GetRejsonRlDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserREJSONRLApiFp(this.configuration).rejsonRlControllerGetJson(dbInstance, getRejsonRlDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify REJSON-RL data type by path
     * @summary 
     * @param {string} dbInstance 
     * @param {ModifyRejsonRlSetDto} modifyRejsonRlSetDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserREJSONRLApi
     */
    public rejsonRlControllerJsonSet(dbInstance: string, modifyRejsonRlSetDto: ModifyRejsonRlSetDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserREJSONRLApiFp(this.configuration).rejsonRlControllerJsonSet(dbInstance, modifyRejsonRlSetDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes path in the REJSON-RL
     * @summary 
     * @param {string} dbInstance 
     * @param {RemoveRejsonRlDto} removeRejsonRlDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserREJSONRLApi
     */
    public rejsonRlControllerRemove(dbInstance: string, removeRejsonRlDto: RemoveRejsonRlDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserREJSONRLApiFp(this.configuration).rejsonRlControllerRemove(dbInstance, removeRejsonRlDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BrowserRediSearchApi - axios parameter creator
 * @export
 */
export const BrowserRediSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create redisearch index
         * @summary 
         * @param {string} dbInstance 
         * @param {CreateRedisearchIndexDto} createRedisearchIndexDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redisearchControllerCreateIndex: async (dbInstance: string, createRedisearchIndexDto: CreateRedisearchIndexDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('redisearchControllerCreateIndex', 'dbInstance', dbInstance)
            // verify required parameter 'createRedisearchIndexDto' is not null or undefined
            assertParamExists('redisearchControllerCreateIndex', 'createRedisearchIndexDto', createRedisearchIndexDto)
            const localVarPath = `/api/databases/{dbInstance}/redisearch`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRedisearchIndexDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get index info
         * @summary 
         * @param {string} dbInstance 
         * @param {IndexInfoRequestBodyDto} indexInfoRequestBodyDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redisearchControllerInfo: async (dbInstance: string, indexInfoRequestBodyDto: IndexInfoRequestBodyDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('redisearchControllerInfo', 'dbInstance', dbInstance)
            // verify required parameter 'indexInfoRequestBodyDto' is not null or undefined
            assertParamExists('redisearchControllerInfo', 'indexInfoRequestBodyDto', indexInfoRequestBodyDto)
            const localVarPath = `/api/databases/{dbInstance}/redisearch/info`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(indexInfoRequestBodyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of available indexes
         * @summary 
         * @param {string} dbInstance 
         * @param {RedisearchControllerListEncodingEnum} encoding 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redisearchControllerList: async (dbInstance: string, encoding: RedisearchControllerListEncodingEnum, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('redisearchControllerList', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('redisearchControllerList', 'encoding', encoding)
            const localVarPath = `/api/databases/{dbInstance}/redisearch`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for keys in index
         * @summary 
         * @param {string} dbInstance 
         * @param {RedisearchControllerSearchEncodingEnum} encoding 
         * @param {SearchRedisearchDto} searchRedisearchDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redisearchControllerSearch: async (dbInstance: string, encoding: RedisearchControllerSearchEncodingEnum, searchRedisearchDto: SearchRedisearchDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('redisearchControllerSearch', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('redisearchControllerSearch', 'encoding', encoding)
            // verify required parameter 'searchRedisearchDto' is not null or undefined
            assertParamExists('redisearchControllerSearch', 'searchRedisearchDto', searchRedisearchDto)
            const localVarPath = `/api/databases/{dbInstance}/redisearch/search`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchRedisearchDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrowserRediSearchApi - functional programming interface
 * @export
 */
export const BrowserRediSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrowserRediSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Create redisearch index
         * @summary 
         * @param {string} dbInstance 
         * @param {CreateRedisearchIndexDto} createRedisearchIndexDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redisearchControllerCreateIndex(dbInstance: string, createRedisearchIndexDto: CreateRedisearchIndexDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redisearchControllerCreateIndex(dbInstance, createRedisearchIndexDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserRediSearchApi.redisearchControllerCreateIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get index info
         * @summary 
         * @param {string} dbInstance 
         * @param {IndexInfoRequestBodyDto} indexInfoRequestBodyDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redisearchControllerInfo(dbInstance: string, indexInfoRequestBodyDto: IndexInfoRequestBodyDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IndexInfoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redisearchControllerInfo(dbInstance, indexInfoRequestBodyDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserRediSearchApi.redisearchControllerInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of available indexes
         * @summary 
         * @param {string} dbInstance 
         * @param {RedisearchControllerListEncodingEnum} encoding 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redisearchControllerList(dbInstance: string, encoding: RedisearchControllerListEncodingEnum, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListRedisearchIndexesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redisearchControllerList(dbInstance, encoding, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserRediSearchApi.redisearchControllerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for keys in index
         * @summary 
         * @param {string} dbInstance 
         * @param {RedisearchControllerSearchEncodingEnum} encoding 
         * @param {SearchRedisearchDto} searchRedisearchDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redisearchControllerSearch(dbInstance: string, encoding: RedisearchControllerSearchEncodingEnum, searchRedisearchDto: SearchRedisearchDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetKeysWithDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redisearchControllerSearch(dbInstance, encoding, searchRedisearchDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserRediSearchApi.redisearchControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BrowserRediSearchApi - factory interface
 * @export
 */
export const BrowserRediSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrowserRediSearchApiFp(configuration)
    return {
        /**
         * Create redisearch index
         * @summary 
         * @param {string} dbInstance 
         * @param {CreateRedisearchIndexDto} createRedisearchIndexDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redisearchControllerCreateIndex(dbInstance: string, createRedisearchIndexDto: CreateRedisearchIndexDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.redisearchControllerCreateIndex(dbInstance, createRedisearchIndexDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get index info
         * @summary 
         * @param {string} dbInstance 
         * @param {IndexInfoRequestBodyDto} indexInfoRequestBodyDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redisearchControllerInfo(dbInstance: string, indexInfoRequestBodyDto: IndexInfoRequestBodyDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<IndexInfoDto> {
            return localVarFp.redisearchControllerInfo(dbInstance, indexInfoRequestBodyDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of available indexes
         * @summary 
         * @param {string} dbInstance 
         * @param {RedisearchControllerListEncodingEnum} encoding 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redisearchControllerList(dbInstance: string, encoding: RedisearchControllerListEncodingEnum, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListRedisearchIndexesResponse> {
            return localVarFp.redisearchControllerList(dbInstance, encoding, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for keys in index
         * @summary 
         * @param {string} dbInstance 
         * @param {RedisearchControllerSearchEncodingEnum} encoding 
         * @param {SearchRedisearchDto} searchRedisearchDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redisearchControllerSearch(dbInstance: string, encoding: RedisearchControllerSearchEncodingEnum, searchRedisearchDto: SearchRedisearchDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetKeysWithDetailsResponse> {
            return localVarFp.redisearchControllerSearch(dbInstance, encoding, searchRedisearchDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrowserRediSearchApi - object-oriented interface
 * @export
 * @class BrowserRediSearchApi
 * @extends {BaseAPI}
 */
export class BrowserRediSearchApi extends BaseAPI {
    /**
     * Create redisearch index
     * @summary 
     * @param {string} dbInstance 
     * @param {CreateRedisearchIndexDto} createRedisearchIndexDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserRediSearchApi
     */
    public redisearchControllerCreateIndex(dbInstance: string, createRedisearchIndexDto: CreateRedisearchIndexDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserRediSearchApiFp(this.configuration).redisearchControllerCreateIndex(dbInstance, createRedisearchIndexDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get index info
     * @summary 
     * @param {string} dbInstance 
     * @param {IndexInfoRequestBodyDto} indexInfoRequestBodyDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserRediSearchApi
     */
    public redisearchControllerInfo(dbInstance: string, indexInfoRequestBodyDto: IndexInfoRequestBodyDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserRediSearchApiFp(this.configuration).redisearchControllerInfo(dbInstance, indexInfoRequestBodyDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of available indexes
     * @summary 
     * @param {string} dbInstance 
     * @param {RedisearchControllerListEncodingEnum} encoding 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserRediSearchApi
     */
    public redisearchControllerList(dbInstance: string, encoding: RedisearchControllerListEncodingEnum, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserRediSearchApiFp(this.configuration).redisearchControllerList(dbInstance, encoding, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for keys in index
     * @summary 
     * @param {string} dbInstance 
     * @param {RedisearchControllerSearchEncodingEnum} encoding 
     * @param {SearchRedisearchDto} searchRedisearchDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserRediSearchApi
     */
    public redisearchControllerSearch(dbInstance: string, encoding: RedisearchControllerSearchEncodingEnum, searchRedisearchDto: SearchRedisearchDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserRediSearchApiFp(this.configuration).redisearchControllerSearch(dbInstance, encoding, searchRedisearchDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RedisearchControllerListEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type RedisearchControllerListEncodingEnum = typeof RedisearchControllerListEncodingEnum[keyof typeof RedisearchControllerListEncodingEnum];
/**
 * @export
 */
export const RedisearchControllerSearchEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type RedisearchControllerSearchEncodingEnum = typeof RedisearchControllerSearchEncodingEnum[keyof typeof RedisearchControllerSearchEncodingEnum];


/**
 * BrowserSetApi - axios parameter creator
 * @export
 */
export const BrowserSetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add the specified members to the Set stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {SetControllerAddMembersEncodingEnum} encoding 
         * @param {AddMembersToSetDto} addMembersToSetDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setControllerAddMembers: async (dbInstance: string, encoding: SetControllerAddMembersEncodingEnum, addMembersToSetDto: AddMembersToSetDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('setControllerAddMembers', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('setControllerAddMembers', 'encoding', encoding)
            // verify required parameter 'addMembersToSetDto' is not null or undefined
            assertParamExists('setControllerAddMembers', 'addMembersToSetDto', addMembersToSetDto)
            const localVarPath = `/api/databases/{dbInstance}/set`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addMembersToSetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set key to hold Set data type
         * @summary 
         * @param {string} dbInstance 
         * @param {SetControllerCreateSetEncodingEnum} encoding 
         * @param {CreateSetWithExpireDto} createSetWithExpireDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setControllerCreateSet: async (dbInstance: string, encoding: SetControllerCreateSetEncodingEnum, createSetWithExpireDto: CreateSetWithExpireDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('setControllerCreateSet', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('setControllerCreateSet', 'encoding', encoding)
            // verify required parameter 'createSetWithExpireDto' is not null or undefined
            assertParamExists('setControllerCreateSet', 'createSetWithExpireDto', createSetWithExpireDto)
            const localVarPath = `/api/databases/{dbInstance}/set`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSetWithExpireDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the specified members from the Set stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {SetControllerDeleteMembersEncodingEnum} encoding 
         * @param {DeleteMembersFromSetDto} deleteMembersFromSetDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setControllerDeleteMembers: async (dbInstance: string, encoding: SetControllerDeleteMembersEncodingEnum, deleteMembersFromSetDto: DeleteMembersFromSetDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('setControllerDeleteMembers', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('setControllerDeleteMembers', 'encoding', encoding)
            // verify required parameter 'deleteMembersFromSetDto' is not null or undefined
            assertParamExists('setControllerDeleteMembers', 'deleteMembersFromSetDto', deleteMembersFromSetDto)
            const localVarPath = `/api/databases/{dbInstance}/set/members`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteMembersFromSetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get specified members of the set stored at key by cursor position
         * @summary 
         * @param {string} dbInstance 
         * @param {SetControllerGetMembersEncodingEnum} encoding 
         * @param {GetSetMembersDto} getSetMembersDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setControllerGetMembers: async (dbInstance: string, encoding: SetControllerGetMembersEncodingEnum, getSetMembersDto: GetSetMembersDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('setControllerGetMembers', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('setControllerGetMembers', 'encoding', encoding)
            // verify required parameter 'getSetMembersDto' is not null or undefined
            assertParamExists('setControllerGetMembers', 'getSetMembersDto', getSetMembersDto)
            const localVarPath = `/api/databases/{dbInstance}/set/get-members`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSetMembersDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrowserSetApi - functional programming interface
 * @export
 */
export const BrowserSetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrowserSetApiAxiosParamCreator(configuration)
    return {
        /**
         * Add the specified members to the Set stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {SetControllerAddMembersEncodingEnum} encoding 
         * @param {AddMembersToSetDto} addMembersToSetDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setControllerAddMembers(dbInstance: string, encoding: SetControllerAddMembersEncodingEnum, addMembersToSetDto: AddMembersToSetDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setControllerAddMembers(dbInstance, encoding, addMembersToSetDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserSetApi.setControllerAddMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set key to hold Set data type
         * @summary 
         * @param {string} dbInstance 
         * @param {SetControllerCreateSetEncodingEnum} encoding 
         * @param {CreateSetWithExpireDto} createSetWithExpireDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setControllerCreateSet(dbInstance: string, encoding: SetControllerCreateSetEncodingEnum, createSetWithExpireDto: CreateSetWithExpireDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setControllerCreateSet(dbInstance, encoding, createSetWithExpireDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserSetApi.setControllerCreateSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove the specified members from the Set stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {SetControllerDeleteMembersEncodingEnum} encoding 
         * @param {DeleteMembersFromSetDto} deleteMembersFromSetDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setControllerDeleteMembers(dbInstance: string, encoding: SetControllerDeleteMembersEncodingEnum, deleteMembersFromSetDto: DeleteMembersFromSetDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteMembersFromSetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setControllerDeleteMembers(dbInstance, encoding, deleteMembersFromSetDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserSetApi.setControllerDeleteMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get specified members of the set stored at key by cursor position
         * @summary 
         * @param {string} dbInstance 
         * @param {SetControllerGetMembersEncodingEnum} encoding 
         * @param {GetSetMembersDto} getSetMembersDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setControllerGetMembers(dbInstance: string, encoding: SetControllerGetMembersEncodingEnum, getSetMembersDto: GetSetMembersDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSetMembersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setControllerGetMembers(dbInstance, encoding, getSetMembersDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserSetApi.setControllerGetMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BrowserSetApi - factory interface
 * @export
 */
export const BrowserSetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrowserSetApiFp(configuration)
    return {
        /**
         * Add the specified members to the Set stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {SetControllerAddMembersEncodingEnum} encoding 
         * @param {AddMembersToSetDto} addMembersToSetDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setControllerAddMembers(dbInstance: string, encoding: SetControllerAddMembersEncodingEnum, addMembersToSetDto: AddMembersToSetDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setControllerAddMembers(dbInstance, encoding, addMembersToSetDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Set key to hold Set data type
         * @summary 
         * @param {string} dbInstance 
         * @param {SetControllerCreateSetEncodingEnum} encoding 
         * @param {CreateSetWithExpireDto} createSetWithExpireDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setControllerCreateSet(dbInstance: string, encoding: SetControllerCreateSetEncodingEnum, createSetWithExpireDto: CreateSetWithExpireDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setControllerCreateSet(dbInstance, encoding, createSetWithExpireDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove the specified members from the Set stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {SetControllerDeleteMembersEncodingEnum} encoding 
         * @param {DeleteMembersFromSetDto} deleteMembersFromSetDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setControllerDeleteMembers(dbInstance: string, encoding: SetControllerDeleteMembersEncodingEnum, deleteMembersFromSetDto: DeleteMembersFromSetDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteMembersFromSetResponse> {
            return localVarFp.setControllerDeleteMembers(dbInstance, encoding, deleteMembersFromSetDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get specified members of the set stored at key by cursor position
         * @summary 
         * @param {string} dbInstance 
         * @param {SetControllerGetMembersEncodingEnum} encoding 
         * @param {GetSetMembersDto} getSetMembersDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setControllerGetMembers(dbInstance: string, encoding: SetControllerGetMembersEncodingEnum, getSetMembersDto: GetSetMembersDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetSetMembersResponse> {
            return localVarFp.setControllerGetMembers(dbInstance, encoding, getSetMembersDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrowserSetApi - object-oriented interface
 * @export
 * @class BrowserSetApi
 * @extends {BaseAPI}
 */
export class BrowserSetApi extends BaseAPI {
    /**
     * Add the specified members to the Set stored at key
     * @summary 
     * @param {string} dbInstance 
     * @param {SetControllerAddMembersEncodingEnum} encoding 
     * @param {AddMembersToSetDto} addMembersToSetDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserSetApi
     */
    public setControllerAddMembers(dbInstance: string, encoding: SetControllerAddMembersEncodingEnum, addMembersToSetDto: AddMembersToSetDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserSetApiFp(this.configuration).setControllerAddMembers(dbInstance, encoding, addMembersToSetDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set key to hold Set data type
     * @summary 
     * @param {string} dbInstance 
     * @param {SetControllerCreateSetEncodingEnum} encoding 
     * @param {CreateSetWithExpireDto} createSetWithExpireDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserSetApi
     */
    public setControllerCreateSet(dbInstance: string, encoding: SetControllerCreateSetEncodingEnum, createSetWithExpireDto: CreateSetWithExpireDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserSetApiFp(this.configuration).setControllerCreateSet(dbInstance, encoding, createSetWithExpireDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove the specified members from the Set stored at key
     * @summary 
     * @param {string} dbInstance 
     * @param {SetControllerDeleteMembersEncodingEnum} encoding 
     * @param {DeleteMembersFromSetDto} deleteMembersFromSetDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserSetApi
     */
    public setControllerDeleteMembers(dbInstance: string, encoding: SetControllerDeleteMembersEncodingEnum, deleteMembersFromSetDto: DeleteMembersFromSetDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserSetApiFp(this.configuration).setControllerDeleteMembers(dbInstance, encoding, deleteMembersFromSetDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get specified members of the set stored at key by cursor position
     * @summary 
     * @param {string} dbInstance 
     * @param {SetControllerGetMembersEncodingEnum} encoding 
     * @param {GetSetMembersDto} getSetMembersDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserSetApi
     */
    public setControllerGetMembers(dbInstance: string, encoding: SetControllerGetMembersEncodingEnum, getSetMembersDto: GetSetMembersDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserSetApiFp(this.configuration).setControllerGetMembers(dbInstance, encoding, getSetMembersDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SetControllerAddMembersEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type SetControllerAddMembersEncodingEnum = typeof SetControllerAddMembersEncodingEnum[keyof typeof SetControllerAddMembersEncodingEnum];
/**
 * @export
 */
export const SetControllerCreateSetEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type SetControllerCreateSetEncodingEnum = typeof SetControllerCreateSetEncodingEnum[keyof typeof SetControllerCreateSetEncodingEnum];
/**
 * @export
 */
export const SetControllerDeleteMembersEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type SetControllerDeleteMembersEncodingEnum = typeof SetControllerDeleteMembersEncodingEnum[keyof typeof SetControllerDeleteMembersEncodingEnum];
/**
 * @export
 */
export const SetControllerGetMembersEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type SetControllerGetMembersEncodingEnum = typeof SetControllerGetMembersEncodingEnum[keyof typeof SetControllerGetMembersEncodingEnum];


/**
 * BrowserStreamsApi - axios parameter creator
 * @export
 */
export const BrowserStreamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Ack pending entries
         * @summary 
         * @param {string} dbInstance 
         * @param {AckPendingEntriesDto} ackPendingEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerControllerAckPendingEntries: async (dbInstance: string, ackPendingEntriesDto: AckPendingEntriesDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('consumerControllerAckPendingEntries', 'dbInstance', dbInstance)
            // verify required parameter 'ackPendingEntriesDto' is not null or undefined
            assertParamExists('consumerControllerAckPendingEntries', 'ackPendingEntriesDto', ackPendingEntriesDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/consumer-groups/consumers/pending-messages/ack`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ackPendingEntriesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Claim pending entries
         * @summary 
         * @param {string} dbInstance 
         * @param {ClaimPendingEntryDto} claimPendingEntryDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerControllerClaimPendingEntries: async (dbInstance: string, claimPendingEntryDto: ClaimPendingEntryDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('consumerControllerClaimPendingEntries', 'dbInstance', dbInstance)
            // verify required parameter 'claimPendingEntryDto' is not null or undefined
            assertParamExists('consumerControllerClaimPendingEntries', 'claimPendingEntryDto', claimPendingEntryDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/consumer-groups/consumers/pending-messages/claim`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(claimPendingEntryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Consumer(s) from the Consumer Group
         * @summary 
         * @param {string} dbInstance 
         * @param {DeleteConsumersDto} deleteConsumersDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerControllerDeleteConsumers: async (dbInstance: string, deleteConsumersDto: DeleteConsumersDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('consumerControllerDeleteConsumers', 'dbInstance', dbInstance)
            // verify required parameter 'deleteConsumersDto' is not null or undefined
            assertParamExists('consumerControllerDeleteConsumers', 'deleteConsumersDto', deleteConsumersDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/consumer-groups/consumers`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteConsumersDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get consumers list in the group
         * @summary 
         * @param {string} dbInstance 
         * @param {ConsumerControllerGetConsumersEncodingEnum} encoding 
         * @param {GetConsumersDto} getConsumersDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerControllerGetConsumers: async (dbInstance: string, encoding: ConsumerControllerGetConsumersEncodingEnum, getConsumersDto: GetConsumersDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('consumerControllerGetConsumers', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('consumerControllerGetConsumers', 'encoding', encoding)
            // verify required parameter 'getConsumersDto' is not null or undefined
            assertParamExists('consumerControllerGetConsumers', 'getConsumersDto', getConsumersDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/consumer-groups/consumers/get`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getConsumersDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pending entries list
         * @summary 
         * @param {string} dbInstance 
         * @param {ConsumerControllerGetPendingEntriesEncodingEnum} encoding 
         * @param {GetPendingEntriesDto} getPendingEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerControllerGetPendingEntries: async (dbInstance: string, encoding: ConsumerControllerGetPendingEntriesEncodingEnum, getPendingEntriesDto: GetPendingEntriesDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('consumerControllerGetPendingEntries', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('consumerControllerGetPendingEntries', 'encoding', encoding)
            // verify required parameter 'getPendingEntriesDto' is not null or undefined
            assertParamExists('consumerControllerGetPendingEntries', 'getPendingEntriesDto', getPendingEntriesDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/consumer-groups/consumers/pending-messages/get`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPendingEntriesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create stream consumer group
         * @summary 
         * @param {string} dbInstance 
         * @param {CreateConsumerGroupsDto} createConsumerGroupsDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerGroupControllerCreateGroups: async (dbInstance: string, createConsumerGroupsDto: CreateConsumerGroupsDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('consumerGroupControllerCreateGroups', 'dbInstance', dbInstance)
            // verify required parameter 'createConsumerGroupsDto' is not null or undefined
            assertParamExists('consumerGroupControllerCreateGroups', 'createConsumerGroupsDto', createConsumerGroupsDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/consumer-groups`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createConsumerGroupsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Consumer Group
         * @summary 
         * @param {string} dbInstance 
         * @param {DeleteConsumerGroupsDto} deleteConsumerGroupsDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerGroupControllerDeleteGroup: async (dbInstance: string, deleteConsumerGroupsDto: DeleteConsumerGroupsDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('consumerGroupControllerDeleteGroup', 'dbInstance', dbInstance)
            // verify required parameter 'deleteConsumerGroupsDto' is not null or undefined
            assertParamExists('consumerGroupControllerDeleteGroup', 'deleteConsumerGroupsDto', deleteConsumerGroupsDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/consumer-groups`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteConsumerGroupsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get consumer groups list
         * @summary 
         * @param {string} dbInstance 
         * @param {ConsumerGroupControllerGetGroupsEncodingEnum} encoding 
         * @param {KeyDto} keyDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerGroupControllerGetGroups: async (dbInstance: string, encoding: ConsumerGroupControllerGetGroupsEncodingEnum, keyDto: KeyDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('consumerGroupControllerGetGroups', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('consumerGroupControllerGetGroups', 'encoding', encoding)
            // verify required parameter 'keyDto' is not null or undefined
            assertParamExists('consumerGroupControllerGetGroups', 'keyDto', keyDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/consumer-groups/get`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify last delivered ID of the Consumer Group
         * @summary 
         * @param {string} dbInstance 
         * @param {UpdateConsumerGroupDto} updateConsumerGroupDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerGroupControllerUpdateGroup: async (dbInstance: string, updateConsumerGroupDto: UpdateConsumerGroupDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('consumerGroupControllerUpdateGroup', 'dbInstance', dbInstance)
            // verify required parameter 'updateConsumerGroupDto' is not null or undefined
            assertParamExists('consumerGroupControllerUpdateGroup', 'updateConsumerGroupDto', updateConsumerGroupDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/consumer-groups`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateConsumerGroupDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add entries to the stream
         * @summary 
         * @param {string} dbInstance 
         * @param {StreamControllerAddEntriesEncodingEnum} encoding 
         * @param {AddStreamEntriesDto} addStreamEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamControllerAddEntries: async (dbInstance: string, encoding: StreamControllerAddEntriesEncodingEnum, addStreamEntriesDto: AddStreamEntriesDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('streamControllerAddEntries', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('streamControllerAddEntries', 'encoding', encoding)
            // verify required parameter 'addStreamEntriesDto' is not null or undefined
            assertParamExists('streamControllerAddEntries', 'addStreamEntriesDto', addStreamEntriesDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/entries`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addStreamEntriesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create stream
         * @summary 
         * @param {string} dbInstance 
         * @param {CreateStreamDto} createStreamDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamControllerCreateStream: async (dbInstance: string, createStreamDto: CreateStreamDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('streamControllerCreateStream', 'dbInstance', dbInstance)
            // verify required parameter 'createStreamDto' is not null or undefined
            assertParamExists('streamControllerCreateStream', 'createStreamDto', createStreamDto)
            const localVarPath = `/api/databases/{dbInstance}/streams`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStreamDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the specified entries from the Stream stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {DeleteStreamEntriesDto} deleteStreamEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamControllerDeleteEntries: async (dbInstance: string, deleteStreamEntriesDto: DeleteStreamEntriesDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('streamControllerDeleteEntries', 'dbInstance', dbInstance)
            // verify required parameter 'deleteStreamEntriesDto' is not null or undefined
            assertParamExists('streamControllerDeleteEntries', 'deleteStreamEntriesDto', deleteStreamEntriesDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/entries`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteStreamEntriesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stream entries
         * @summary 
         * @param {string} dbInstance 
         * @param {StreamControllerGetEntriesEncodingEnum} encoding 
         * @param {GetStreamEntriesDto} getStreamEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamControllerGetEntries: async (dbInstance: string, encoding: StreamControllerGetEntriesEncodingEnum, getStreamEntriesDto: GetStreamEntriesDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('streamControllerGetEntries', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('streamControllerGetEntries', 'encoding', encoding)
            // verify required parameter 'getStreamEntriesDto' is not null or undefined
            assertParamExists('streamControllerGetEntries', 'getStreamEntriesDto', getStreamEntriesDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/entries/get`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getStreamEntriesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrowserStreamsApi - functional programming interface
 * @export
 */
export const BrowserStreamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrowserStreamsApiAxiosParamCreator(configuration)
    return {
        /**
         * Ack pending entries
         * @summary 
         * @param {string} dbInstance 
         * @param {AckPendingEntriesDto} ackPendingEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumerControllerAckPendingEntries(dbInstance: string, ackPendingEntriesDto: AckPendingEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AckPendingEntriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumerControllerAckPendingEntries(dbInstance, ackPendingEntriesDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.consumerControllerAckPendingEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Claim pending entries
         * @summary 
         * @param {string} dbInstance 
         * @param {ClaimPendingEntryDto} claimPendingEntryDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumerControllerClaimPendingEntries(dbInstance: string, claimPendingEntryDto: ClaimPendingEntryDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClaimPendingEntriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumerControllerClaimPendingEntries(dbInstance, claimPendingEntryDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.consumerControllerClaimPendingEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Consumer(s) from the Consumer Group
         * @summary 
         * @param {string} dbInstance 
         * @param {DeleteConsumersDto} deleteConsumersDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumerControllerDeleteConsumers(dbInstance: string, deleteConsumersDto: DeleteConsumersDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumerControllerDeleteConsumers(dbInstance, deleteConsumersDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.consumerControllerDeleteConsumers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get consumers list in the group
         * @summary 
         * @param {string} dbInstance 
         * @param {ConsumerControllerGetConsumersEncodingEnum} encoding 
         * @param {GetConsumersDto} getConsumersDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumerControllerGetConsumers(dbInstance: string, encoding: ConsumerControllerGetConsumersEncodingEnum, getConsumersDto: GetConsumersDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConsumerDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumerControllerGetConsumers(dbInstance, encoding, getConsumersDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.consumerControllerGetConsumers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pending entries list
         * @summary 
         * @param {string} dbInstance 
         * @param {ConsumerControllerGetPendingEntriesEncodingEnum} encoding 
         * @param {GetPendingEntriesDto} getPendingEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumerControllerGetPendingEntries(dbInstance: string, encoding: ConsumerControllerGetPendingEntriesEncodingEnum, getPendingEntriesDto: GetPendingEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PendingEntryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumerControllerGetPendingEntries(dbInstance, encoding, getPendingEntriesDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.consumerControllerGetPendingEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create stream consumer group
         * @summary 
         * @param {string} dbInstance 
         * @param {CreateConsumerGroupsDto} createConsumerGroupsDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumerGroupControllerCreateGroups(dbInstance: string, createConsumerGroupsDto: CreateConsumerGroupsDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumerGroupControllerCreateGroups(dbInstance, createConsumerGroupsDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.consumerGroupControllerCreateGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Consumer Group
         * @summary 
         * @param {string} dbInstance 
         * @param {DeleteConsumerGroupsDto} deleteConsumerGroupsDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumerGroupControllerDeleteGroup(dbInstance: string, deleteConsumerGroupsDto: DeleteConsumerGroupsDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteConsumerGroupsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumerGroupControllerDeleteGroup(dbInstance, deleteConsumerGroupsDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.consumerGroupControllerDeleteGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get consumer groups list
         * @summary 
         * @param {string} dbInstance 
         * @param {ConsumerGroupControllerGetGroupsEncodingEnum} encoding 
         * @param {KeyDto} keyDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumerGroupControllerGetGroups(dbInstance: string, encoding: ConsumerGroupControllerGetGroupsEncodingEnum, keyDto: KeyDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConsumerGroupDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumerGroupControllerGetGroups(dbInstance, encoding, keyDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.consumerGroupControllerGetGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify last delivered ID of the Consumer Group
         * @summary 
         * @param {string} dbInstance 
         * @param {UpdateConsumerGroupDto} updateConsumerGroupDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumerGroupControllerUpdateGroup(dbInstance: string, updateConsumerGroupDto: UpdateConsumerGroupDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumerGroupControllerUpdateGroup(dbInstance, updateConsumerGroupDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.consumerGroupControllerUpdateGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add entries to the stream
         * @summary 
         * @param {string} dbInstance 
         * @param {StreamControllerAddEntriesEncodingEnum} encoding 
         * @param {AddStreamEntriesDto} addStreamEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamControllerAddEntries(dbInstance: string, encoding: StreamControllerAddEntriesEncodingEnum, addStreamEntriesDto: AddStreamEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddStreamEntriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamControllerAddEntries(dbInstance, encoding, addStreamEntriesDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.streamControllerAddEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create stream
         * @summary 
         * @param {string} dbInstance 
         * @param {CreateStreamDto} createStreamDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamControllerCreateStream(dbInstance: string, createStreamDto: CreateStreamDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamControllerCreateStream(dbInstance, createStreamDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.streamControllerCreateStream']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove the specified entries from the Stream stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {DeleteStreamEntriesDto} deleteStreamEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamControllerDeleteEntries(dbInstance: string, deleteStreamEntriesDto: DeleteStreamEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteStreamEntriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamControllerDeleteEntries(dbInstance, deleteStreamEntriesDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.streamControllerDeleteEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get stream entries
         * @summary 
         * @param {string} dbInstance 
         * @param {StreamControllerGetEntriesEncodingEnum} encoding 
         * @param {GetStreamEntriesDto} getStreamEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamControllerGetEntries(dbInstance: string, encoding: StreamControllerGetEntriesEncodingEnum, getStreamEntriesDto: GetStreamEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStreamEntriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamControllerGetEntries(dbInstance, encoding, getStreamEntriesDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.streamControllerGetEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BrowserStreamsApi - factory interface
 * @export
 */
export const BrowserStreamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrowserStreamsApiFp(configuration)
    return {
        /**
         * Ack pending entries
         * @summary 
         * @param {string} dbInstance 
         * @param {AckPendingEntriesDto} ackPendingEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerControllerAckPendingEntries(dbInstance: string, ackPendingEntriesDto: AckPendingEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<AckPendingEntriesResponse> {
            return localVarFp.consumerControllerAckPendingEntries(dbInstance, ackPendingEntriesDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Claim pending entries
         * @summary 
         * @param {string} dbInstance 
         * @param {ClaimPendingEntryDto} claimPendingEntryDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerControllerClaimPendingEntries(dbInstance: string, claimPendingEntryDto: ClaimPendingEntryDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<ClaimPendingEntriesResponse> {
            return localVarFp.consumerControllerClaimPendingEntries(dbInstance, claimPendingEntryDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Consumer(s) from the Consumer Group
         * @summary 
         * @param {string} dbInstance 
         * @param {DeleteConsumersDto} deleteConsumersDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerControllerDeleteConsumers(dbInstance: string, deleteConsumersDto: DeleteConsumersDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.consumerControllerDeleteConsumers(dbInstance, deleteConsumersDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get consumers list in the group
         * @summary 
         * @param {string} dbInstance 
         * @param {ConsumerControllerGetConsumersEncodingEnum} encoding 
         * @param {GetConsumersDto} getConsumersDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerControllerGetConsumers(dbInstance: string, encoding: ConsumerControllerGetConsumersEncodingEnum, getConsumersDto: GetConsumersDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ConsumerDto>> {
            return localVarFp.consumerControllerGetConsumers(dbInstance, encoding, getConsumersDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pending entries list
         * @summary 
         * @param {string} dbInstance 
         * @param {ConsumerControllerGetPendingEntriesEncodingEnum} encoding 
         * @param {GetPendingEntriesDto} getPendingEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerControllerGetPendingEntries(dbInstance: string, encoding: ConsumerControllerGetPendingEntriesEncodingEnum, getPendingEntriesDto: GetPendingEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<PendingEntryDto>> {
            return localVarFp.consumerControllerGetPendingEntries(dbInstance, encoding, getPendingEntriesDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Create stream consumer group
         * @summary 
         * @param {string} dbInstance 
         * @param {CreateConsumerGroupsDto} createConsumerGroupsDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerGroupControllerCreateGroups(dbInstance: string, createConsumerGroupsDto: CreateConsumerGroupsDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.consumerGroupControllerCreateGroups(dbInstance, createConsumerGroupsDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Consumer Group
         * @summary 
         * @param {string} dbInstance 
         * @param {DeleteConsumerGroupsDto} deleteConsumerGroupsDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerGroupControllerDeleteGroup(dbInstance: string, deleteConsumerGroupsDto: DeleteConsumerGroupsDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteConsumerGroupsResponse> {
            return localVarFp.consumerGroupControllerDeleteGroup(dbInstance, deleteConsumerGroupsDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get consumer groups list
         * @summary 
         * @param {string} dbInstance 
         * @param {ConsumerGroupControllerGetGroupsEncodingEnum} encoding 
         * @param {KeyDto} keyDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerGroupControllerGetGroups(dbInstance: string, encoding: ConsumerGroupControllerGetGroupsEncodingEnum, keyDto: KeyDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ConsumerGroupDto>> {
            return localVarFp.consumerGroupControllerGetGroups(dbInstance, encoding, keyDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify last delivered ID of the Consumer Group
         * @summary 
         * @param {string} dbInstance 
         * @param {UpdateConsumerGroupDto} updateConsumerGroupDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerGroupControllerUpdateGroup(dbInstance: string, updateConsumerGroupDto: UpdateConsumerGroupDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.consumerGroupControllerUpdateGroup(dbInstance, updateConsumerGroupDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Add entries to the stream
         * @summary 
         * @param {string} dbInstance 
         * @param {StreamControllerAddEntriesEncodingEnum} encoding 
         * @param {AddStreamEntriesDto} addStreamEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamControllerAddEntries(dbInstance: string, encoding: StreamControllerAddEntriesEncodingEnum, addStreamEntriesDto: AddStreamEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<AddStreamEntriesResponse> {
            return localVarFp.streamControllerAddEntries(dbInstance, encoding, addStreamEntriesDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Create stream
         * @summary 
         * @param {string} dbInstance 
         * @param {CreateStreamDto} createStreamDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamControllerCreateStream(dbInstance: string, createStreamDto: CreateStreamDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.streamControllerCreateStream(dbInstance, createStreamDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove the specified entries from the Stream stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {DeleteStreamEntriesDto} deleteStreamEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamControllerDeleteEntries(dbInstance: string, deleteStreamEntriesDto: DeleteStreamEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteStreamEntriesResponse> {
            return localVarFp.streamControllerDeleteEntries(dbInstance, deleteStreamEntriesDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get stream entries
         * @summary 
         * @param {string} dbInstance 
         * @param {StreamControllerGetEntriesEncodingEnum} encoding 
         * @param {GetStreamEntriesDto} getStreamEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamControllerGetEntries(dbInstance: string, encoding: StreamControllerGetEntriesEncodingEnum, getStreamEntriesDto: GetStreamEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetStreamEntriesResponse> {
            return localVarFp.streamControllerGetEntries(dbInstance, encoding, getStreamEntriesDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrowserStreamsApi - object-oriented interface
 * @export
 * @class BrowserStreamsApi
 * @extends {BaseAPI}
 */
export class BrowserStreamsApi extends BaseAPI {
    /**
     * Ack pending entries
     * @summary 
     * @param {string} dbInstance 
     * @param {AckPendingEntriesDto} ackPendingEntriesDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public consumerControllerAckPendingEntries(dbInstance: string, ackPendingEntriesDto: AckPendingEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).consumerControllerAckPendingEntries(dbInstance, ackPendingEntriesDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Claim pending entries
     * @summary 
     * @param {string} dbInstance 
     * @param {ClaimPendingEntryDto} claimPendingEntryDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public consumerControllerClaimPendingEntries(dbInstance: string, claimPendingEntryDto: ClaimPendingEntryDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).consumerControllerClaimPendingEntries(dbInstance, claimPendingEntryDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Consumer(s) from the Consumer Group
     * @summary 
     * @param {string} dbInstance 
     * @param {DeleteConsumersDto} deleteConsumersDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public consumerControllerDeleteConsumers(dbInstance: string, deleteConsumersDto: DeleteConsumersDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).consumerControllerDeleteConsumers(dbInstance, deleteConsumersDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get consumers list in the group
     * @summary 
     * @param {string} dbInstance 
     * @param {ConsumerControllerGetConsumersEncodingEnum} encoding 
     * @param {GetConsumersDto} getConsumersDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public consumerControllerGetConsumers(dbInstance: string, encoding: ConsumerControllerGetConsumersEncodingEnum, getConsumersDto: GetConsumersDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).consumerControllerGetConsumers(dbInstance, encoding, getConsumersDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pending entries list
     * @summary 
     * @param {string} dbInstance 
     * @param {ConsumerControllerGetPendingEntriesEncodingEnum} encoding 
     * @param {GetPendingEntriesDto} getPendingEntriesDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public consumerControllerGetPendingEntries(dbInstance: string, encoding: ConsumerControllerGetPendingEntriesEncodingEnum, getPendingEntriesDto: GetPendingEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).consumerControllerGetPendingEntries(dbInstance, encoding, getPendingEntriesDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create stream consumer group
     * @summary 
     * @param {string} dbInstance 
     * @param {CreateConsumerGroupsDto} createConsumerGroupsDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public consumerGroupControllerCreateGroups(dbInstance: string, createConsumerGroupsDto: CreateConsumerGroupsDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).consumerGroupControllerCreateGroups(dbInstance, createConsumerGroupsDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Consumer Group
     * @summary 
     * @param {string} dbInstance 
     * @param {DeleteConsumerGroupsDto} deleteConsumerGroupsDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public consumerGroupControllerDeleteGroup(dbInstance: string, deleteConsumerGroupsDto: DeleteConsumerGroupsDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).consumerGroupControllerDeleteGroup(dbInstance, deleteConsumerGroupsDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get consumer groups list
     * @summary 
     * @param {string} dbInstance 
     * @param {ConsumerGroupControllerGetGroupsEncodingEnum} encoding 
     * @param {KeyDto} keyDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public consumerGroupControllerGetGroups(dbInstance: string, encoding: ConsumerGroupControllerGetGroupsEncodingEnum, keyDto: KeyDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).consumerGroupControllerGetGroups(dbInstance, encoding, keyDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify last delivered ID of the Consumer Group
     * @summary 
     * @param {string} dbInstance 
     * @param {UpdateConsumerGroupDto} updateConsumerGroupDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public consumerGroupControllerUpdateGroup(dbInstance: string, updateConsumerGroupDto: UpdateConsumerGroupDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).consumerGroupControllerUpdateGroup(dbInstance, updateConsumerGroupDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add entries to the stream
     * @summary 
     * @param {string} dbInstance 
     * @param {StreamControllerAddEntriesEncodingEnum} encoding 
     * @param {AddStreamEntriesDto} addStreamEntriesDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public streamControllerAddEntries(dbInstance: string, encoding: StreamControllerAddEntriesEncodingEnum, addStreamEntriesDto: AddStreamEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).streamControllerAddEntries(dbInstance, encoding, addStreamEntriesDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create stream
     * @summary 
     * @param {string} dbInstance 
     * @param {CreateStreamDto} createStreamDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public streamControllerCreateStream(dbInstance: string, createStreamDto: CreateStreamDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).streamControllerCreateStream(dbInstance, createStreamDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove the specified entries from the Stream stored at key
     * @summary 
     * @param {string} dbInstance 
     * @param {DeleteStreamEntriesDto} deleteStreamEntriesDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public streamControllerDeleteEntries(dbInstance: string, deleteStreamEntriesDto: DeleteStreamEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).streamControllerDeleteEntries(dbInstance, deleteStreamEntriesDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get stream entries
     * @summary 
     * @param {string} dbInstance 
     * @param {StreamControllerGetEntriesEncodingEnum} encoding 
     * @param {GetStreamEntriesDto} getStreamEntriesDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public streamControllerGetEntries(dbInstance: string, encoding: StreamControllerGetEntriesEncodingEnum, getStreamEntriesDto: GetStreamEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).streamControllerGetEntries(dbInstance, encoding, getStreamEntriesDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ConsumerControllerGetConsumersEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type ConsumerControllerGetConsumersEncodingEnum = typeof ConsumerControllerGetConsumersEncodingEnum[keyof typeof ConsumerControllerGetConsumersEncodingEnum];
/**
 * @export
 */
export const ConsumerControllerGetPendingEntriesEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type ConsumerControllerGetPendingEntriesEncodingEnum = typeof ConsumerControllerGetPendingEntriesEncodingEnum[keyof typeof ConsumerControllerGetPendingEntriesEncodingEnum];
/**
 * @export
 */
export const ConsumerGroupControllerGetGroupsEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type ConsumerGroupControllerGetGroupsEncodingEnum = typeof ConsumerGroupControllerGetGroupsEncodingEnum[keyof typeof ConsumerGroupControllerGetGroupsEncodingEnum];
/**
 * @export
 */
export const StreamControllerAddEntriesEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type StreamControllerAddEntriesEncodingEnum = typeof StreamControllerAddEntriesEncodingEnum[keyof typeof StreamControllerAddEntriesEncodingEnum];
/**
 * @export
 */
export const StreamControllerGetEntriesEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type StreamControllerGetEntriesEncodingEnum = typeof StreamControllerGetEntriesEncodingEnum[keyof typeof StreamControllerGetEntriesEncodingEnum];


/**
 * BrowserStringApi - axios parameter creator
 * @export
 */
export const BrowserStringApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint do download string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerDownloadStringFileEncodingEnum} encoding 
         * @param {GetKeyInfoDto} getKeyInfoDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stringControllerDownloadStringFile: async (dbInstance: string, encoding: StringControllerDownloadStringFileEncodingEnum, getKeyInfoDto: GetKeyInfoDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('stringControllerDownloadStringFile', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('stringControllerDownloadStringFile', 'encoding', encoding)
            // verify required parameter 'getKeyInfoDto' is not null or undefined
            assertParamExists('stringControllerDownloadStringFile', 'getKeyInfoDto', getKeyInfoDto)
            const localVarPath = `/api/databases/{dbInstance}/string/download-value`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getKeyInfoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerGetStringValueEncodingEnum} encoding 
         * @param {GetStringInfoDto} getStringInfoDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stringControllerGetStringValue: async (dbInstance: string, encoding: StringControllerGetStringValueEncodingEnum, getStringInfoDto: GetStringInfoDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('stringControllerGetStringValue', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('stringControllerGetStringValue', 'encoding', encoding)
            // verify required parameter 'getStringInfoDto' is not null or undefined
            assertParamExists('stringControllerGetStringValue', 'getStringInfoDto', getStringInfoDto)
            const localVarPath = `/api/databases/{dbInstance}/string/get-value`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getStringInfoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set key to hold string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerSetStringEncodingEnum} encoding 
         * @param {SetStringWithExpireDto} setStringWithExpireDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stringControllerSetString: async (dbInstance: string, encoding: StringControllerSetStringEncodingEnum, setStringWithExpireDto: SetStringWithExpireDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('stringControllerSetString', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('stringControllerSetString', 'encoding', encoding)
            // verify required parameter 'setStringWithExpireDto' is not null or undefined
            assertParamExists('stringControllerSetString', 'setStringWithExpireDto', setStringWithExpireDto)
            const localVarPath = `/api/databases/{dbInstance}/string`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setStringWithExpireDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerUpdateStringValueEncodingEnum} encoding 
         * @param {SetStringDto} setStringDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stringControllerUpdateStringValue: async (dbInstance: string, encoding: StringControllerUpdateStringValueEncodingEnum, setStringDto: SetStringDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('stringControllerUpdateStringValue', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('stringControllerUpdateStringValue', 'encoding', encoding)
            // verify required parameter 'setStringDto' is not null or undefined
            assertParamExists('stringControllerUpdateStringValue', 'setStringDto', setStringDto)
            const localVarPath = `/api/databases/{dbInstance}/string`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setStringDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrowserStringApi - functional programming interface
 * @export
 */
export const BrowserStringApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrowserStringApiAxiosParamCreator(configuration)
    return {
        /**
         * Endpoint do download string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerDownloadStringFileEncodingEnum} encoding 
         * @param {GetKeyInfoDto} getKeyInfoDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stringControllerDownloadStringFile(dbInstance: string, encoding: StringControllerDownloadStringFileEncodingEnum, getKeyInfoDto: GetKeyInfoDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stringControllerDownloadStringFile(dbInstance, encoding, getKeyInfoDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStringApi.stringControllerDownloadStringFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerGetStringValueEncodingEnum} encoding 
         * @param {GetStringInfoDto} getStringInfoDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stringControllerGetStringValue(dbInstance: string, encoding: StringControllerGetStringValueEncodingEnum, getStringInfoDto: GetStringInfoDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStringValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stringControllerGetStringValue(dbInstance, encoding, getStringInfoDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStringApi.stringControllerGetStringValue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set key to hold string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerSetStringEncodingEnum} encoding 
         * @param {SetStringWithExpireDto} setStringWithExpireDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stringControllerSetString(dbInstance: string, encoding: StringControllerSetStringEncodingEnum, setStringWithExpireDto: SetStringWithExpireDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stringControllerSetString(dbInstance, encoding, setStringWithExpireDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStringApi.stringControllerSetString']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerUpdateStringValueEncodingEnum} encoding 
         * @param {SetStringDto} setStringDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stringControllerUpdateStringValue(dbInstance: string, encoding: StringControllerUpdateStringValueEncodingEnum, setStringDto: SetStringDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stringControllerUpdateStringValue(dbInstance, encoding, setStringDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStringApi.stringControllerUpdateStringValue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BrowserStringApi - factory interface
 * @export
 */
export const BrowserStringApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrowserStringApiFp(configuration)
    return {
        /**
         * Endpoint do download string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerDownloadStringFileEncodingEnum} encoding 
         * @param {GetKeyInfoDto} getKeyInfoDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stringControllerDownloadStringFile(dbInstance: string, encoding: StringControllerDownloadStringFileEncodingEnum, getKeyInfoDto: GetKeyInfoDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.stringControllerDownloadStringFile(dbInstance, encoding, getKeyInfoDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerGetStringValueEncodingEnum} encoding 
         * @param {GetStringInfoDto} getStringInfoDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stringControllerGetStringValue(dbInstance: string, encoding: StringControllerGetStringValueEncodingEnum, getStringInfoDto: GetStringInfoDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetStringValueResponse> {
            return localVarFp.stringControllerGetStringValue(dbInstance, encoding, getStringInfoDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Set key to hold string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerSetStringEncodingEnum} encoding 
         * @param {SetStringWithExpireDto} setStringWithExpireDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stringControllerSetString(dbInstance: string, encoding: StringControllerSetStringEncodingEnum, setStringWithExpireDto: SetStringWithExpireDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.stringControllerSetString(dbInstance, encoding, setStringWithExpireDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Update string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerUpdateStringValueEncodingEnum} encoding 
         * @param {SetStringDto} setStringDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stringControllerUpdateStringValue(dbInstance: string, encoding: StringControllerUpdateStringValueEncodingEnum, setStringDto: SetStringDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.stringControllerUpdateStringValue(dbInstance, encoding, setStringDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrowserStringApi - object-oriented interface
 * @export
 * @class BrowserStringApi
 * @extends {BaseAPI}
 */
export class BrowserStringApi extends BaseAPI {
    /**
     * Endpoint do download string value
     * @summary 
     * @param {string} dbInstance 
     * @param {StringControllerDownloadStringFileEncodingEnum} encoding 
     * @param {GetKeyInfoDto} getKeyInfoDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStringApi
     */
    public stringControllerDownloadStringFile(dbInstance: string, encoding: StringControllerDownloadStringFileEncodingEnum, getKeyInfoDto: GetKeyInfoDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStringApiFp(this.configuration).stringControllerDownloadStringFile(dbInstance, encoding, getKeyInfoDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get string value
     * @summary 
     * @param {string} dbInstance 
     * @param {StringControllerGetStringValueEncodingEnum} encoding 
     * @param {GetStringInfoDto} getStringInfoDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStringApi
     */
    public stringControllerGetStringValue(dbInstance: string, encoding: StringControllerGetStringValueEncodingEnum, getStringInfoDto: GetStringInfoDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStringApiFp(this.configuration).stringControllerGetStringValue(dbInstance, encoding, getStringInfoDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set key to hold string value
     * @summary 
     * @param {string} dbInstance 
     * @param {StringControllerSetStringEncodingEnum} encoding 
     * @param {SetStringWithExpireDto} setStringWithExpireDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStringApi
     */
    public stringControllerSetString(dbInstance: string, encoding: StringControllerSetStringEncodingEnum, setStringWithExpireDto: SetStringWithExpireDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStringApiFp(this.configuration).stringControllerSetString(dbInstance, encoding, setStringWithExpireDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update string value
     * @summary 
     * @param {string} dbInstance 
     * @param {StringControllerUpdateStringValueEncodingEnum} encoding 
     * @param {SetStringDto} setStringDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStringApi
     */
    public stringControllerUpdateStringValue(dbInstance: string, encoding: StringControllerUpdateStringValueEncodingEnum, setStringDto: SetStringDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStringApiFp(this.configuration).stringControllerUpdateStringValue(dbInstance, encoding, setStringDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const StringControllerDownloadStringFileEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type StringControllerDownloadStringFileEncodingEnum = typeof StringControllerDownloadStringFileEncodingEnum[keyof typeof StringControllerDownloadStringFileEncodingEnum];
/**
 * @export
 */
export const StringControllerGetStringValueEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type StringControllerGetStringValueEncodingEnum = typeof StringControllerGetStringValueEncodingEnum[keyof typeof StringControllerGetStringValueEncodingEnum];
/**
 * @export
 */
export const StringControllerSetStringEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type StringControllerSetStringEncodingEnum = typeof StringControllerSetStringEncodingEnum[keyof typeof StringControllerSetStringEncodingEnum];
/**
 * @export
 */
export const StringControllerUpdateStringValueEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type StringControllerUpdateStringValueEncodingEnum = typeof StringControllerUpdateStringValueEncodingEnum[keyof typeof StringControllerUpdateStringValueEncodingEnum];


/**
 * BrowserZSetApi - axios parameter creator
 * @export
 */
export const BrowserZSetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add the specified members to the ZSet stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {ZSetControllerAddMembersEncodingEnum} encoding 
         * @param {AddMembersToZSetDto} addMembersToZSetDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zSetControllerAddMembers: async (dbInstance: string, encoding: ZSetControllerAddMembersEncodingEnum, addMembersToZSetDto: AddMembersToZSetDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('zSetControllerAddMembers', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('zSetControllerAddMembers', 'encoding', encoding)
            // verify required parameter 'addMembersToZSetDto' is not null or undefined
            assertParamExists('zSetControllerAddMembers', 'addMembersToZSetDto', addMembersToZSetDto)
            const localVarPath = `/api/databases/{dbInstance}/zSet`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addMembersToZSetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set key to hold ZSet data type
         * @summary 
         * @param {string} dbInstance 
         * @param {ZSetControllerCreateSetEncodingEnum} encoding 
         * @param {CreateZSetWithExpireDto} createZSetWithExpireDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zSetControllerCreateSet: async (dbInstance: string, encoding: ZSetControllerCreateSetEncodingEnum, createZSetWithExpireDto: CreateZSetWithExpireDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('zSetControllerCreateSet', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('zSetControllerCreateSet', 'encoding', encoding)
            // verify required parameter 'createZSetWithExpireDto' is not null or undefined
            assertParamExists('zSetControllerCreateSet', 'createZSetWithExpireDto', createZSetWithExpireDto)
            const localVarPath = `/api/databases/{dbInstance}/zSet`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createZSetWithExpireDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the specified members from the Set stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {ZSetControllerDeleteMembersEncodingEnum} encoding 
         * @param {DeleteMembersFromZSetDto} deleteMembersFromZSetDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zSetControllerDeleteMembers: async (dbInstance: string, encoding: ZSetControllerDeleteMembersEncodingEnum, deleteMembersFromZSetDto: DeleteMembersFromZSetDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('zSetControllerDeleteMembers', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('zSetControllerDeleteMembers', 'encoding', encoding)
            // verify required parameter 'deleteMembersFromZSetDto' is not null or undefined
            assertParamExists('zSetControllerDeleteMembers', 'deleteMembersFromZSetDto', deleteMembersFromZSetDto)
            const localVarPath = `/api/databases/{dbInstance}/zSet/members`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteMembersFromZSetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get specified members of the ZSet stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {ZSetControllerGetZSetEncodingEnum} encoding 
         * @param {GetZSetMembersDto} getZSetMembersDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zSetControllerGetZSet: async (dbInstance: string, encoding: ZSetControllerGetZSetEncodingEnum, getZSetMembersDto: GetZSetMembersDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('zSetControllerGetZSet', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('zSetControllerGetZSet', 'encoding', encoding)
            // verify required parameter 'getZSetMembersDto' is not null or undefined
            assertParamExists('zSetControllerGetZSet', 'getZSetMembersDto', getZSetMembersDto)
            const localVarPath = `/api/databases/{dbInstance}/zSet/get-members`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getZSetMembersDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search members in ZSet stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {ZSetControllerSearchZSetEncodingEnum} encoding 
         * @param {SearchZSetMembersDto} searchZSetMembersDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zSetControllerSearchZSet: async (dbInstance: string, encoding: ZSetControllerSearchZSetEncodingEnum, searchZSetMembersDto: SearchZSetMembersDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('zSetControllerSearchZSet', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('zSetControllerSearchZSet', 'encoding', encoding)
            // verify required parameter 'searchZSetMembersDto' is not null or undefined
            assertParamExists('zSetControllerSearchZSet', 'searchZSetMembersDto', searchZSetMembersDto)
            const localVarPath = `/api/databases/{dbInstance}/zSet/search`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchZSetMembersDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the specified member in the ZSet stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {ZSetControllerUpdateMemberEncodingEnum} encoding 
         * @param {UpdateMemberInZSetDto} updateMemberInZSetDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zSetControllerUpdateMember: async (dbInstance: string, encoding: ZSetControllerUpdateMemberEncodingEnum, updateMemberInZSetDto: UpdateMemberInZSetDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('zSetControllerUpdateMember', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('zSetControllerUpdateMember', 'encoding', encoding)
            // verify required parameter 'updateMemberInZSetDto' is not null or undefined
            assertParamExists('zSetControllerUpdateMember', 'updateMemberInZSetDto', updateMemberInZSetDto)
            const localVarPath = `/api/databases/{dbInstance}/zSet`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMemberInZSetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrowserZSetApi - functional programming interface
 * @export
 */
export const BrowserZSetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrowserZSetApiAxiosParamCreator(configuration)
    return {
        /**
         * Add the specified members to the ZSet stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {ZSetControllerAddMembersEncodingEnum} encoding 
         * @param {AddMembersToZSetDto} addMembersToZSetDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zSetControllerAddMembers(dbInstance: string, encoding: ZSetControllerAddMembersEncodingEnum, addMembersToZSetDto: AddMembersToZSetDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zSetControllerAddMembers(dbInstance, encoding, addMembersToZSetDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserZSetApi.zSetControllerAddMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set key to hold ZSet data type
         * @summary 
         * @param {string} dbInstance 
         * @param {ZSetControllerCreateSetEncodingEnum} encoding 
         * @param {CreateZSetWithExpireDto} createZSetWithExpireDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zSetControllerCreateSet(dbInstance: string, encoding: ZSetControllerCreateSetEncodingEnum, createZSetWithExpireDto: CreateZSetWithExpireDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zSetControllerCreateSet(dbInstance, encoding, createZSetWithExpireDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserZSetApi.zSetControllerCreateSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove the specified members from the Set stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {ZSetControllerDeleteMembersEncodingEnum} encoding 
         * @param {DeleteMembersFromZSetDto} deleteMembersFromZSetDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zSetControllerDeleteMembers(dbInstance: string, encoding: ZSetControllerDeleteMembersEncodingEnum, deleteMembersFromZSetDto: DeleteMembersFromZSetDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteMembersFromZSetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zSetControllerDeleteMembers(dbInstance, encoding, deleteMembersFromZSetDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserZSetApi.zSetControllerDeleteMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get specified members of the ZSet stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {ZSetControllerGetZSetEncodingEnum} encoding 
         * @param {GetZSetMembersDto} getZSetMembersDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zSetControllerGetZSet(dbInstance: string, encoding: ZSetControllerGetZSetEncodingEnum, getZSetMembersDto: GetZSetMembersDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetZSetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zSetControllerGetZSet(dbInstance, encoding, getZSetMembersDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserZSetApi.zSetControllerGetZSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search members in ZSet stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {ZSetControllerSearchZSetEncodingEnum} encoding 
         * @param {SearchZSetMembersDto} searchZSetMembersDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zSetControllerSearchZSet(dbInstance: string, encoding: ZSetControllerSearchZSetEncodingEnum, searchZSetMembersDto: SearchZSetMembersDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchZSetMembersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zSetControllerSearchZSet(dbInstance, encoding, searchZSetMembersDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserZSetApi.zSetControllerSearchZSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the specified member in the ZSet stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {ZSetControllerUpdateMemberEncodingEnum} encoding 
         * @param {UpdateMemberInZSetDto} updateMemberInZSetDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zSetControllerUpdateMember(dbInstance: string, encoding: ZSetControllerUpdateMemberEncodingEnum, updateMemberInZSetDto: UpdateMemberInZSetDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zSetControllerUpdateMember(dbInstance, encoding, updateMemberInZSetDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserZSetApi.zSetControllerUpdateMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BrowserZSetApi - factory interface
 * @export
 */
export const BrowserZSetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrowserZSetApiFp(configuration)
    return {
        /**
         * Add the specified members to the ZSet stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {ZSetControllerAddMembersEncodingEnum} encoding 
         * @param {AddMembersToZSetDto} addMembersToZSetDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zSetControllerAddMembers(dbInstance: string, encoding: ZSetControllerAddMembersEncodingEnum, addMembersToZSetDto: AddMembersToZSetDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.zSetControllerAddMembers(dbInstance, encoding, addMembersToZSetDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Set key to hold ZSet data type
         * @summary 
         * @param {string} dbInstance 
         * @param {ZSetControllerCreateSetEncodingEnum} encoding 
         * @param {CreateZSetWithExpireDto} createZSetWithExpireDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zSetControllerCreateSet(dbInstance: string, encoding: ZSetControllerCreateSetEncodingEnum, createZSetWithExpireDto: CreateZSetWithExpireDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.zSetControllerCreateSet(dbInstance, encoding, createZSetWithExpireDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove the specified members from the Set stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {ZSetControllerDeleteMembersEncodingEnum} encoding 
         * @param {DeleteMembersFromZSetDto} deleteMembersFromZSetDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zSetControllerDeleteMembers(dbInstance: string, encoding: ZSetControllerDeleteMembersEncodingEnum, deleteMembersFromZSetDto: DeleteMembersFromZSetDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteMembersFromZSetResponse> {
            return localVarFp.zSetControllerDeleteMembers(dbInstance, encoding, deleteMembersFromZSetDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get specified members of the ZSet stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {ZSetControllerGetZSetEncodingEnum} encoding 
         * @param {GetZSetMembersDto} getZSetMembersDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zSetControllerGetZSet(dbInstance: string, encoding: ZSetControllerGetZSetEncodingEnum, getZSetMembersDto: GetZSetMembersDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetZSetResponse> {
            return localVarFp.zSetControllerGetZSet(dbInstance, encoding, getZSetMembersDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Search members in ZSet stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {ZSetControllerSearchZSetEncodingEnum} encoding 
         * @param {SearchZSetMembersDto} searchZSetMembersDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zSetControllerSearchZSet(dbInstance: string, encoding: ZSetControllerSearchZSetEncodingEnum, searchZSetMembersDto: SearchZSetMembersDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<SearchZSetMembersResponse> {
            return localVarFp.zSetControllerSearchZSet(dbInstance, encoding, searchZSetMembersDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the specified member in the ZSet stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {ZSetControllerUpdateMemberEncodingEnum} encoding 
         * @param {UpdateMemberInZSetDto} updateMemberInZSetDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zSetControllerUpdateMember(dbInstance: string, encoding: ZSetControllerUpdateMemberEncodingEnum, updateMemberInZSetDto: UpdateMemberInZSetDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.zSetControllerUpdateMember(dbInstance, encoding, updateMemberInZSetDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrowserZSetApi - object-oriented interface
 * @export
 * @class BrowserZSetApi
 * @extends {BaseAPI}
 */
export class BrowserZSetApi extends BaseAPI {
    /**
     * Add the specified members to the ZSet stored at key
     * @summary 
     * @param {string} dbInstance 
     * @param {ZSetControllerAddMembersEncodingEnum} encoding 
     * @param {AddMembersToZSetDto} addMembersToZSetDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserZSetApi
     */
    public zSetControllerAddMembers(dbInstance: string, encoding: ZSetControllerAddMembersEncodingEnum, addMembersToZSetDto: AddMembersToZSetDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserZSetApiFp(this.configuration).zSetControllerAddMembers(dbInstance, encoding, addMembersToZSetDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set key to hold ZSet data type
     * @summary 
     * @param {string} dbInstance 
     * @param {ZSetControllerCreateSetEncodingEnum} encoding 
     * @param {CreateZSetWithExpireDto} createZSetWithExpireDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserZSetApi
     */
    public zSetControllerCreateSet(dbInstance: string, encoding: ZSetControllerCreateSetEncodingEnum, createZSetWithExpireDto: CreateZSetWithExpireDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserZSetApiFp(this.configuration).zSetControllerCreateSet(dbInstance, encoding, createZSetWithExpireDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove the specified members from the Set stored at key
     * @summary 
     * @param {string} dbInstance 
     * @param {ZSetControllerDeleteMembersEncodingEnum} encoding 
     * @param {DeleteMembersFromZSetDto} deleteMembersFromZSetDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserZSetApi
     */
    public zSetControllerDeleteMembers(dbInstance: string, encoding: ZSetControllerDeleteMembersEncodingEnum, deleteMembersFromZSetDto: DeleteMembersFromZSetDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserZSetApiFp(this.configuration).zSetControllerDeleteMembers(dbInstance, encoding, deleteMembersFromZSetDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get specified members of the ZSet stored at key
     * @summary 
     * @param {string} dbInstance 
     * @param {ZSetControllerGetZSetEncodingEnum} encoding 
     * @param {GetZSetMembersDto} getZSetMembersDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserZSetApi
     */
    public zSetControllerGetZSet(dbInstance: string, encoding: ZSetControllerGetZSetEncodingEnum, getZSetMembersDto: GetZSetMembersDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserZSetApiFp(this.configuration).zSetControllerGetZSet(dbInstance, encoding, getZSetMembersDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search members in ZSet stored at key
     * @summary 
     * @param {string} dbInstance 
     * @param {ZSetControllerSearchZSetEncodingEnum} encoding 
     * @param {SearchZSetMembersDto} searchZSetMembersDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserZSetApi
     */
    public zSetControllerSearchZSet(dbInstance: string, encoding: ZSetControllerSearchZSetEncodingEnum, searchZSetMembersDto: SearchZSetMembersDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserZSetApiFp(this.configuration).zSetControllerSearchZSet(dbInstance, encoding, searchZSetMembersDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the specified member in the ZSet stored at key
     * @summary 
     * @param {string} dbInstance 
     * @param {ZSetControllerUpdateMemberEncodingEnum} encoding 
     * @param {UpdateMemberInZSetDto} updateMemberInZSetDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserZSetApi
     */
    public zSetControllerUpdateMember(dbInstance: string, encoding: ZSetControllerUpdateMemberEncodingEnum, updateMemberInZSetDto: UpdateMemberInZSetDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserZSetApiFp(this.configuration).zSetControllerUpdateMember(dbInstance, encoding, updateMemberInZSetDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ZSetControllerAddMembersEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type ZSetControllerAddMembersEncodingEnum = typeof ZSetControllerAddMembersEncodingEnum[keyof typeof ZSetControllerAddMembersEncodingEnum];
/**
 * @export
 */
export const ZSetControllerCreateSetEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type ZSetControllerCreateSetEncodingEnum = typeof ZSetControllerCreateSetEncodingEnum[keyof typeof ZSetControllerCreateSetEncodingEnum];
/**
 * @export
 */
export const ZSetControllerDeleteMembersEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type ZSetControllerDeleteMembersEncodingEnum = typeof ZSetControllerDeleteMembersEncodingEnum[keyof typeof ZSetControllerDeleteMembersEncodingEnum];
/**
 * @export
 */
export const ZSetControllerGetZSetEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type ZSetControllerGetZSetEncodingEnum = typeof ZSetControllerGetZSetEncodingEnum[keyof typeof ZSetControllerGetZSetEncodingEnum];
/**
 * @export
 */
export const ZSetControllerSearchZSetEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type ZSetControllerSearchZSetEncodingEnum = typeof ZSetControllerSearchZSetEncodingEnum[keyof typeof ZSetControllerSearchZSetEncodingEnum];
/**
 * @export
 */
export const ZSetControllerUpdateMemberEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type ZSetControllerUpdateMemberEncodingEnum = typeof ZSetControllerUpdateMemberEncodingEnum[keyof typeof ZSetControllerUpdateMemberEncodingEnum];


/**
 * BulkActionsApi - axios parameter creator
 * @export
 */
export const BulkActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Import data from file
         * @summary 
         * @param {string} dbInstance 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkImportControllerImport: async (dbInstance: string, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('bulkImportControllerImport', 'dbInstance', dbInstance)
            const localVarPath = `/api/databases/{dbInstance}/bulk-actions/import`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import default data
         * @summary 
         * @param {string} dbInstance 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkImportControllerImportDefaultData: async (dbInstance: string, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('bulkImportControllerImportDefaultData', 'dbInstance', dbInstance)
            const localVarPath = `/api/databases/{dbInstance}/bulk-actions/import/default-data`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import data from tutorial by path
         * @summary 
         * @param {string} dbInstance 
         * @param {UploadImportFileByPathDto} uploadImportFileByPathDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkImportControllerUploadFromTutorial: async (dbInstance: string, uploadImportFileByPathDto: UploadImportFileByPathDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('bulkImportControllerUploadFromTutorial', 'dbInstance', dbInstance)
            // verify required parameter 'uploadImportFileByPathDto' is not null or undefined
            assertParamExists('bulkImportControllerUploadFromTutorial', 'uploadImportFileByPathDto', uploadImportFileByPathDto)
            const localVarPath = `/api/databases/{dbInstance}/bulk-actions/import/tutorial-data`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadImportFileByPathDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BulkActionsApi - functional programming interface
 * @export
 */
export const BulkActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BulkActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Import data from file
         * @summary 
         * @param {string} dbInstance 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkImportControllerImport(dbInstance: string, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkImportControllerImport(dbInstance, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BulkActionsApi.bulkImportControllerImport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import default data
         * @summary 
         * @param {string} dbInstance 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkImportControllerImportDefaultData(dbInstance: string, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkImportControllerImportDefaultData(dbInstance, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BulkActionsApi.bulkImportControllerImportDefaultData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import data from tutorial by path
         * @summary 
         * @param {string} dbInstance 
         * @param {UploadImportFileByPathDto} uploadImportFileByPathDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkImportControllerUploadFromTutorial(dbInstance: string, uploadImportFileByPathDto: UploadImportFileByPathDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkImportControllerUploadFromTutorial(dbInstance, uploadImportFileByPathDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BulkActionsApi.bulkImportControllerUploadFromTutorial']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BulkActionsApi - factory interface
 * @export
 */
export const BulkActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BulkActionsApiFp(configuration)
    return {
        /**
         * Import data from file
         * @summary 
         * @param {string} dbInstance 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkImportControllerImport(dbInstance: string, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.bulkImportControllerImport(dbInstance, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Import default data
         * @summary 
         * @param {string} dbInstance 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkImportControllerImportDefaultData(dbInstance: string, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.bulkImportControllerImportDefaultData(dbInstance, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Import data from tutorial by path
         * @summary 
         * @param {string} dbInstance 
         * @param {UploadImportFileByPathDto} uploadImportFileByPathDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkImportControllerUploadFromTutorial(dbInstance: string, uploadImportFileByPathDto: UploadImportFileByPathDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.bulkImportControllerUploadFromTutorial(dbInstance, uploadImportFileByPathDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BulkActionsApi - object-oriented interface
 * @export
 * @class BulkActionsApi
 * @extends {BaseAPI}
 */
export class BulkActionsApi extends BaseAPI {
    /**
     * Import data from file
     * @summary 
     * @param {string} dbInstance 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsApi
     */
    public bulkImportControllerImport(dbInstance: string, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BulkActionsApiFp(this.configuration).bulkImportControllerImport(dbInstance, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import default data
     * @summary 
     * @param {string} dbInstance 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsApi
     */
    public bulkImportControllerImportDefaultData(dbInstance: string, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BulkActionsApiFp(this.configuration).bulkImportControllerImportDefaultData(dbInstance, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import data from tutorial by path
     * @summary 
     * @param {string} dbInstance 
     * @param {UploadImportFileByPathDto} uploadImportFileByPathDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsApi
     */
    public bulkImportControllerUploadFromTutorial(dbInstance: string, uploadImportFileByPathDto: UploadImportFileByPathDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BulkActionsApiFp(this.configuration).bulkImportControllerUploadFromTutorial(dbInstance, uploadImportFileByPathDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CLIApi - axios parameter creator
 * @export
 */
export const CLIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete Redis CLI client
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {string} uuid CLI client uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cliControllerDeleteClient: async (dbInstance: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('cliControllerDeleteClient', 'dbInstance', dbInstance)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('cliControllerDeleteClient', 'uuid', uuid)
            const localVarPath = `/api/databases/{dbInstance}/cli/{uuid}`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create Redis client for CLI
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cliControllerGetClient: async (dbInstance: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('cliControllerGetClient', 'dbInstance', dbInstance)
            const localVarPath = `/api/databases/{dbInstance}/cli`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Re-create Redis client for CLI
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {string} uuid CLI client uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cliControllerReCreateClient: async (dbInstance: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('cliControllerReCreateClient', 'dbInstance', dbInstance)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('cliControllerReCreateClient', 'uuid', uuid)
            const localVarPath = `/api/databases/{dbInstance}/cli/{uuid}`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send Redis CLI command
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {string} uuid CLI client uuid
         * @param {SendCommandDto} sendCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cliControllerSendClusterCommand: async (dbInstance: string, uuid: string, sendCommandDto: SendCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('cliControllerSendClusterCommand', 'dbInstance', dbInstance)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('cliControllerSendClusterCommand', 'uuid', uuid)
            // verify required parameter 'sendCommandDto' is not null or undefined
            assertParamExists('cliControllerSendClusterCommand', 'sendCommandDto', sendCommandDto)
            const localVarPath = `/api/databases/{dbInstance}/cli/{uuid}/send-cluster-command`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send Redis CLI command
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {string} uuid CLI client uuid
         * @param {SendCommandDto} sendCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cliControllerSendCommand: async (dbInstance: string, uuid: string, sendCommandDto: SendCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('cliControllerSendCommand', 'dbInstance', dbInstance)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('cliControllerSendCommand', 'uuid', uuid)
            // verify required parameter 'sendCommandDto' is not null or undefined
            assertParamExists('cliControllerSendCommand', 'sendCommandDto', sendCommandDto)
            const localVarPath = `/api/databases/{dbInstance}/cli/{uuid}/send-command`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CLIApi - functional programming interface
 * @export
 */
export const CLIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CLIApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete Redis CLI client
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {string} uuid CLI client uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cliControllerDeleteClient(dbInstance: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteClientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cliControllerDeleteClient(dbInstance, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CLIApi.cliControllerDeleteClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create Redis client for CLI
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cliControllerGetClient(dbInstance: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCliClientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cliControllerGetClient(dbInstance, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CLIApi.cliControllerGetClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Re-create Redis client for CLI
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {string} uuid CLI client uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cliControllerReCreateClient(dbInstance: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cliControllerReCreateClient(dbInstance, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CLIApi.cliControllerReCreateClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send Redis CLI command
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {string} uuid CLI client uuid
         * @param {SendCommandDto} sendCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cliControllerSendClusterCommand(dbInstance: string, uuid: string, sendCommandDto: SendCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SendCommandResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cliControllerSendClusterCommand(dbInstance, uuid, sendCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CLIApi.cliControllerSendClusterCommand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send Redis CLI command
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {string} uuid CLI client uuid
         * @param {SendCommandDto} sendCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cliControllerSendCommand(dbInstance: string, uuid: string, sendCommandDto: SendCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendCommandResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cliControllerSendCommand(dbInstance, uuid, sendCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CLIApi.cliControllerSendCommand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CLIApi - factory interface
 * @export
 */
export const CLIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CLIApiFp(configuration)
    return {
        /**
         * Delete Redis CLI client
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {string} uuid CLI client uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cliControllerDeleteClient(dbInstance: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteClientResponse> {
            return localVarFp.cliControllerDeleteClient(dbInstance, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Create Redis client for CLI
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cliControllerGetClient(dbInstance: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateCliClientResponse> {
            return localVarFp.cliControllerGetClient(dbInstance, options).then((request) => request(axios, basePath));
        },
        /**
         * Re-create Redis client for CLI
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {string} uuid CLI client uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cliControllerReCreateClient(dbInstance: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cliControllerReCreateClient(dbInstance, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Send Redis CLI command
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {string} uuid CLI client uuid
         * @param {SendCommandDto} sendCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cliControllerSendClusterCommand(dbInstance: string, uuid: string, sendCommandDto: SendCommandDto, options?: RawAxiosRequestConfig): AxiosPromise<Array<SendCommandResponse>> {
            return localVarFp.cliControllerSendClusterCommand(dbInstance, uuid, sendCommandDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Send Redis CLI command
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {string} uuid CLI client uuid
         * @param {SendCommandDto} sendCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cliControllerSendCommand(dbInstance: string, uuid: string, sendCommandDto: SendCommandDto, options?: RawAxiosRequestConfig): AxiosPromise<SendCommandResponse> {
            return localVarFp.cliControllerSendCommand(dbInstance, uuid, sendCommandDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CLIApi - object-oriented interface
 * @export
 * @class CLIApi
 * @extends {BaseAPI}
 */
export class CLIApi extends BaseAPI {
    /**
     * Delete Redis CLI client
     * @summary 
     * @param {string} dbInstance Database instance id.
     * @param {string} uuid CLI client uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CLIApi
     */
    public cliControllerDeleteClient(dbInstance: string, uuid: string, options?: RawAxiosRequestConfig) {
        return CLIApiFp(this.configuration).cliControllerDeleteClient(dbInstance, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create Redis client for CLI
     * @summary 
     * @param {string} dbInstance Database instance id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CLIApi
     */
    public cliControllerGetClient(dbInstance: string, options?: RawAxiosRequestConfig) {
        return CLIApiFp(this.configuration).cliControllerGetClient(dbInstance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Re-create Redis client for CLI
     * @summary 
     * @param {string} dbInstance Database instance id.
     * @param {string} uuid CLI client uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CLIApi
     */
    public cliControllerReCreateClient(dbInstance: string, uuid: string, options?: RawAxiosRequestConfig) {
        return CLIApiFp(this.configuration).cliControllerReCreateClient(dbInstance, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send Redis CLI command
     * @summary 
     * @param {string} dbInstance Database instance id.
     * @param {string} uuid CLI client uuid
     * @param {SendCommandDto} sendCommandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CLIApi
     */
    public cliControllerSendClusterCommand(dbInstance: string, uuid: string, sendCommandDto: SendCommandDto, options?: RawAxiosRequestConfig) {
        return CLIApiFp(this.configuration).cliControllerSendClusterCommand(dbInstance, uuid, sendCommandDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send Redis CLI command
     * @summary 
     * @param {string} dbInstance Database instance id.
     * @param {string} uuid CLI client uuid
     * @param {SendCommandDto} sendCommandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CLIApi
     */
    public cliControllerSendCommand(dbInstance: string, uuid: string, sendCommandDto: SendCommandDto, options?: RawAxiosRequestConfig) {
        return CLIApiFp(this.configuration).cliControllerSendCommand(dbInstance, uuid, sendCommandDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CloudAuthApi - axios parameter creator
 * @export
 */
export const CloudAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OAuth callback endpoint for handling OAuth authorization code flow
         * @summary 
         * @param {string} [code] Authorization code from OAuth provider
         * @param {string} [state] State parameter to prevent CSRF attacks
         * @param {string} [error] Error code if OAuth flow failed
         * @param {string} [errorDescription] Human-readable error description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudAuthControllerCallback: async (code?: string, state?: string, error?: string, errorDescription?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cloud/auth/oauth/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (error !== undefined) {
                localVarQueryParameter['error'] = error;
            }

            if (errorDescription !== undefined) {
                localVarQueryParameter['error_description'] = errorDescription;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudAuthApi - functional programming interface
 * @export
 */
export const CloudAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * OAuth callback endpoint for handling OAuth authorization code flow
         * @summary 
         * @param {string} [code] Authorization code from OAuth provider
         * @param {string} [state] State parameter to prevent CSRF attacks
         * @param {string} [error] Error code if OAuth flow failed
         * @param {string} [errorDescription] Human-readable error description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudAuthControllerCallback(code?: string, state?: string, error?: string, errorDescription?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudAuthControllerCallback(code, state, error, errorDescription, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudAuthApi.cloudAuthControllerCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CloudAuthApi - factory interface
 * @export
 */
export const CloudAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudAuthApiFp(configuration)
    return {
        /**
         * OAuth callback endpoint for handling OAuth authorization code flow
         * @summary 
         * @param {string} [code] Authorization code from OAuth provider
         * @param {string} [state] State parameter to prevent CSRF attacks
         * @param {string} [error] Error code if OAuth flow failed
         * @param {string} [errorDescription] Human-readable error description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudAuthControllerCallback(code?: string, state?: string, error?: string, errorDescription?: string, options?: RawAxiosRequestConfig): AxiosPromise<CloudAuthResponse> {
            return localVarFp.cloudAuthControllerCallback(code, state, error, errorDescription, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudAuthApi - object-oriented interface
 * @export
 * @class CloudAuthApi
 * @extends {BaseAPI}
 */
export class CloudAuthApi extends BaseAPI {
    /**
     * OAuth callback endpoint for handling OAuth authorization code flow
     * @summary 
     * @param {string} [code] Authorization code from OAuth provider
     * @param {string} [state] State parameter to prevent CSRF attacks
     * @param {string} [error] Error code if OAuth flow failed
     * @param {string} [errorDescription] Human-readable error description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudAuthApi
     */
    public cloudAuthControllerCallback(code?: string, state?: string, error?: string, errorDescription?: string, options?: RawAxiosRequestConfig) {
        return CloudAuthApiFp(this.configuration).cloudAuthControllerCallback(code, state, error, errorDescription, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CloudAutodiscoveryApi - axios parameter creator
 * @export
 */
export const CloudAutodiscoveryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add databases from Redis Enterprise Cloud Pro account.
         * @summary 
         * @param {ImportCloudDatabasesDto} importCloudDatabasesDto 
         * @param {string} [xCloudApiKey] 
         * @param {string} [xCloudApiSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudAutodiscoveryControllerAddDiscoveredDatabases: async (importCloudDatabasesDto: ImportCloudDatabasesDto, xCloudApiKey?: string, xCloudApiSecret?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'importCloudDatabasesDto' is not null or undefined
            assertParamExists('cloudAutodiscoveryControllerAddDiscoveredDatabases', 'importCloudDatabasesDto', importCloudDatabasesDto)
            const localVarPath = `/api/cloud/autodiscovery/databases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xCloudApiKey != null) {
                localVarHeaderParameter['x-cloud-api-key'] = String(xCloudApiKey);
            }
            if (xCloudApiSecret != null) {
                localVarHeaderParameter['x-cloud-api-secret'] = String(xCloudApiSecret);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importCloudDatabasesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get databases belonging to subscriptions
         * @summary 
         * @param {DiscoverCloudDatabasesDto} discoverCloudDatabasesDto 
         * @param {string} [xCloudApiKey] 
         * @param {string} [xCloudApiSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudAutodiscoveryControllerDiscoverDatabases: async (discoverCloudDatabasesDto: DiscoverCloudDatabasesDto, xCloudApiKey?: string, xCloudApiSecret?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'discoverCloudDatabasesDto' is not null or undefined
            assertParamExists('cloudAutodiscoveryControllerDiscoverDatabases', 'discoverCloudDatabasesDto', discoverCloudDatabasesDto)
            const localVarPath = `/api/cloud/autodiscovery/get-databases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xCloudApiKey != null) {
                localVarHeaderParameter['x-cloud-api-key'] = String(xCloudApiKey);
            }
            if (xCloudApiSecret != null) {
                localVarHeaderParameter['x-cloud-api-secret'] = String(xCloudApiSecret);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(discoverCloudDatabasesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about current accounts subscriptions.
         * @summary 
         * @param {string} [xCloudApiKey] 
         * @param {string} [xCloudApiSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudAutodiscoveryControllerDiscoverSubscriptions: async (xCloudApiKey?: string, xCloudApiSecret?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cloud/autodiscovery/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xCloudApiKey != null) {
                localVarHeaderParameter['x-cloud-api-key'] = String(xCloudApiKey);
            }
            if (xCloudApiSecret != null) {
                localVarHeaderParameter['x-cloud-api-secret'] = String(xCloudApiSecret);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current account
         * @summary 
         * @param {string} [xCloudApiKey] 
         * @param {string} [xCloudApiSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudAutodiscoveryControllerGetAccount: async (xCloudApiKey?: string, xCloudApiSecret?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cloud/autodiscovery/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xCloudApiKey != null) {
                localVarHeaderParameter['x-cloud-api-key'] = String(xCloudApiKey);
            }
            if (xCloudApiSecret != null) {
                localVarHeaderParameter['x-cloud-api-secret'] = String(xCloudApiSecret);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add databases from Redis Enterprise Cloud Pro account.
         * @summary 
         * @param {ImportCloudDatabasesDto} importCloudDatabasesDto 
         * @param {string} [source] 
         * @param {string} [medium] 
         * @param {string} [campaign] 
         * @param {string} [amp] 
         * @param {string} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meCloudAutodiscoveryControllerAddDiscoveredDatabases: async (importCloudDatabasesDto: ImportCloudDatabasesDto, source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'importCloudDatabasesDto' is not null or undefined
            assertParamExists('meCloudAutodiscoveryControllerAddDiscoveredDatabases', 'importCloudDatabasesDto', importCloudDatabasesDto)
            const localVarPath = `/api/cloud/me/autodiscovery/databases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (medium !== undefined) {
                localVarQueryParameter['medium'] = medium;
            }

            if (campaign !== undefined) {
                localVarQueryParameter['campaign'] = campaign;
            }

            if (amp !== undefined) {
                localVarQueryParameter['amp'] = amp;
            }

            if (_package !== undefined) {
                localVarQueryParameter['package'] = _package;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importCloudDatabasesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get databases belonging to subscriptions
         * @summary 
         * @param {DiscoverCloudDatabasesDto} discoverCloudDatabasesDto 
         * @param {string} [source] 
         * @param {string} [medium] 
         * @param {string} [campaign] 
         * @param {string} [amp] 
         * @param {string} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meCloudAutodiscoveryControllerDiscoverDatabases: async (discoverCloudDatabasesDto: DiscoverCloudDatabasesDto, source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'discoverCloudDatabasesDto' is not null or undefined
            assertParamExists('meCloudAutodiscoveryControllerDiscoverDatabases', 'discoverCloudDatabasesDto', discoverCloudDatabasesDto)
            const localVarPath = `/api/cloud/me/autodiscovery/get-databases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (medium !== undefined) {
                localVarQueryParameter['medium'] = medium;
            }

            if (campaign !== undefined) {
                localVarQueryParameter['campaign'] = campaign;
            }

            if (amp !== undefined) {
                localVarQueryParameter['amp'] = amp;
            }

            if (_package !== undefined) {
                localVarQueryParameter['package'] = _package;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(discoverCloudDatabasesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about current accounts subscriptions.
         * @summary 
         * @param {string} [source] 
         * @param {string} [medium] 
         * @param {string} [campaign] 
         * @param {string} [amp] 
         * @param {string} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meCloudAutodiscoveryControllerDiscoverSubscriptions: async (source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cloud/me/autodiscovery/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (medium !== undefined) {
                localVarQueryParameter['medium'] = medium;
            }

            if (campaign !== undefined) {
                localVarQueryParameter['campaign'] = campaign;
            }

            if (amp !== undefined) {
                localVarQueryParameter['amp'] = amp;
            }

            if (_package !== undefined) {
                localVarQueryParameter['package'] = _package;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current account
         * @summary 
         * @param {string} [source] 
         * @param {string} [medium] 
         * @param {string} [campaign] 
         * @param {string} [amp] 
         * @param {string} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meCloudAutodiscoveryControllerGetAccount: async (source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cloud/me/autodiscovery/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (medium !== undefined) {
                localVarQueryParameter['medium'] = medium;
            }

            if (campaign !== undefined) {
                localVarQueryParameter['campaign'] = campaign;
            }

            if (amp !== undefined) {
                localVarQueryParameter['amp'] = amp;
            }

            if (_package !== undefined) {
                localVarQueryParameter['package'] = _package;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudAutodiscoveryApi - functional programming interface
 * @export
 */
export const CloudAutodiscoveryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudAutodiscoveryApiAxiosParamCreator(configuration)
    return {
        /**
         * Add databases from Redis Enterprise Cloud Pro account.
         * @summary 
         * @param {ImportCloudDatabasesDto} importCloudDatabasesDto 
         * @param {string} [xCloudApiKey] 
         * @param {string} [xCloudApiSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudAutodiscoveryControllerAddDiscoveredDatabases(importCloudDatabasesDto: ImportCloudDatabasesDto, xCloudApiKey?: string, xCloudApiSecret?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImportCloudDatabaseResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudAutodiscoveryControllerAddDiscoveredDatabases(importCloudDatabasesDto, xCloudApiKey, xCloudApiSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudAutodiscoveryApi.cloudAutodiscoveryControllerAddDiscoveredDatabases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get databases belonging to subscriptions
         * @summary 
         * @param {DiscoverCloudDatabasesDto} discoverCloudDatabasesDto 
         * @param {string} [xCloudApiKey] 
         * @param {string} [xCloudApiSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudAutodiscoveryControllerDiscoverDatabases(discoverCloudDatabasesDto: DiscoverCloudDatabasesDto, xCloudApiKey?: string, xCloudApiSecret?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CloudDatabase>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudAutodiscoveryControllerDiscoverDatabases(discoverCloudDatabasesDto, xCloudApiKey, xCloudApiSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudAutodiscoveryApi.cloudAutodiscoveryControllerDiscoverDatabases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about current accounts subscriptions.
         * @summary 
         * @param {string} [xCloudApiKey] 
         * @param {string} [xCloudApiSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudAutodiscoveryControllerDiscoverSubscriptions(xCloudApiKey?: string, xCloudApiSecret?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CloudSubscription>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudAutodiscoveryControllerDiscoverSubscriptions(xCloudApiKey, xCloudApiSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudAutodiscoveryApi.cloudAutodiscoveryControllerDiscoverSubscriptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current account
         * @summary 
         * @param {string} [xCloudApiKey] 
         * @param {string} [xCloudApiSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudAutodiscoveryControllerGetAccount(xCloudApiKey?: string, xCloudApiSecret?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudAccountInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudAutodiscoveryControllerGetAccount(xCloudApiKey, xCloudApiSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudAutodiscoveryApi.cloudAutodiscoveryControllerGetAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add databases from Redis Enterprise Cloud Pro account.
         * @summary 
         * @param {ImportCloudDatabasesDto} importCloudDatabasesDto 
         * @param {string} [source] 
         * @param {string} [medium] 
         * @param {string} [campaign] 
         * @param {string} [amp] 
         * @param {string} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meCloudAutodiscoveryControllerAddDiscoveredDatabases(importCloudDatabasesDto: ImportCloudDatabasesDto, source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImportCloudDatabaseResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meCloudAutodiscoveryControllerAddDiscoveredDatabases(importCloudDatabasesDto, source, medium, campaign, amp, _package, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudAutodiscoveryApi.meCloudAutodiscoveryControllerAddDiscoveredDatabases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get databases belonging to subscriptions
         * @summary 
         * @param {DiscoverCloudDatabasesDto} discoverCloudDatabasesDto 
         * @param {string} [source] 
         * @param {string} [medium] 
         * @param {string} [campaign] 
         * @param {string} [amp] 
         * @param {string} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meCloudAutodiscoveryControllerDiscoverDatabases(discoverCloudDatabasesDto: DiscoverCloudDatabasesDto, source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CloudDatabase>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meCloudAutodiscoveryControllerDiscoverDatabases(discoverCloudDatabasesDto, source, medium, campaign, amp, _package, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudAutodiscoveryApi.meCloudAutodiscoveryControllerDiscoverDatabases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about current accounts subscriptions.
         * @summary 
         * @param {string} [source] 
         * @param {string} [medium] 
         * @param {string} [campaign] 
         * @param {string} [amp] 
         * @param {string} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meCloudAutodiscoveryControllerDiscoverSubscriptions(source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CloudSubscription>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meCloudAutodiscoveryControllerDiscoverSubscriptions(source, medium, campaign, amp, _package, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudAutodiscoveryApi.meCloudAutodiscoveryControllerDiscoverSubscriptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current account
         * @summary 
         * @param {string} [source] 
         * @param {string} [medium] 
         * @param {string} [campaign] 
         * @param {string} [amp] 
         * @param {string} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meCloudAutodiscoveryControllerGetAccount(source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudAccountInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meCloudAutodiscoveryControllerGetAccount(source, medium, campaign, amp, _package, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudAutodiscoveryApi.meCloudAutodiscoveryControllerGetAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CloudAutodiscoveryApi - factory interface
 * @export
 */
export const CloudAutodiscoveryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudAutodiscoveryApiFp(configuration)
    return {
        /**
         * Add databases from Redis Enterprise Cloud Pro account.
         * @summary 
         * @param {ImportCloudDatabasesDto} importCloudDatabasesDto 
         * @param {string} [xCloudApiKey] 
         * @param {string} [xCloudApiSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudAutodiscoveryControllerAddDiscoveredDatabases(importCloudDatabasesDto: ImportCloudDatabasesDto, xCloudApiKey?: string, xCloudApiSecret?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ImportCloudDatabaseResponse>> {
            return localVarFp.cloudAutodiscoveryControllerAddDiscoveredDatabases(importCloudDatabasesDto, xCloudApiKey, xCloudApiSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * Get databases belonging to subscriptions
         * @summary 
         * @param {DiscoverCloudDatabasesDto} discoverCloudDatabasesDto 
         * @param {string} [xCloudApiKey] 
         * @param {string} [xCloudApiSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudAutodiscoveryControllerDiscoverDatabases(discoverCloudDatabasesDto: DiscoverCloudDatabasesDto, xCloudApiKey?: string, xCloudApiSecret?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CloudDatabase>> {
            return localVarFp.cloudAutodiscoveryControllerDiscoverDatabases(discoverCloudDatabasesDto, xCloudApiKey, xCloudApiSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about current accounts subscriptions.
         * @summary 
         * @param {string} [xCloudApiKey] 
         * @param {string} [xCloudApiSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudAutodiscoveryControllerDiscoverSubscriptions(xCloudApiKey?: string, xCloudApiSecret?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CloudSubscription>> {
            return localVarFp.cloudAutodiscoveryControllerDiscoverSubscriptions(xCloudApiKey, xCloudApiSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current account
         * @summary 
         * @param {string} [xCloudApiKey] 
         * @param {string} [xCloudApiSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudAutodiscoveryControllerGetAccount(xCloudApiKey?: string, xCloudApiSecret?: string, options?: RawAxiosRequestConfig): AxiosPromise<CloudAccountInfo> {
            return localVarFp.cloudAutodiscoveryControllerGetAccount(xCloudApiKey, xCloudApiSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * Add databases from Redis Enterprise Cloud Pro account.
         * @summary 
         * @param {ImportCloudDatabasesDto} importCloudDatabasesDto 
         * @param {string} [source] 
         * @param {string} [medium] 
         * @param {string} [campaign] 
         * @param {string} [amp] 
         * @param {string} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meCloudAutodiscoveryControllerAddDiscoveredDatabases(importCloudDatabasesDto: ImportCloudDatabasesDto, source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ImportCloudDatabaseResponse>> {
            return localVarFp.meCloudAutodiscoveryControllerAddDiscoveredDatabases(importCloudDatabasesDto, source, medium, campaign, amp, _package, options).then((request) => request(axios, basePath));
        },
        /**
         * Get databases belonging to subscriptions
         * @summary 
         * @param {DiscoverCloudDatabasesDto} discoverCloudDatabasesDto 
         * @param {string} [source] 
         * @param {string} [medium] 
         * @param {string} [campaign] 
         * @param {string} [amp] 
         * @param {string} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meCloudAutodiscoveryControllerDiscoverDatabases(discoverCloudDatabasesDto: DiscoverCloudDatabasesDto, source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CloudDatabase>> {
            return localVarFp.meCloudAutodiscoveryControllerDiscoverDatabases(discoverCloudDatabasesDto, source, medium, campaign, amp, _package, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about current accounts subscriptions.
         * @summary 
         * @param {string} [source] 
         * @param {string} [medium] 
         * @param {string} [campaign] 
         * @param {string} [amp] 
         * @param {string} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meCloudAutodiscoveryControllerDiscoverSubscriptions(source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CloudSubscription>> {
            return localVarFp.meCloudAutodiscoveryControllerDiscoverSubscriptions(source, medium, campaign, amp, _package, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current account
         * @summary 
         * @param {string} [source] 
         * @param {string} [medium] 
         * @param {string} [campaign] 
         * @param {string} [amp] 
         * @param {string} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meCloudAutodiscoveryControllerGetAccount(source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options?: RawAxiosRequestConfig): AxiosPromise<CloudAccountInfo> {
            return localVarFp.meCloudAutodiscoveryControllerGetAccount(source, medium, campaign, amp, _package, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudAutodiscoveryApi - object-oriented interface
 * @export
 * @class CloudAutodiscoveryApi
 * @extends {BaseAPI}
 */
export class CloudAutodiscoveryApi extends BaseAPI {
    /**
     * Add databases from Redis Enterprise Cloud Pro account.
     * @summary 
     * @param {ImportCloudDatabasesDto} importCloudDatabasesDto 
     * @param {string} [xCloudApiKey] 
     * @param {string} [xCloudApiSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudAutodiscoveryApi
     */
    public cloudAutodiscoveryControllerAddDiscoveredDatabases(importCloudDatabasesDto: ImportCloudDatabasesDto, xCloudApiKey?: string, xCloudApiSecret?: string, options?: RawAxiosRequestConfig) {
        return CloudAutodiscoveryApiFp(this.configuration).cloudAutodiscoveryControllerAddDiscoveredDatabases(importCloudDatabasesDto, xCloudApiKey, xCloudApiSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get databases belonging to subscriptions
     * @summary 
     * @param {DiscoverCloudDatabasesDto} discoverCloudDatabasesDto 
     * @param {string} [xCloudApiKey] 
     * @param {string} [xCloudApiSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudAutodiscoveryApi
     */
    public cloudAutodiscoveryControllerDiscoverDatabases(discoverCloudDatabasesDto: DiscoverCloudDatabasesDto, xCloudApiKey?: string, xCloudApiSecret?: string, options?: RawAxiosRequestConfig) {
        return CloudAutodiscoveryApiFp(this.configuration).cloudAutodiscoveryControllerDiscoverDatabases(discoverCloudDatabasesDto, xCloudApiKey, xCloudApiSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about current accounts subscriptions.
     * @summary 
     * @param {string} [xCloudApiKey] 
     * @param {string} [xCloudApiSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudAutodiscoveryApi
     */
    public cloudAutodiscoveryControllerDiscoverSubscriptions(xCloudApiKey?: string, xCloudApiSecret?: string, options?: RawAxiosRequestConfig) {
        return CloudAutodiscoveryApiFp(this.configuration).cloudAutodiscoveryControllerDiscoverSubscriptions(xCloudApiKey, xCloudApiSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current account
     * @summary 
     * @param {string} [xCloudApiKey] 
     * @param {string} [xCloudApiSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudAutodiscoveryApi
     */
    public cloudAutodiscoveryControllerGetAccount(xCloudApiKey?: string, xCloudApiSecret?: string, options?: RawAxiosRequestConfig) {
        return CloudAutodiscoveryApiFp(this.configuration).cloudAutodiscoveryControllerGetAccount(xCloudApiKey, xCloudApiSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add databases from Redis Enterprise Cloud Pro account.
     * @summary 
     * @param {ImportCloudDatabasesDto} importCloudDatabasesDto 
     * @param {string} [source] 
     * @param {string} [medium] 
     * @param {string} [campaign] 
     * @param {string} [amp] 
     * @param {string} [_package] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudAutodiscoveryApi
     */
    public meCloudAutodiscoveryControllerAddDiscoveredDatabases(importCloudDatabasesDto: ImportCloudDatabasesDto, source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options?: RawAxiosRequestConfig) {
        return CloudAutodiscoveryApiFp(this.configuration).meCloudAutodiscoveryControllerAddDiscoveredDatabases(importCloudDatabasesDto, source, medium, campaign, amp, _package, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get databases belonging to subscriptions
     * @summary 
     * @param {DiscoverCloudDatabasesDto} discoverCloudDatabasesDto 
     * @param {string} [source] 
     * @param {string} [medium] 
     * @param {string} [campaign] 
     * @param {string} [amp] 
     * @param {string} [_package] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudAutodiscoveryApi
     */
    public meCloudAutodiscoveryControllerDiscoverDatabases(discoverCloudDatabasesDto: DiscoverCloudDatabasesDto, source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options?: RawAxiosRequestConfig) {
        return CloudAutodiscoveryApiFp(this.configuration).meCloudAutodiscoveryControllerDiscoverDatabases(discoverCloudDatabasesDto, source, medium, campaign, amp, _package, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about current accounts subscriptions.
     * @summary 
     * @param {string} [source] 
     * @param {string} [medium] 
     * @param {string} [campaign] 
     * @param {string} [amp] 
     * @param {string} [_package] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudAutodiscoveryApi
     */
    public meCloudAutodiscoveryControllerDiscoverSubscriptions(source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options?: RawAxiosRequestConfig) {
        return CloudAutodiscoveryApiFp(this.configuration).meCloudAutodiscoveryControllerDiscoverSubscriptions(source, medium, campaign, amp, _package, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current account
     * @summary 
     * @param {string} [source] 
     * @param {string} [medium] 
     * @param {string} [campaign] 
     * @param {string} [amp] 
     * @param {string} [_package] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudAutodiscoveryApi
     */
    public meCloudAutodiscoveryControllerGetAccount(source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options?: RawAxiosRequestConfig) {
        return CloudAutodiscoveryApiFp(this.configuration).meCloudAutodiscoveryControllerGetAccount(source, medium, campaign, amp, _package, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CloudCAPIKeysApi - axios parameter creator
 * @export
 */
export const CloudCAPIKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes user\'s capi keys by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudCapiKeyControllerDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cloudCapiKeyControllerDelete', 'id', id)
            const localVarPath = `/api/cloud/me/capi-keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes all user\'s capi keys
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudCapiKeyControllerDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cloud/me/capi-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return list of user\'s existing capi keys
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudCapiKeyControllerList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cloud/me/capi-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudCAPIKeysApi - functional programming interface
 * @export
 */
export const CloudCAPIKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudCAPIKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * Removes user\'s capi keys by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudCapiKeyControllerDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudCapiKeyControllerDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudCAPIKeysApi.cloudCapiKeyControllerDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes all user\'s capi keys
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudCapiKeyControllerDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudCapiKeyControllerDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudCAPIKeysApi.cloudCapiKeyControllerDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return list of user\'s existing capi keys
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudCapiKeyControllerList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CloudCapiKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudCapiKeyControllerList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudCAPIKeysApi.cloudCapiKeyControllerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CloudCAPIKeysApi - factory interface
 * @export
 */
export const CloudCAPIKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudCAPIKeysApiFp(configuration)
    return {
        /**
         * Removes user\'s capi keys by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudCapiKeyControllerDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cloudCapiKeyControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes all user\'s capi keys
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudCapiKeyControllerDeleteAll(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cloudCapiKeyControllerDeleteAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Return list of user\'s existing capi keys
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudCapiKeyControllerList(options?: RawAxiosRequestConfig): AxiosPromise<Array<CloudCapiKey>> {
            return localVarFp.cloudCapiKeyControllerList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudCAPIKeysApi - object-oriented interface
 * @export
 * @class CloudCAPIKeysApi
 * @extends {BaseAPI}
 */
export class CloudCAPIKeysApi extends BaseAPI {
    /**
     * Removes user\'s capi keys by id
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudCAPIKeysApi
     */
    public cloudCapiKeyControllerDelete(id: string, options?: RawAxiosRequestConfig) {
        return CloudCAPIKeysApiFp(this.configuration).cloudCapiKeyControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes all user\'s capi keys
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudCAPIKeysApi
     */
    public cloudCapiKeyControllerDeleteAll(options?: RawAxiosRequestConfig) {
        return CloudCAPIKeysApiFp(this.configuration).cloudCapiKeyControllerDeleteAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return list of user\'s existing capi keys
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudCAPIKeysApi
     */
    public cloudCapiKeyControllerList(options?: RawAxiosRequestConfig) {
        return CloudCAPIKeysApiFp(this.configuration).cloudCapiKeyControllerList(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CloudJobsApi - axios parameter creator
 * @export
 */
export const CloudJobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create cloud job
         * @summary 
         * @param {CreateCloudJobDto} createCloudJobDto 
         * @param {string} [source] 
         * @param {string} [medium] 
         * @param {string} [campaign] 
         * @param {string} [amp] 
         * @param {string} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudJobControllerCreateFreeDatabase: async (createCloudJobDto: CreateCloudJobDto, source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCloudJobDto' is not null or undefined
            assertParamExists('cloudJobControllerCreateFreeDatabase', 'createCloudJobDto', createCloudJobDto)
            const localVarPath = `/api/cloud/me/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (medium !== undefined) {
                localVarQueryParameter['medium'] = medium;
            }

            if (campaign !== undefined) {
                localVarQueryParameter['campaign'] = campaign;
            }

            if (amp !== undefined) {
                localVarQueryParameter['amp'] = amp;
            }

            if (_package !== undefined) {
                localVarQueryParameter['package'] = _package;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCloudJobDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user jobs
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudJobControllerGetJobInfo: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cloudJobControllerGetJobInfo', 'id', id)
            const localVarPath = `/api/cloud/me/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of user jobs
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudJobControllerGetUserJobsInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cloud/me/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudJobsApi - functional programming interface
 * @export
 */
export const CloudJobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudJobsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create cloud job
         * @summary 
         * @param {CreateCloudJobDto} createCloudJobDto 
         * @param {string} [source] 
         * @param {string} [medium] 
         * @param {string} [campaign] 
         * @param {string} [amp] 
         * @param {string} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudJobControllerCreateFreeDatabase(createCloudJobDto: CreateCloudJobDto, source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudJobInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudJobControllerCreateFreeDatabase(createCloudJobDto, source, medium, campaign, amp, _package, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudJobsApi.cloudJobControllerCreateFreeDatabase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user jobs
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudJobControllerGetJobInfo(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudJobInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudJobControllerGetJobInfo(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudJobsApi.cloudJobControllerGetJobInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of user jobs
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudJobControllerGetUserJobsInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CloudJobInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudJobControllerGetUserJobsInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudJobsApi.cloudJobControllerGetUserJobsInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CloudJobsApi - factory interface
 * @export
 */
export const CloudJobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudJobsApiFp(configuration)
    return {
        /**
         * Create cloud job
         * @summary 
         * @param {CreateCloudJobDto} createCloudJobDto 
         * @param {string} [source] 
         * @param {string} [medium] 
         * @param {string} [campaign] 
         * @param {string} [amp] 
         * @param {string} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudJobControllerCreateFreeDatabase(createCloudJobDto: CreateCloudJobDto, source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options?: RawAxiosRequestConfig): AxiosPromise<CloudJobInfo> {
            return localVarFp.cloudJobControllerCreateFreeDatabase(createCloudJobDto, source, medium, campaign, amp, _package, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user jobs
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudJobControllerGetJobInfo(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CloudJobInfo> {
            return localVarFp.cloudJobControllerGetJobInfo(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of user jobs
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudJobControllerGetUserJobsInfo(options?: RawAxiosRequestConfig): AxiosPromise<Array<CloudJobInfo>> {
            return localVarFp.cloudJobControllerGetUserJobsInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudJobsApi - object-oriented interface
 * @export
 * @class CloudJobsApi
 * @extends {BaseAPI}
 */
export class CloudJobsApi extends BaseAPI {
    /**
     * Create cloud job
     * @summary 
     * @param {CreateCloudJobDto} createCloudJobDto 
     * @param {string} [source] 
     * @param {string} [medium] 
     * @param {string} [campaign] 
     * @param {string} [amp] 
     * @param {string} [_package] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudJobsApi
     */
    public cloudJobControllerCreateFreeDatabase(createCloudJobDto: CreateCloudJobDto, source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options?: RawAxiosRequestConfig) {
        return CloudJobsApiFp(this.configuration).cloudJobControllerCreateFreeDatabase(createCloudJobDto, source, medium, campaign, amp, _package, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user jobs
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudJobsApi
     */
    public cloudJobControllerGetJobInfo(id: string, options?: RawAxiosRequestConfig) {
        return CloudJobsApiFp(this.configuration).cloudJobControllerGetJobInfo(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of user jobs
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudJobsApi
     */
    public cloudJobControllerGetUserJobsInfo(options?: RawAxiosRequestConfig) {
        return CloudJobsApiFp(this.configuration).cloudJobControllerGetUserJobsInfo(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CloudSubscriptionApi - axios parameter creator
 * @export
 */
export const CloudSubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get list of plans with cloud regions
         * @summary 
         * @param {string} [source] 
         * @param {string} [medium] 
         * @param {string} [campaign] 
         * @param {string} [amp] 
         * @param {string} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudSubscriptionControllerGetPlans: async (source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cloud/me/subscription/plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (medium !== undefined) {
                localVarQueryParameter['medium'] = medium;
            }

            if (campaign !== undefined) {
                localVarQueryParameter['campaign'] = campaign;
            }

            if (amp !== undefined) {
                localVarQueryParameter['amp'] = amp;
            }

            if (_package !== undefined) {
                localVarQueryParameter['package'] = _package;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudSubscriptionApi - functional programming interface
 * @export
 */
export const CloudSubscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudSubscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * Get list of plans with cloud regions
         * @summary 
         * @param {string} [source] 
         * @param {string} [medium] 
         * @param {string} [campaign] 
         * @param {string} [amp] 
         * @param {string} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudSubscriptionControllerGetPlans(source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CloudSubscriptionPlanResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudSubscriptionControllerGetPlans(source, medium, campaign, amp, _package, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudSubscriptionApi.cloudSubscriptionControllerGetPlans']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CloudSubscriptionApi - factory interface
 * @export
 */
export const CloudSubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudSubscriptionApiFp(configuration)
    return {
        /**
         * Get list of plans with cloud regions
         * @summary 
         * @param {string} [source] 
         * @param {string} [medium] 
         * @param {string} [campaign] 
         * @param {string} [amp] 
         * @param {string} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudSubscriptionControllerGetPlans(source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CloudSubscriptionPlanResponse>> {
            return localVarFp.cloudSubscriptionControllerGetPlans(source, medium, campaign, amp, _package, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudSubscriptionApi - object-oriented interface
 * @export
 * @class CloudSubscriptionApi
 * @extends {BaseAPI}
 */
export class CloudSubscriptionApi extends BaseAPI {
    /**
     * Get list of plans with cloud regions
     * @summary 
     * @param {string} [source] 
     * @param {string} [medium] 
     * @param {string} [campaign] 
     * @param {string} [amp] 
     * @param {string} [_package] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudSubscriptionApi
     */
    public cloudSubscriptionControllerGetPlans(source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options?: RawAxiosRequestConfig) {
        return CloudSubscriptionApiFp(this.configuration).cloudSubscriptionControllerGetPlans(source, medium, campaign, amp, _package, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CloudUserApi - axios parameter creator
 * @export
 */
export const CloudUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Logout user
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudUserControllerLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cloud/me/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return user general info with accounts list
         * @summary 
         * @param {string} [source] 
         * @param {string} [medium] 
         * @param {string} [campaign] 
         * @param {string} [amp] 
         * @param {string} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudUserControllerMe: async (source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cloud/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (medium !== undefined) {
                localVarQueryParameter['medium'] = medium;
            }

            if (campaign !== undefined) {
                localVarQueryParameter['campaign'] = campaign;
            }

            if (amp !== undefined) {
                localVarQueryParameter['amp'] = amp;
            }

            if (_package !== undefined) {
                localVarQueryParameter['package'] = _package;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activate user account
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudUserControllerSetCurrentAccount: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cloudUserControllerSetCurrentAccount', 'id', id)
            const localVarPath = `/api/cloud/me/accounts/{id}/current`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudUserApi - functional programming interface
 * @export
 */
export const CloudUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudUserApiAxiosParamCreator(configuration)
    return {
        /**
         * Logout user
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudUserControllerLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudUserControllerLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudUserApi.cloudUserControllerLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return user general info with accounts list
         * @summary 
         * @param {string} [source] 
         * @param {string} [medium] 
         * @param {string} [campaign] 
         * @param {string} [amp] 
         * @param {string} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudUserControllerMe(source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudUserControllerMe(source, medium, campaign, amp, _package, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudUserApi.cloudUserControllerMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Activate user account
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudUserControllerSetCurrentAccount(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudUserControllerSetCurrentAccount(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudUserApi.cloudUserControllerSetCurrentAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CloudUserApi - factory interface
 * @export
 */
export const CloudUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudUserApiFp(configuration)
    return {
        /**
         * Logout user
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudUserControllerLogout(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cloudUserControllerLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * Return user general info with accounts list
         * @summary 
         * @param {string} [source] 
         * @param {string} [medium] 
         * @param {string} [campaign] 
         * @param {string} [amp] 
         * @param {string} [_package] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudUserControllerMe(source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options?: RawAxiosRequestConfig): AxiosPromise<CloudUser> {
            return localVarFp.cloudUserControllerMe(source, medium, campaign, amp, _package, options).then((request) => request(axios, basePath));
        },
        /**
         * Activate user account
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudUserControllerSetCurrentAccount(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CloudUser> {
            return localVarFp.cloudUserControllerSetCurrentAccount(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudUserApi - object-oriented interface
 * @export
 * @class CloudUserApi
 * @extends {BaseAPI}
 */
export class CloudUserApi extends BaseAPI {
    /**
     * Logout user
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudUserApi
     */
    public cloudUserControllerLogout(options?: RawAxiosRequestConfig) {
        return CloudUserApiFp(this.configuration).cloudUserControllerLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return user general info with accounts list
     * @summary 
     * @param {string} [source] 
     * @param {string} [medium] 
     * @param {string} [campaign] 
     * @param {string} [amp] 
     * @param {string} [_package] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudUserApi
     */
    public cloudUserControllerMe(source?: string, medium?: string, campaign?: string, amp?: string, _package?: string, options?: RawAxiosRequestConfig) {
        return CloudUserApiFp(this.configuration).cloudUserControllerMe(source, medium, campaign, amp, _package, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activate user account
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudUserApi
     */
    public cloudUserControllerSetCurrentAccount(id: string, options?: RawAxiosRequestConfig) {
        return CloudUserApiFp(this.configuration).cloudUserControllerSetCurrentAccount(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClusterMonitorApi - axios parameter creator
 * @export
 */
export const ClusterMonitorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get cluster details
         * @summary 
         * @param {string} dbInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterMonitorControllerGetClusterDetails: async (dbInstance: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('clusterMonitorControllerGetClusterDetails', 'dbInstance', dbInstance)
            const localVarPath = `/api/databases/{dbInstance}/cluster-details`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClusterMonitorApi - functional programming interface
 * @export
 */
export const ClusterMonitorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClusterMonitorApiAxiosParamCreator(configuration)
    return {
        /**
         * Get cluster details
         * @summary 
         * @param {string} dbInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterMonitorControllerGetClusterDetails(dbInstance: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusterMonitorControllerGetClusterDetails(dbInstance, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterMonitorApi.clusterMonitorControllerGetClusterDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClusterMonitorApi - factory interface
 * @export
 */
export const ClusterMonitorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClusterMonitorApiFp(configuration)
    return {
        /**
         * Get cluster details
         * @summary 
         * @param {string} dbInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterMonitorControllerGetClusterDetails(dbInstance: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterDetails> {
            return localVarFp.clusterMonitorControllerGetClusterDetails(dbInstance, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClusterMonitorApi - object-oriented interface
 * @export
 * @class ClusterMonitorApi
 * @extends {BaseAPI}
 */
export class ClusterMonitorApi extends BaseAPI {
    /**
     * Get cluster details
     * @summary 
     * @param {string} dbInstance 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterMonitorApi
     */
    public clusterMonitorControllerGetClusterDetails(dbInstance: string, options?: RawAxiosRequestConfig) {
        return ClusterMonitorApiFp(this.configuration).clusterMonitorControllerGetClusterDetails(dbInstance, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CommandsApi - axios parameter creator
 * @export
 */
export const CommandsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsControllerGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/commands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommandsApi - functional programming interface
 * @export
 */
export const CommandsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommandsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandsControllerGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commandsControllerGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandsApi.commandsControllerGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CommandsApi - factory interface
 * @export
 */
export const CommandsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommandsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsControllerGetAll(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.commandsControllerGetAll(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommandsApi - object-oriented interface
 * @export
 * @class CommandsApi
 * @extends {BaseAPI}
 */
export class CommandsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public commandsControllerGetAll(options?: RawAxiosRequestConfig) {
        return CommandsApiFp(this.configuration).commandsControllerGetAll(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatabaseApi - axios parameter creator
 * @export
 */
export const DatabaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete many databases by ids
         * @summary 
         * @param {DeleteDatabasesDto} deleteDatabasesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerBulkDeleteDatabaseInstance: async (deleteDatabasesDto: DeleteDatabasesDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteDatabasesDto' is not null or undefined
            assertParamExists('databaseControllerBulkDeleteDatabaseInstance', 'deleteDatabasesDto', deleteDatabasesDto)
            const localVarPath = `/api/databases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteDatabasesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update database instance by id
         * @summary 
         * @param {string} id 
         * @param {UpdateDatabaseDto} updateDatabaseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerClone: async (id: string, updateDatabaseDto: UpdateDatabaseDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('databaseControllerClone', 'id', id)
            // verify required parameter 'updateDatabaseDto' is not null or undefined
            assertParamExists('databaseControllerClone', 'updateDatabaseDto', updateDatabaseDto)
            const localVarPath = `/api/databases/clone/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDatabaseDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Connect to database instance by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerConnect: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('databaseControllerConnect', 'id', id)
            const localVarPath = `/api/databases/{id}/connect`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add database instance
         * @summary 
         * @param {CreateDatabaseDto} createDatabaseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerCreate: async (createDatabaseDto: CreateDatabaseDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDatabaseDto' is not null or undefined
            assertParamExists('databaseControllerCreate', 'createDatabaseDto', createDatabaseDto)
            const localVarPath = `/api/databases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDatabaseDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete database instance by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerDeleteDatabaseInstance: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('databaseControllerDeleteDatabaseInstance', 'id', id)
            const localVarPath = `/api/databases/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export many databases by ids. With or without passwords and certificates bodies.
         * @summary 
         * @param {ExportDatabasesDto} exportDatabasesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerExportConnections: async (exportDatabasesDto: ExportDatabasesDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportDatabasesDto' is not null or undefined
            assertParamExists('databaseControllerExportConnections', 'exportDatabasesDto', exportDatabasesDto)
            const localVarPath = `/api/databases/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportDatabasesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get database instance by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('databaseControllerGet', 'id', id)
            const localVarPath = `/api/databases/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get databases list
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/databases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connection
         * @summary 
         * @param {CreateDatabaseDto} createDatabaseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerTestConnection: async (createDatabaseDto: CreateDatabaseDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDatabaseDto' is not null or undefined
            assertParamExists('databaseControllerTestConnection', 'createDatabaseDto', createDatabaseDto)
            const localVarPath = `/api/databases/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDatabaseDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connection
         * @summary 
         * @param {string} id 
         * @param {UpdateDatabaseDto} updateDatabaseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerTestExistConnection: async (id: string, updateDatabaseDto: UpdateDatabaseDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('databaseControllerTestExistConnection', 'id', id)
            // verify required parameter 'updateDatabaseDto' is not null or undefined
            assertParamExists('databaseControllerTestExistConnection', 'updateDatabaseDto', updateDatabaseDto)
            const localVarPath = `/api/databases/test/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDatabaseDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update database instance by id
         * @summary 
         * @param {string} id 
         * @param {UpdateDatabaseDto} updateDatabaseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerUpdate: async (id: string, updateDatabaseDto: UpdateDatabaseDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('databaseControllerUpdate', 'id', id)
            // verify required parameter 'updateDatabaseDto' is not null or undefined
            assertParamExists('databaseControllerUpdate', 'updateDatabaseDto', updateDatabaseDto)
            const localVarPath = `/api/databases/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDatabaseDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseImportControllerImport: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/databases/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseApi - functional programming interface
 * @export
 */
export const DatabaseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete many databases by ids
         * @summary 
         * @param {DeleteDatabasesDto} deleteDatabasesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseControllerBulkDeleteDatabaseInstance(deleteDatabasesDto: DeleteDatabasesDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteDatabasesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseControllerBulkDeleteDatabaseInstance(deleteDatabasesDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseApi.databaseControllerBulkDeleteDatabaseInstance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update database instance by id
         * @summary 
         * @param {string} id 
         * @param {UpdateDatabaseDto} updateDatabaseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseControllerClone(id: string, updateDatabaseDto: UpdateDatabaseDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseControllerClone(id, updateDatabaseDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseApi.databaseControllerClone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Connect to database instance by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseControllerConnect(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseControllerConnect(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseApi.databaseControllerConnect']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add database instance
         * @summary 
         * @param {CreateDatabaseDto} createDatabaseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseControllerCreate(createDatabaseDto: CreateDatabaseDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseControllerCreate(createDatabaseDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseApi.databaseControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete database instance by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseControllerDeleteDatabaseInstance(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseControllerDeleteDatabaseInstance(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseApi.databaseControllerDeleteDatabaseInstance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Export many databases by ids. With or without passwords and certificates bodies.
         * @summary 
         * @param {ExportDatabasesDto} exportDatabasesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseControllerExportConnections(exportDatabasesDto: ExportDatabasesDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportDatabase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseControllerExportConnections(exportDatabasesDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseApi.databaseControllerExportConnections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get database instance by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseControllerGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseControllerGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseApi.databaseControllerGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get databases list
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseControllerList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Database>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseControllerList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseApi.databaseControllerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test connection
         * @summary 
         * @param {CreateDatabaseDto} createDatabaseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseControllerTestConnection(createDatabaseDto: CreateDatabaseDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseControllerTestConnection(createDatabaseDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseApi.databaseControllerTestConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test connection
         * @summary 
         * @param {string} id 
         * @param {UpdateDatabaseDto} updateDatabaseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseControllerTestExistConnection(id: string, updateDatabaseDto: UpdateDatabaseDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseControllerTestExistConnection(id, updateDatabaseDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseApi.databaseControllerTestExistConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update database instance by id
         * @summary 
         * @param {string} id 
         * @param {UpdateDatabaseDto} updateDatabaseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseControllerUpdate(id: string, updateDatabaseDto: UpdateDatabaseDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseControllerUpdate(id, updateDatabaseDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseApi.databaseControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseImportControllerImport(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseImportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseImportControllerImport(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseApi.databaseImportControllerImport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DatabaseApi - factory interface
 * @export
 */
export const DatabaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseApiFp(configuration)
    return {
        /**
         * Delete many databases by ids
         * @summary 
         * @param {DeleteDatabasesDto} deleteDatabasesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerBulkDeleteDatabaseInstance(deleteDatabasesDto: DeleteDatabasesDto, options?: RawAxiosRequestConfig): AxiosPromise<DeleteDatabasesDto> {
            return localVarFp.databaseControllerBulkDeleteDatabaseInstance(deleteDatabasesDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update database instance by id
         * @summary 
         * @param {string} id 
         * @param {UpdateDatabaseDto} updateDatabaseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerClone(id: string, updateDatabaseDto: UpdateDatabaseDto, options?: RawAxiosRequestConfig): AxiosPromise<DatabaseResponse> {
            return localVarFp.databaseControllerClone(id, updateDatabaseDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Connect to database instance by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerConnect(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.databaseControllerConnect(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Add database instance
         * @summary 
         * @param {CreateDatabaseDto} createDatabaseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerCreate(createDatabaseDto: CreateDatabaseDto, options?: RawAxiosRequestConfig): AxiosPromise<DatabaseResponse> {
            return localVarFp.databaseControllerCreate(createDatabaseDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete database instance by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerDeleteDatabaseInstance(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.databaseControllerDeleteDatabaseInstance(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Export many databases by ids. With or without passwords and certificates bodies.
         * @summary 
         * @param {ExportDatabasesDto} exportDatabasesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerExportConnections(exportDatabasesDto: ExportDatabasesDto, options?: RawAxiosRequestConfig): AxiosPromise<ExportDatabase> {
            return localVarFp.databaseControllerExportConnections(exportDatabasesDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Get database instance by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DatabaseResponse> {
            return localVarFp.databaseControllerGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get databases list
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Database>> {
            return localVarFp.databaseControllerList(options).then((request) => request(axios, basePath));
        },
        /**
         * Test connection
         * @summary 
         * @param {CreateDatabaseDto} createDatabaseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerTestConnection(createDatabaseDto: CreateDatabaseDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.databaseControllerTestConnection(createDatabaseDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Test connection
         * @summary 
         * @param {string} id 
         * @param {UpdateDatabaseDto} updateDatabaseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerTestExistConnection(id: string, updateDatabaseDto: UpdateDatabaseDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.databaseControllerTestExistConnection(id, updateDatabaseDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update database instance by id
         * @summary 
         * @param {string} id 
         * @param {UpdateDatabaseDto} updateDatabaseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseControllerUpdate(id: string, updateDatabaseDto: UpdateDatabaseDto, options?: RawAxiosRequestConfig): AxiosPromise<DatabaseResponse> {
            return localVarFp.databaseControllerUpdate(id, updateDatabaseDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseImportControllerImport(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<DatabaseImportResponse> {
            return localVarFp.databaseImportControllerImport(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseApi - object-oriented interface
 * @export
 * @class DatabaseApi
 * @extends {BaseAPI}
 */
export class DatabaseApi extends BaseAPI {
    /**
     * Delete many databases by ids
     * @summary 
     * @param {DeleteDatabasesDto} deleteDatabasesDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public databaseControllerBulkDeleteDatabaseInstance(deleteDatabasesDto: DeleteDatabasesDto, options?: RawAxiosRequestConfig) {
        return DatabaseApiFp(this.configuration).databaseControllerBulkDeleteDatabaseInstance(deleteDatabasesDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update database instance by id
     * @summary 
     * @param {string} id 
     * @param {UpdateDatabaseDto} updateDatabaseDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public databaseControllerClone(id: string, updateDatabaseDto: UpdateDatabaseDto, options?: RawAxiosRequestConfig) {
        return DatabaseApiFp(this.configuration).databaseControllerClone(id, updateDatabaseDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Connect to database instance by id
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public databaseControllerConnect(id: string, options?: RawAxiosRequestConfig) {
        return DatabaseApiFp(this.configuration).databaseControllerConnect(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add database instance
     * @summary 
     * @param {CreateDatabaseDto} createDatabaseDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public databaseControllerCreate(createDatabaseDto: CreateDatabaseDto, options?: RawAxiosRequestConfig) {
        return DatabaseApiFp(this.configuration).databaseControllerCreate(createDatabaseDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete database instance by id
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public databaseControllerDeleteDatabaseInstance(id: string, options?: RawAxiosRequestConfig) {
        return DatabaseApiFp(this.configuration).databaseControllerDeleteDatabaseInstance(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export many databases by ids. With or without passwords and certificates bodies.
     * @summary 
     * @param {ExportDatabasesDto} exportDatabasesDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public databaseControllerExportConnections(exportDatabasesDto: ExportDatabasesDto, options?: RawAxiosRequestConfig) {
        return DatabaseApiFp(this.configuration).databaseControllerExportConnections(exportDatabasesDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get database instance by id
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public databaseControllerGet(id: string, options?: RawAxiosRequestConfig) {
        return DatabaseApiFp(this.configuration).databaseControllerGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get databases list
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public databaseControllerList(options?: RawAxiosRequestConfig) {
        return DatabaseApiFp(this.configuration).databaseControllerList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connection
     * @summary 
     * @param {CreateDatabaseDto} createDatabaseDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public databaseControllerTestConnection(createDatabaseDto: CreateDatabaseDto, options?: RawAxiosRequestConfig) {
        return DatabaseApiFp(this.configuration).databaseControllerTestConnection(createDatabaseDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connection
     * @summary 
     * @param {string} id 
     * @param {UpdateDatabaseDto} updateDatabaseDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public databaseControllerTestExistConnection(id: string, updateDatabaseDto: UpdateDatabaseDto, options?: RawAxiosRequestConfig) {
        return DatabaseApiFp(this.configuration).databaseControllerTestExistConnection(id, updateDatabaseDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update database instance by id
     * @summary 
     * @param {string} id 
     * @param {UpdateDatabaseDto} updateDatabaseDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public databaseControllerUpdate(id: string, updateDatabaseDto: UpdateDatabaseDto, options?: RawAxiosRequestConfig) {
        return DatabaseApiFp(this.configuration).databaseControllerUpdate(id, updateDatabaseDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public databaseImportControllerImport(file?: File, options?: RawAxiosRequestConfig) {
        return DatabaseApiFp(this.configuration).databaseImportControllerImport(file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatabaseAnalysisApi - axios parameter creator
 * @export
 */
export const DatabaseAnalysisApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new database analysis
         * @summary 
         * @param {string} dbInstance 
         * @param {DatabaseAnalysisControllerCreateEncodingEnum} encoding 
         * @param {CreateDatabaseAnalysisDto} createDatabaseAnalysisDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseAnalysisControllerCreate: async (dbInstance: string, encoding: DatabaseAnalysisControllerCreateEncodingEnum, createDatabaseAnalysisDto: CreateDatabaseAnalysisDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('databaseAnalysisControllerCreate', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('databaseAnalysisControllerCreate', 'encoding', encoding)
            // verify required parameter 'createDatabaseAnalysisDto' is not null or undefined
            assertParamExists('databaseAnalysisControllerCreate', 'createDatabaseAnalysisDto', createDatabaseAnalysisDto)
            const localVarPath = `/api/databases/{dbInstance}/analysis`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDatabaseAnalysisDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get database analysis
         * @summary 
         * @param {string} id Analysis id
         * @param {string} dbInstance Database instance id
         * @param {DatabaseAnalysisControllerGetEncodingEnum} encoding 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseAnalysisControllerGet: async (id: string, dbInstance: string, encoding: DatabaseAnalysisControllerGetEncodingEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('databaseAnalysisControllerGet', 'id', id)
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('databaseAnalysisControllerGet', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('databaseAnalysisControllerGet', 'encoding', encoding)
            const localVarPath = `/api/databases/{dbInstance}/analysis/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get database analysis list
         * @summary 
         * @param {string} dbInstance Database instance id
         * @param {DatabaseAnalysisControllerListEncodingEnum} encoding 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseAnalysisControllerList: async (dbInstance: string, encoding: DatabaseAnalysisControllerListEncodingEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('databaseAnalysisControllerList', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('databaseAnalysisControllerList', 'encoding', encoding)
            const localVarPath = `/api/databases/{dbInstance}/analysis`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update database analysis by id
         * @summary 
         * @param {string} id Analysis id
         * @param {string} dbInstance Database instance id
         * @param {RecommendationVoteDto} recommendationVoteDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseAnalysisControllerModify: async (id: string, dbInstance: string, recommendationVoteDto: RecommendationVoteDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('databaseAnalysisControllerModify', 'id', id)
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('databaseAnalysisControllerModify', 'dbInstance', dbInstance)
            // verify required parameter 'recommendationVoteDto' is not null or undefined
            assertParamExists('databaseAnalysisControllerModify', 'recommendationVoteDto', recommendationVoteDto)
            const localVarPath = `/api/databases/{dbInstance}/analysis/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recommendationVoteDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseAnalysisApi - functional programming interface
 * @export
 */
export const DatabaseAnalysisApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseAnalysisApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new database analysis
         * @summary 
         * @param {string} dbInstance 
         * @param {DatabaseAnalysisControllerCreateEncodingEnum} encoding 
         * @param {CreateDatabaseAnalysisDto} createDatabaseAnalysisDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseAnalysisControllerCreate(dbInstance: string, encoding: DatabaseAnalysisControllerCreateEncodingEnum, createDatabaseAnalysisDto: CreateDatabaseAnalysisDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseAnalysis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseAnalysisControllerCreate(dbInstance, encoding, createDatabaseAnalysisDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseAnalysisApi.databaseAnalysisControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get database analysis
         * @summary 
         * @param {string} id Analysis id
         * @param {string} dbInstance Database instance id
         * @param {DatabaseAnalysisControllerGetEncodingEnum} encoding 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseAnalysisControllerGet(id: string, dbInstance: string, encoding: DatabaseAnalysisControllerGetEncodingEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseAnalysis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseAnalysisControllerGet(id, dbInstance, encoding, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseAnalysisApi.databaseAnalysisControllerGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get database analysis list
         * @summary 
         * @param {string} dbInstance Database instance id
         * @param {DatabaseAnalysisControllerListEncodingEnum} encoding 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseAnalysisControllerList(dbInstance: string, encoding: DatabaseAnalysisControllerListEncodingEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ShortDatabaseAnalysis>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseAnalysisControllerList(dbInstance, encoding, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseAnalysisApi.databaseAnalysisControllerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update database analysis by id
         * @summary 
         * @param {string} id Analysis id
         * @param {string} dbInstance Database instance id
         * @param {RecommendationVoteDto} recommendationVoteDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseAnalysisControllerModify(id: string, dbInstance: string, recommendationVoteDto: RecommendationVoteDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseAnalysis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseAnalysisControllerModify(id, dbInstance, recommendationVoteDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseAnalysisApi.databaseAnalysisControllerModify']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DatabaseAnalysisApi - factory interface
 * @export
 */
export const DatabaseAnalysisApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseAnalysisApiFp(configuration)
    return {
        /**
         * Create new database analysis
         * @summary 
         * @param {string} dbInstance 
         * @param {DatabaseAnalysisControllerCreateEncodingEnum} encoding 
         * @param {CreateDatabaseAnalysisDto} createDatabaseAnalysisDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseAnalysisControllerCreate(dbInstance: string, encoding: DatabaseAnalysisControllerCreateEncodingEnum, createDatabaseAnalysisDto: CreateDatabaseAnalysisDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<DatabaseAnalysis> {
            return localVarFp.databaseAnalysisControllerCreate(dbInstance, encoding, createDatabaseAnalysisDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get database analysis
         * @summary 
         * @param {string} id Analysis id
         * @param {string} dbInstance Database instance id
         * @param {DatabaseAnalysisControllerGetEncodingEnum} encoding 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseAnalysisControllerGet(id: string, dbInstance: string, encoding: DatabaseAnalysisControllerGetEncodingEnum, options?: RawAxiosRequestConfig): AxiosPromise<DatabaseAnalysis> {
            return localVarFp.databaseAnalysisControllerGet(id, dbInstance, encoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Get database analysis list
         * @summary 
         * @param {string} dbInstance Database instance id
         * @param {DatabaseAnalysisControllerListEncodingEnum} encoding 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseAnalysisControllerList(dbInstance: string, encoding: DatabaseAnalysisControllerListEncodingEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<ShortDatabaseAnalysis>> {
            return localVarFp.databaseAnalysisControllerList(dbInstance, encoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Update database analysis by id
         * @summary 
         * @param {string} id Analysis id
         * @param {string} dbInstance Database instance id
         * @param {RecommendationVoteDto} recommendationVoteDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseAnalysisControllerModify(id: string, dbInstance: string, recommendationVoteDto: RecommendationVoteDto, options?: RawAxiosRequestConfig): AxiosPromise<DatabaseAnalysis> {
            return localVarFp.databaseAnalysisControllerModify(id, dbInstance, recommendationVoteDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseAnalysisApi - object-oriented interface
 * @export
 * @class DatabaseAnalysisApi
 * @extends {BaseAPI}
 */
export class DatabaseAnalysisApi extends BaseAPI {
    /**
     * Create new database analysis
     * @summary 
     * @param {string} dbInstance 
     * @param {DatabaseAnalysisControllerCreateEncodingEnum} encoding 
     * @param {CreateDatabaseAnalysisDto} createDatabaseAnalysisDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseAnalysisApi
     */
    public databaseAnalysisControllerCreate(dbInstance: string, encoding: DatabaseAnalysisControllerCreateEncodingEnum, createDatabaseAnalysisDto: CreateDatabaseAnalysisDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return DatabaseAnalysisApiFp(this.configuration).databaseAnalysisControllerCreate(dbInstance, encoding, createDatabaseAnalysisDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get database analysis
     * @summary 
     * @param {string} id Analysis id
     * @param {string} dbInstance Database instance id
     * @param {DatabaseAnalysisControllerGetEncodingEnum} encoding 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseAnalysisApi
     */
    public databaseAnalysisControllerGet(id: string, dbInstance: string, encoding: DatabaseAnalysisControllerGetEncodingEnum, options?: RawAxiosRequestConfig) {
        return DatabaseAnalysisApiFp(this.configuration).databaseAnalysisControllerGet(id, dbInstance, encoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get database analysis list
     * @summary 
     * @param {string} dbInstance Database instance id
     * @param {DatabaseAnalysisControllerListEncodingEnum} encoding 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseAnalysisApi
     */
    public databaseAnalysisControllerList(dbInstance: string, encoding: DatabaseAnalysisControllerListEncodingEnum, options?: RawAxiosRequestConfig) {
        return DatabaseAnalysisApiFp(this.configuration).databaseAnalysisControllerList(dbInstance, encoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update database analysis by id
     * @summary 
     * @param {string} id Analysis id
     * @param {string} dbInstance Database instance id
     * @param {RecommendationVoteDto} recommendationVoteDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseAnalysisApi
     */
    public databaseAnalysisControllerModify(id: string, dbInstance: string, recommendationVoteDto: RecommendationVoteDto, options?: RawAxiosRequestConfig) {
        return DatabaseAnalysisApiFp(this.configuration).databaseAnalysisControllerModify(id, dbInstance, recommendationVoteDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DatabaseAnalysisControllerCreateEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type DatabaseAnalysisControllerCreateEncodingEnum = typeof DatabaseAnalysisControllerCreateEncodingEnum[keyof typeof DatabaseAnalysisControllerCreateEncodingEnum];
/**
 * @export
 */
export const DatabaseAnalysisControllerGetEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type DatabaseAnalysisControllerGetEncodingEnum = typeof DatabaseAnalysisControllerGetEncodingEnum[keyof typeof DatabaseAnalysisControllerGetEncodingEnum];
/**
 * @export
 */
export const DatabaseAnalysisControllerListEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type DatabaseAnalysisControllerListEncodingEnum = typeof DatabaseAnalysisControllerListEncodingEnum[keyof typeof DatabaseAnalysisControllerListEncodingEnum];


/**
 * DatabaseDatabaseSettingsApi - axios parameter creator
 * @export
 */
export const DatabaseDatabaseSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update database settings
         * @summary 
         * @param {string} dbInstance 
         * @param {CreateOrUpdateDatabaseSettingDto} createOrUpdateDatabaseSettingDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseSettingsControllerCreate: async (dbInstance: string, createOrUpdateDatabaseSettingDto: CreateOrUpdateDatabaseSettingDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('databaseSettingsControllerCreate', 'dbInstance', dbInstance)
            // verify required parameter 'createOrUpdateDatabaseSettingDto' is not null or undefined
            assertParamExists('databaseSettingsControllerCreate', 'createOrUpdateDatabaseSettingDto', createOrUpdateDatabaseSettingDto)
            const localVarPath = `/api/databases/{dbInstance}/settings`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrUpdateDatabaseSettingDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete database settings
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseSettingsControllerDelete: async (dbInstance: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('databaseSettingsControllerDelete', 'dbInstance', dbInstance)
            const localVarPath = `/api/databases/{dbInstance}/settings`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get database settings
         * @summary 
         * @param {string} dbInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseSettingsControllerGet: async (dbInstance: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('databaseSettingsControllerGet', 'dbInstance', dbInstance)
            const localVarPath = `/api/databases/{dbInstance}/settings`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseDatabaseSettingsApi - functional programming interface
 * @export
 */
export const DatabaseDatabaseSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseDatabaseSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Update database settings
         * @summary 
         * @param {string} dbInstance 
         * @param {CreateOrUpdateDatabaseSettingDto} createOrUpdateDatabaseSettingDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseSettingsControllerCreate(dbInstance: string, createOrUpdateDatabaseSettingDto: CreateOrUpdateDatabaseSettingDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseSettingsControllerCreate(dbInstance, createOrUpdateDatabaseSettingDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseDatabaseSettingsApi.databaseSettingsControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete database settings
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseSettingsControllerDelete(dbInstance: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseSettingsControllerDelete(dbInstance, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseDatabaseSettingsApi.databaseSettingsControllerDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get database settings
         * @summary 
         * @param {string} dbInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseSettingsControllerGet(dbInstance: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseSettingsControllerGet(dbInstance, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseDatabaseSettingsApi.databaseSettingsControllerGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DatabaseDatabaseSettingsApi - factory interface
 * @export
 */
export const DatabaseDatabaseSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseDatabaseSettingsApiFp(configuration)
    return {
        /**
         * Update database settings
         * @summary 
         * @param {string} dbInstance 
         * @param {CreateOrUpdateDatabaseSettingDto} createOrUpdateDatabaseSettingDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseSettingsControllerCreate(dbInstance: string, createOrUpdateDatabaseSettingDto: CreateOrUpdateDatabaseSettingDto, options?: RawAxiosRequestConfig): AxiosPromise<DatabaseSettings> {
            return localVarFp.databaseSettingsControllerCreate(dbInstance, createOrUpdateDatabaseSettingDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete database settings
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseSettingsControllerDelete(dbInstance: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.databaseSettingsControllerDelete(dbInstance, options).then((request) => request(axios, basePath));
        },
        /**
         * Get database settings
         * @summary 
         * @param {string} dbInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseSettingsControllerGet(dbInstance: string, options?: RawAxiosRequestConfig): AxiosPromise<DatabaseSettings> {
            return localVarFp.databaseSettingsControllerGet(dbInstance, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseDatabaseSettingsApi - object-oriented interface
 * @export
 * @class DatabaseDatabaseSettingsApi
 * @extends {BaseAPI}
 */
export class DatabaseDatabaseSettingsApi extends BaseAPI {
    /**
     * Update database settings
     * @summary 
     * @param {string} dbInstance 
     * @param {CreateOrUpdateDatabaseSettingDto} createOrUpdateDatabaseSettingDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseDatabaseSettingsApi
     */
    public databaseSettingsControllerCreate(dbInstance: string, createOrUpdateDatabaseSettingDto: CreateOrUpdateDatabaseSettingDto, options?: RawAxiosRequestConfig) {
        return DatabaseDatabaseSettingsApiFp(this.configuration).databaseSettingsControllerCreate(dbInstance, createOrUpdateDatabaseSettingDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete database settings
     * @summary 
     * @param {string} dbInstance Database instance id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseDatabaseSettingsApi
     */
    public databaseSettingsControllerDelete(dbInstance: string, options?: RawAxiosRequestConfig) {
        return DatabaseDatabaseSettingsApiFp(this.configuration).databaseSettingsControllerDelete(dbInstance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get database settings
     * @summary 
     * @param {string} dbInstance 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseDatabaseSettingsApi
     */
    public databaseSettingsControllerGet(dbInstance: string, options?: RawAxiosRequestConfig) {
        return DatabaseDatabaseSettingsApiFp(this.configuration).databaseSettingsControllerGet(dbInstance, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatabaseInstancesApi - axios parameter creator
 * @export
 */
export const DatabaseInstancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Try to create connection to specified database index
         * @summary 
         * @param {object} index 
         * @param {string} id 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseInfoControllerGetDatabaseIndex: async (index: object, id: string, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'index' is not null or undefined
            assertParamExists('databaseInfoControllerGetDatabaseIndex', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('databaseInfoControllerGetDatabaseIndex', 'id', id)
            const localVarPath = `/api/databases/{id}/db/{index}`
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Redis database overview
         * @summary 
         * @param {string} id 
         * @param {number} [riDbIndex] 
         * @param {DatabaseInfoControllerGetDatabaseOverviewKeyspaceEnum} [keyspace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseInfoControllerGetDatabaseOverview: async (id: string, riDbIndex?: number, keyspace?: DatabaseInfoControllerGetDatabaseOverviewKeyspaceEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('databaseInfoControllerGetDatabaseOverview', 'id', id)
            const localVarPath = `/api/databases/{id}/overview`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyspace !== undefined) {
                localVarQueryParameter['keyspace'] = keyspace;
            }


    
            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Redis database config info
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseInfoControllerGetInfo: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('databaseInfoControllerGetInfo', 'id', id)
            const localVarPath = `/api/databases/{id}/info`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseInstancesApi - functional programming interface
 * @export
 */
export const DatabaseInstancesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseInstancesApiAxiosParamCreator(configuration)
    return {
        /**
         * Try to create connection to specified database index
         * @summary 
         * @param {object} index 
         * @param {string} id 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseInfoControllerGetDatabaseIndex(index: object, id: string, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseInfoControllerGetDatabaseIndex(index, id, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseInstancesApi.databaseInfoControllerGetDatabaseIndex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Redis database overview
         * @summary 
         * @param {string} id 
         * @param {number} [riDbIndex] 
         * @param {DatabaseInfoControllerGetDatabaseOverviewKeyspaceEnum} [keyspace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseInfoControllerGetDatabaseOverview(id: string, riDbIndex?: number, keyspace?: DatabaseInfoControllerGetDatabaseOverviewKeyspaceEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseOverview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseInfoControllerGetDatabaseOverview(id, riDbIndex, keyspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseInstancesApi.databaseInfoControllerGetDatabaseOverview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Redis database config info
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseInfoControllerGetInfo(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RedisDatabaseInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseInfoControllerGetInfo(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseInstancesApi.databaseInfoControllerGetInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DatabaseInstancesApi - factory interface
 * @export
 */
export const DatabaseInstancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseInstancesApiFp(configuration)
    return {
        /**
         * Try to create connection to specified database index
         * @summary 
         * @param {object} index 
         * @param {string} id 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseInfoControllerGetDatabaseIndex(index: object, id: string, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.databaseInfoControllerGetDatabaseIndex(index, id, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Redis database overview
         * @summary 
         * @param {string} id 
         * @param {number} [riDbIndex] 
         * @param {DatabaseInfoControllerGetDatabaseOverviewKeyspaceEnum} [keyspace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseInfoControllerGetDatabaseOverview(id: string, riDbIndex?: number, keyspace?: DatabaseInfoControllerGetDatabaseOverviewKeyspaceEnum, options?: RawAxiosRequestConfig): AxiosPromise<DatabaseOverview> {
            return localVarFp.databaseInfoControllerGetDatabaseOverview(id, riDbIndex, keyspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Redis database config info
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseInfoControllerGetInfo(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RedisDatabaseInfoResponse> {
            return localVarFp.databaseInfoControllerGetInfo(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseInstancesApi - object-oriented interface
 * @export
 * @class DatabaseInstancesApi
 * @extends {BaseAPI}
 */
export class DatabaseInstancesApi extends BaseAPI {
    /**
     * Try to create connection to specified database index
     * @summary 
     * @param {object} index 
     * @param {string} id 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseInstancesApi
     */
    public databaseInfoControllerGetDatabaseIndex(index: object, id: string, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return DatabaseInstancesApiFp(this.configuration).databaseInfoControllerGetDatabaseIndex(index, id, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Redis database overview
     * @summary 
     * @param {string} id 
     * @param {number} [riDbIndex] 
     * @param {DatabaseInfoControllerGetDatabaseOverviewKeyspaceEnum} [keyspace] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseInstancesApi
     */
    public databaseInfoControllerGetDatabaseOverview(id: string, riDbIndex?: number, keyspace?: DatabaseInfoControllerGetDatabaseOverviewKeyspaceEnum, options?: RawAxiosRequestConfig) {
        return DatabaseInstancesApiFp(this.configuration).databaseInfoControllerGetDatabaseOverview(id, riDbIndex, keyspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Redis database config info
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseInstancesApi
     */
    public databaseInfoControllerGetInfo(id: string, options?: RawAxiosRequestConfig) {
        return DatabaseInstancesApiFp(this.configuration).databaseInfoControllerGetInfo(id, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DatabaseInfoControllerGetDatabaseOverviewKeyspaceEnum = {
    Full: 'full',
    Current: 'current'
} as const;
export type DatabaseInfoControllerGetDatabaseOverviewKeyspaceEnum = typeof DatabaseInfoControllerGetDatabaseOverviewKeyspaceEnum[keyof typeof DatabaseInfoControllerGetDatabaseOverviewKeyspaceEnum];


/**
 * DatabaseRecommendationsApi - axios parameter creator
 * @export
 */
export const DatabaseRecommendationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete many recommendations by ids
         * @summary 
         * @param {string} dbInstance 
         * @param {DeleteDatabaseRecommendationDto} deleteDatabaseRecommendationDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseRecommendationControllerBulkDeleteDatabaseRecommendation: async (dbInstance: string, deleteDatabaseRecommendationDto: DeleteDatabaseRecommendationDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('databaseRecommendationControllerBulkDeleteDatabaseRecommendation', 'dbInstance', dbInstance)
            // verify required parameter 'deleteDatabaseRecommendationDto' is not null or undefined
            assertParamExists('databaseRecommendationControllerBulkDeleteDatabaseRecommendation', 'deleteDatabaseRecommendationDto', deleteDatabaseRecommendationDto)
            const localVarPath = `/api/databases/{dbInstance}/recommendations`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteDatabaseRecommendationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get database recommendations
         * @summary 
         * @param {string} dbInstance 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseRecommendationControllerList: async (dbInstance: string, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('databaseRecommendationControllerList', 'dbInstance', dbInstance)
            const localVarPath = `/api/databases/{dbInstance}/recommendations`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update database recommendation by id
         * @summary 
         * @param {string} id 
         * @param {string} dbInstance 
         * @param {ModifyDatabaseRecommendationDto} modifyDatabaseRecommendationDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseRecommendationControllerModify: async (id: string, dbInstance: string, modifyDatabaseRecommendationDto: ModifyDatabaseRecommendationDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('databaseRecommendationControllerModify', 'id', id)
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('databaseRecommendationControllerModify', 'dbInstance', dbInstance)
            // verify required parameter 'modifyDatabaseRecommendationDto' is not null or undefined
            assertParamExists('databaseRecommendationControllerModify', 'modifyDatabaseRecommendationDto', modifyDatabaseRecommendationDto)
            const localVarPath = `/api/databases/{dbInstance}/recommendations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyDatabaseRecommendationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark all database recommendations as read
         * @summary 
         * @param {string} dbInstance 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseRecommendationControllerRead: async (dbInstance: string, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('databaseRecommendationControllerRead', 'dbInstance', dbInstance)
            const localVarPath = `/api/databases/{dbInstance}/recommendations/read`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseRecommendationsApi - functional programming interface
 * @export
 */
export const DatabaseRecommendationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseRecommendationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete many recommendations by ids
         * @summary 
         * @param {string} dbInstance 
         * @param {DeleteDatabaseRecommendationDto} deleteDatabaseRecommendationDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseRecommendationControllerBulkDeleteDatabaseRecommendation(dbInstance: string, deleteDatabaseRecommendationDto: DeleteDatabaseRecommendationDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteDatabaseRecommendationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseRecommendationControllerBulkDeleteDatabaseRecommendation(dbInstance, deleteDatabaseRecommendationDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseRecommendationsApi.databaseRecommendationControllerBulkDeleteDatabaseRecommendation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get database recommendations
         * @summary 
         * @param {string} dbInstance 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseRecommendationControllerList(dbInstance: string, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseRecommendationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseRecommendationControllerList(dbInstance, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseRecommendationsApi.databaseRecommendationControllerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update database recommendation by id
         * @summary 
         * @param {string} id 
         * @param {string} dbInstance 
         * @param {ModifyDatabaseRecommendationDto} modifyDatabaseRecommendationDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseRecommendationControllerModify(id: string, dbInstance: string, modifyDatabaseRecommendationDto: ModifyDatabaseRecommendationDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseRecommendation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseRecommendationControllerModify(id, dbInstance, modifyDatabaseRecommendationDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseRecommendationsApi.databaseRecommendationControllerModify']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Mark all database recommendations as read
         * @summary 
         * @param {string} dbInstance 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseRecommendationControllerRead(dbInstance: string, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseRecommendationControllerRead(dbInstance, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseRecommendationsApi.databaseRecommendationControllerRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DatabaseRecommendationsApi - factory interface
 * @export
 */
export const DatabaseRecommendationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseRecommendationsApiFp(configuration)
    return {
        /**
         * Delete many recommendations by ids
         * @summary 
         * @param {string} dbInstance 
         * @param {DeleteDatabaseRecommendationDto} deleteDatabaseRecommendationDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseRecommendationControllerBulkDeleteDatabaseRecommendation(dbInstance: string, deleteDatabaseRecommendationDto: DeleteDatabaseRecommendationDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteDatabaseRecommendationResponse> {
            return localVarFp.databaseRecommendationControllerBulkDeleteDatabaseRecommendation(dbInstance, deleteDatabaseRecommendationDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get database recommendations
         * @summary 
         * @param {string} dbInstance 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseRecommendationControllerList(dbInstance: string, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<DatabaseRecommendationsResponse> {
            return localVarFp.databaseRecommendationControllerList(dbInstance, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Update database recommendation by id
         * @summary 
         * @param {string} id 
         * @param {string} dbInstance 
         * @param {ModifyDatabaseRecommendationDto} modifyDatabaseRecommendationDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseRecommendationControllerModify(id: string, dbInstance: string, modifyDatabaseRecommendationDto: ModifyDatabaseRecommendationDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<DatabaseRecommendation> {
            return localVarFp.databaseRecommendationControllerModify(id, dbInstance, modifyDatabaseRecommendationDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark all database recommendations as read
         * @summary 
         * @param {string} dbInstance 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseRecommendationControllerRead(dbInstance: string, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.databaseRecommendationControllerRead(dbInstance, riDbIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseRecommendationsApi - object-oriented interface
 * @export
 * @class DatabaseRecommendationsApi
 * @extends {BaseAPI}
 */
export class DatabaseRecommendationsApi extends BaseAPI {
    /**
     * Delete many recommendations by ids
     * @summary 
     * @param {string} dbInstance 
     * @param {DeleteDatabaseRecommendationDto} deleteDatabaseRecommendationDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseRecommendationsApi
     */
    public databaseRecommendationControllerBulkDeleteDatabaseRecommendation(dbInstance: string, deleteDatabaseRecommendationDto: DeleteDatabaseRecommendationDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return DatabaseRecommendationsApiFp(this.configuration).databaseRecommendationControllerBulkDeleteDatabaseRecommendation(dbInstance, deleteDatabaseRecommendationDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get database recommendations
     * @summary 
     * @param {string} dbInstance 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseRecommendationsApi
     */
    public databaseRecommendationControllerList(dbInstance: string, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return DatabaseRecommendationsApiFp(this.configuration).databaseRecommendationControllerList(dbInstance, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update database recommendation by id
     * @summary 
     * @param {string} id 
     * @param {string} dbInstance 
     * @param {ModifyDatabaseRecommendationDto} modifyDatabaseRecommendationDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseRecommendationsApi
     */
    public databaseRecommendationControllerModify(id: string, dbInstance: string, modifyDatabaseRecommendationDto: ModifyDatabaseRecommendationDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return DatabaseRecommendationsApiFp(this.configuration).databaseRecommendationControllerModify(id, dbInstance, modifyDatabaseRecommendationDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark all database recommendations as read
     * @summary 
     * @param {string} dbInstance 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseRecommendationsApi
     */
    public databaseRecommendationControllerRead(dbInstance: string, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return DatabaseRecommendationsApiFp(this.configuration).databaseRecommendationControllerRead(dbInstance, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InfoApi - axios parameter creator
 * @export
 */
export const InfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get list of features
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        featureControllerList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/features`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        featureControllerSync: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/features/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get server info
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of blocking commands in CLI
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverControllerGetCliBlockingCommands: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/info/cli-blocking-commands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of unsupported commands in CLI
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverControllerGetCliUnsupportedCommands: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/info/cli-unsupported-commands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get server info
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverControllerGetInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoApi - functional programming interface
 * @export
 */
export const InfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfoApiAxiosParamCreator(configuration)
    return {
        /**
         * Get list of features
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async featureControllerList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.featureControllerList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.featureControllerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async featureControllerSync(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.featureControllerSync(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.featureControllerSync']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get server info
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthControllerHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthControllerHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.healthControllerHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of blocking commands in CLI
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serverControllerGetCliBlockingCommands(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serverControllerGetCliBlockingCommands(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.serverControllerGetCliBlockingCommands']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of unsupported commands in CLI
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serverControllerGetCliUnsupportedCommands(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serverControllerGetCliUnsupportedCommands(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.serverControllerGetCliUnsupportedCommands']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get server info
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serverControllerGetInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetServerInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serverControllerGetInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.serverControllerGetInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InfoApi - factory interface
 * @export
 */
export const InfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfoApiFp(configuration)
    return {
        /**
         * Get list of features
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        featureControllerList(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.featureControllerList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        featureControllerSync(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.featureControllerSync(options).then((request) => request(axios, basePath));
        },
        /**
         * Get server info
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerHealth(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.healthControllerHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of blocking commands in CLI
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverControllerGetCliBlockingCommands(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.serverControllerGetCliBlockingCommands(options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of unsupported commands in CLI
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverControllerGetCliUnsupportedCommands(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.serverControllerGetCliUnsupportedCommands(options).then((request) => request(axios, basePath));
        },
        /**
         * Get server info
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverControllerGetInfo(options?: RawAxiosRequestConfig): AxiosPromise<GetServerInfoResponse> {
            return localVarFp.serverControllerGetInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfoApi - object-oriented interface
 * @export
 * @class InfoApi
 * @extends {BaseAPI}
 */
export class InfoApi extends BaseAPI {
    /**
     * Get list of features
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public featureControllerList(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).featureControllerList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public featureControllerSync(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).featureControllerSync(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get server info
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public healthControllerHealth(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).healthControllerHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of blocking commands in CLI
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public serverControllerGetCliBlockingCommands(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).serverControllerGetCliBlockingCommands(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of unsupported commands in CLI
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public serverControllerGetCliUnsupportedCommands(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).serverControllerGetCliUnsupportedCommands(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get server info
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public serverControllerGetInfo(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).serverControllerGetInfo(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return ordered notifications history
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerGetNotifications: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark all notifications as read
         * @summary 
         * @param {ReadNotificationsDto} readNotificationsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerReadNotifications: async (readNotificationsDto: ReadNotificationsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'readNotificationsDto' is not null or undefined
            assertParamExists('notificationControllerReadNotifications', 'readNotificationsDto', readNotificationsDto)
            const localVarPath = `/api/notifications/read`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(readNotificationsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Return ordered notifications history
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationControllerGetNotifications(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationControllerGetNotifications(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationControllerGetNotifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Mark all notifications as read
         * @summary 
         * @param {ReadNotificationsDto} readNotificationsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationControllerReadNotifications(readNotificationsDto: ReadNotificationsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationControllerReadNotifications(readNotificationsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationControllerReadNotifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * Return ordered notifications history
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerGetNotifications(options?: RawAxiosRequestConfig): AxiosPromise<NotificationsDto> {
            return localVarFp.notificationControllerGetNotifications(options).then((request) => request(axios, basePath));
        },
        /**
         * Mark all notifications as read
         * @summary 
         * @param {ReadNotificationsDto} readNotificationsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerReadNotifications(readNotificationsDto: ReadNotificationsDto, options?: RawAxiosRequestConfig): AxiosPromise<NotificationsDto> {
            return localVarFp.notificationControllerReadNotifications(readNotificationsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * Return ordered notifications history
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationControllerGetNotifications(options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationControllerGetNotifications(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark all notifications as read
     * @summary 
     * @param {ReadNotificationsDto} readNotificationsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationControllerReadNotifications(readNotificationsDto: ReadNotificationsDto, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationControllerReadNotifications(readNotificationsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PluginsApi - axios parameter creator
 * @export
 */
export const PluginsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get list of available plugins
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginControllerGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/plugins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Redis whitelist commands available for plugins
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginsControllerGetPluginCommands: async (dbInstance: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('pluginsControllerGetPluginCommands', 'dbInstance', dbInstance)
            const localVarPath = `/api/databases/{dbInstance}/plugins/commands`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get previously saved state
         * @summary 
         * @param {string} visualizationId 
         * @param {string} id 
         * @param {string} dbInstance Database instance id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginsControllerGetState: async (visualizationId: string, id: string, dbInstance: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'visualizationId' is not null or undefined
            assertParamExists('pluginsControllerGetState', 'visualizationId', visualizationId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pluginsControllerGetState', 'id', id)
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('pluginsControllerGetState', 'dbInstance', dbInstance)
            const localVarPath = `/api/databases/{dbInstance}/plugins/{visualizationId}/command-executions/{id}/state`
                .replace(`{${"visualizationId"}}`, encodeURIComponent(String(visualizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save plugin state for particular command execution
         * @summary 
         * @param {string} visualizationId 
         * @param {string} id 
         * @param {string} dbInstance Database instance id.
         * @param {CreatePluginStateDto} createPluginStateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginsControllerSaveState: async (visualizationId: string, id: string, dbInstance: string, createPluginStateDto: CreatePluginStateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'visualizationId' is not null or undefined
            assertParamExists('pluginsControllerSaveState', 'visualizationId', visualizationId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pluginsControllerSaveState', 'id', id)
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('pluginsControllerSaveState', 'dbInstance', dbInstance)
            // verify required parameter 'createPluginStateDto' is not null or undefined
            assertParamExists('pluginsControllerSaveState', 'createPluginStateDto', createPluginStateDto)
            const localVarPath = `/api/databases/{dbInstance}/plugins/{visualizationId}/command-executions/{id}/state`
                .replace(`{${"visualizationId"}}`, encodeURIComponent(String(visualizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPluginStateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send Redis Command from the Workbench
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {CreateCommandExecutionDto} createCommandExecutionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginsControllerSendCommand: async (dbInstance: string, createCommandExecutionDto: CreateCommandExecutionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('pluginsControllerSendCommand', 'dbInstance', dbInstance)
            // verify required parameter 'createCommandExecutionDto' is not null or undefined
            assertParamExists('pluginsControllerSendCommand', 'createCommandExecutionDto', createCommandExecutionDto)
            const localVarPath = `/api/databases/{dbInstance}/plugins/command-executions`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCommandExecutionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PluginsApi - functional programming interface
 * @export
 */
export const PluginsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PluginsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get list of available plugins
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluginControllerGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PluginsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pluginControllerGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginsApi.pluginControllerGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Redis whitelist commands available for plugins
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluginsControllerGetPluginCommands(dbInstance: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pluginsControllerGetPluginCommands(dbInstance, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginsApi.pluginsControllerGetPluginCommands']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get previously saved state
         * @summary 
         * @param {string} visualizationId 
         * @param {string} id 
         * @param {string} dbInstance Database instance id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluginsControllerGetState(visualizationId: string, id: string, dbInstance: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PluginState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pluginsControllerGetState(visualizationId, id, dbInstance, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginsApi.pluginsControllerGetState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Save plugin state for particular command execution
         * @summary 
         * @param {string} visualizationId 
         * @param {string} id 
         * @param {string} dbInstance Database instance id.
         * @param {CreatePluginStateDto} createPluginStateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluginsControllerSaveState(visualizationId: string, id: string, dbInstance: string, createPluginStateDto: CreatePluginStateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pluginsControllerSaveState(visualizationId, id, dbInstance, createPluginStateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginsApi.pluginsControllerSaveState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send Redis Command from the Workbench
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {CreateCommandExecutionDto} createCommandExecutionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluginsControllerSendCommand(dbInstance: string, createCommandExecutionDto: CreateCommandExecutionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PluginCommandExecution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pluginsControllerSendCommand(dbInstance, createCommandExecutionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginsApi.pluginsControllerSendCommand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PluginsApi - factory interface
 * @export
 */
export const PluginsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PluginsApiFp(configuration)
    return {
        /**
         * Get list of available plugins
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginControllerGetAll(options?: RawAxiosRequestConfig): AxiosPromise<PluginsResponse> {
            return localVarFp.pluginControllerGetAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Redis whitelist commands available for plugins
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginsControllerGetPluginCommands(dbInstance: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.pluginsControllerGetPluginCommands(dbInstance, options).then((request) => request(axios, basePath));
        },
        /**
         * Get previously saved state
         * @summary 
         * @param {string} visualizationId 
         * @param {string} id 
         * @param {string} dbInstance Database instance id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginsControllerGetState(visualizationId: string, id: string, dbInstance: string, options?: RawAxiosRequestConfig): AxiosPromise<PluginState> {
            return localVarFp.pluginsControllerGetState(visualizationId, id, dbInstance, options).then((request) => request(axios, basePath));
        },
        /**
         * Save plugin state for particular command execution
         * @summary 
         * @param {string} visualizationId 
         * @param {string} id 
         * @param {string} dbInstance Database instance id.
         * @param {CreatePluginStateDto} createPluginStateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginsControllerSaveState(visualizationId: string, id: string, dbInstance: string, createPluginStateDto: CreatePluginStateDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pluginsControllerSaveState(visualizationId, id, dbInstance, createPluginStateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Send Redis Command from the Workbench
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {CreateCommandExecutionDto} createCommandExecutionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginsControllerSendCommand(dbInstance: string, createCommandExecutionDto: CreateCommandExecutionDto, options?: RawAxiosRequestConfig): AxiosPromise<PluginCommandExecution> {
            return localVarFp.pluginsControllerSendCommand(dbInstance, createCommandExecutionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PluginsApi - object-oriented interface
 * @export
 * @class PluginsApi
 * @extends {BaseAPI}
 */
export class PluginsApi extends BaseAPI {
    /**
     * Get list of available plugins
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public pluginControllerGetAll(options?: RawAxiosRequestConfig) {
        return PluginsApiFp(this.configuration).pluginControllerGetAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Redis whitelist commands available for plugins
     * @summary 
     * @param {string} dbInstance Database instance id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public pluginsControllerGetPluginCommands(dbInstance: string, options?: RawAxiosRequestConfig) {
        return PluginsApiFp(this.configuration).pluginsControllerGetPluginCommands(dbInstance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get previously saved state
     * @summary 
     * @param {string} visualizationId 
     * @param {string} id 
     * @param {string} dbInstance Database instance id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public pluginsControllerGetState(visualizationId: string, id: string, dbInstance: string, options?: RawAxiosRequestConfig) {
        return PluginsApiFp(this.configuration).pluginsControllerGetState(visualizationId, id, dbInstance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Save plugin state for particular command execution
     * @summary 
     * @param {string} visualizationId 
     * @param {string} id 
     * @param {string} dbInstance Database instance id.
     * @param {CreatePluginStateDto} createPluginStateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public pluginsControllerSaveState(visualizationId: string, id: string, dbInstance: string, createPluginStateDto: CreatePluginStateDto, options?: RawAxiosRequestConfig) {
        return PluginsApiFp(this.configuration).pluginsControllerSaveState(visualizationId, id, dbInstance, createPluginStateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send Redis Command from the Workbench
     * @summary 
     * @param {string} dbInstance Database instance id.
     * @param {CreateCommandExecutionDto} createCommandExecutionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public pluginsControllerSendCommand(dbInstance: string, createCommandExecutionDto: CreateCommandExecutionDto, options?: RawAxiosRequestConfig) {
        return PluginsApiFp(this.configuration).pluginsControllerSendCommand(dbInstance, createCommandExecutionDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfilerApi - axios parameter creator
 * @export
 */
export const ProfilerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint do download profiler log file
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilerControllerDownloadLogsFile: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profilerControllerDownloadLogsFile', 'id', id)
            const localVarPath = `/api/profiler/logs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfilerApi - functional programming interface
 * @export
 */
export const ProfilerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfilerApiAxiosParamCreator(configuration)
    return {
        /**
         * Endpoint do download profiler log file
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilerControllerDownloadLogsFile(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilerControllerDownloadLogsFile(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilerApi.profilerControllerDownloadLogsFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfilerApi - factory interface
 * @export
 */
export const ProfilerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfilerApiFp(configuration)
    return {
        /**
         * Endpoint do download profiler log file
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilerControllerDownloadLogsFile(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.profilerControllerDownloadLogsFile(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfilerApi - object-oriented interface
 * @export
 * @class ProfilerApi
 * @extends {BaseAPI}
 */
export class ProfilerApi extends BaseAPI {
    /**
     * Endpoint do download profiler log file
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilerApi
     */
    public profilerControllerDownloadLogsFile(id: string, options?: RawAxiosRequestConfig) {
        return ProfilerApiFp(this.configuration).profilerControllerDownloadLogsFile(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PubSubApi - axios parameter creator
 * @export
 */
export const PubSubApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Publish message to a channel
         * @summary 
         * @param {string} dbInstance 
         * @param {PublishDto} publishDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pubSubControllerPublish: async (dbInstance: string, publishDto: PublishDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('pubSubControllerPublish', 'dbInstance', dbInstance)
            // verify required parameter 'publishDto' is not null or undefined
            assertParamExists('pubSubControllerPublish', 'publishDto', publishDto)
            const localVarPath = `/api/databases/{dbInstance}/pub-sub/messages`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publishDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PubSubApi - functional programming interface
 * @export
 */
export const PubSubApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PubSubApiAxiosParamCreator(configuration)
    return {
        /**
         * Publish message to a channel
         * @summary 
         * @param {string} dbInstance 
         * @param {PublishDto} publishDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pubSubControllerPublish(dbInstance: string, publishDto: PublishDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublishResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pubSubControllerPublish(dbInstance, publishDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PubSubApi.pubSubControllerPublish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PubSubApi - factory interface
 * @export
 */
export const PubSubApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PubSubApiFp(configuration)
    return {
        /**
         * Publish message to a channel
         * @summary 
         * @param {string} dbInstance 
         * @param {PublishDto} publishDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pubSubControllerPublish(dbInstance: string, publishDto: PublishDto, options?: RawAxiosRequestConfig): AxiosPromise<PublishResponse> {
            return localVarFp.pubSubControllerPublish(dbInstance, publishDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PubSubApi - object-oriented interface
 * @export
 * @class PubSubApi
 * @extends {BaseAPI}
 */
export class PubSubApi extends BaseAPI {
    /**
     * Publish message to a channel
     * @summary 
     * @param {string} dbInstance 
     * @param {PublishDto} publishDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PubSubApi
     */
    public pubSubControllerPublish(dbInstance: string, publishDto: PublishDto, options?: RawAxiosRequestConfig) {
        return PubSubApiFp(this.configuration).pubSubControllerPublish(dbInstance, publishDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RDIApi - axios parameter creator
 * @export
 */
export const RDIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Connect to RDI
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiControllerConnect: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rdiControllerConnect', 'id', id)
            const localVarPath = `/api/rdi/{id}/connect`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create RDI
         * @summary 
         * @param {CreateRdiDto} createRdiDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiControllerCreate: async (createRdiDto: CreateRdiDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRdiDto' is not null or undefined
            assertParamExists('rdiControllerCreate', 'createRdiDto', createRdiDto)
            const localVarPath = `/api/rdi`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRdiDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete RDI
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiControllerDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/rdi`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get RDI by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiControllerGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rdiControllerGet', 'id', id)
            const localVarPath = `/api/rdi/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get RDI list
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiControllerList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/rdi`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update RDI
         * @summary 
         * @param {string} id 
         * @param {UpdateRdiDto} updateRdiDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiControllerUpdate: async (id: string, updateRdiDto: UpdateRdiDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rdiControllerUpdate', 'id', id)
            // verify required parameter 'updateRdiDto' is not null or undefined
            assertParamExists('rdiControllerUpdate', 'updateRdiDto', updateRdiDto)
            const localVarPath = `/api/rdi/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRdiDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy the pipeline
         * @summary 
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerDeploy: async (id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rdiPipelineControllerDeploy', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('rdiPipelineControllerDeploy', 'body', body)
            const localVarPath = `/api/rdi/{id}/pipeline/deploy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Dry run job
         * @summary 
         * @param {string} id 
         * @param {RdiDryRunJobDto} rdiDryRunJobDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerDryRunJob: async (id: string, rdiDryRunJobDto: RdiDryRunJobDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rdiPipelineControllerDryRunJob', 'id', id)
            // verify required parameter 'rdiDryRunJobDto' is not null or undefined
            assertParamExists('rdiPipelineControllerDryRunJob', 'rdiDryRunJobDto', rdiDryRunJobDto)
            const localVarPath = `/api/rdi/{id}/pipeline/dry-run-job`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rdiDryRunJobDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get config template for selected pipeline and db types
         * @summary 
         * @param {string} pipelineType 
         * @param {string} dbType 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerGetConfigTemplate: async (pipelineType: string, dbType: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineType' is not null or undefined
            assertParamExists('rdiPipelineControllerGetConfigTemplate', 'pipelineType', pipelineType)
            // verify required parameter 'dbType' is not null or undefined
            assertParamExists('rdiPipelineControllerGetConfigTemplate', 'dbType', dbType)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rdiPipelineControllerGetConfigTemplate', 'id', id)
            const localVarPath = `/api/rdi/{id}/pipeline/config/template/{pipelineType}/{dbType}`
                .replace(`{${"pipelineType"}}`, encodeURIComponent(String(pipelineType)))
                .replace(`{${"dbType"}}`, encodeURIComponent(String(dbType)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get job functions
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerGetJobFunctions: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rdiPipelineControllerGetJobFunctions', 'id', id)
            const localVarPath = `/api/rdi/{id}/pipeline/job-functions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get job template for selected pipeline type
         * @summary 
         * @param {string} pipelineType 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerGetJobTemplate: async (pipelineType: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineType' is not null or undefined
            assertParamExists('rdiPipelineControllerGetJobTemplate', 'pipelineType', pipelineType)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rdiPipelineControllerGetJobTemplate', 'id', id)
            const localVarPath = `/api/rdi/{id}/pipeline/job/template/{pipelineType}`
                .replace(`{${"pipelineType"}}`, encodeURIComponent(String(pipelineType)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pipeline
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerGetPipeline: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rdiPipelineControllerGetPipeline', 'id', id)
            const localVarPath = `/api/rdi/{id}/pipeline`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pipeline status
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerGetPipelineStatus: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rdiPipelineControllerGetPipelineStatus', 'id', id)
            const localVarPath = `/api/rdi/{id}/pipeline/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pipeline schema
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerGetSchema: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rdiPipelineControllerGetSchema', 'id', id)
            const localVarPath = `/api/rdi/{id}/pipeline/schema`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pipeline strategies and db types for template
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerGetStrategies: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rdiPipelineControllerGetStrategies', 'id', id)
            const localVarPath = `/api/rdi/{id}/pipeline/strategies`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets default pipeline
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerResetPipeline: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rdiPipelineControllerResetPipeline', 'id', id)
            const localVarPath = `/api/rdi/{id}/pipeline/reset`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the stopped pipeline
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerStartPipeline: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rdiPipelineControllerStartPipeline', 'id', id)
            const localVarPath = `/api/rdi/{id}/pipeline/start`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stops running pipeline
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerStopPipeline: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rdiPipelineControllerStopPipeline', 'id', id)
            const localVarPath = `/api/rdi/{id}/pipeline/stop`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test target connections
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerTestConnections: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rdiPipelineControllerTestConnections', 'id', id)
            const localVarPath = `/api/rdi/{id}/pipeline/test-connections`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get statistics
         * @summary 
         * @param {string} id 
         * @param {string} [sections] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiStatisticsControllerGetStatistics: async (id: string, sections?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rdiStatisticsControllerGetStatistics', 'id', id)
            const localVarPath = `/api/rdi/{id}/statistics`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sections !== undefined) {
                localVarQueryParameter['sections'] = sections;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RDIApi - functional programming interface
 * @export
 */
export const RDIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RDIApiAxiosParamCreator(configuration)
    return {
        /**
         * Connect to RDI
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rdiControllerConnect(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rdiControllerConnect(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RDIApi.rdiControllerConnect']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create RDI
         * @summary 
         * @param {CreateRdiDto} createRdiDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rdiControllerCreate(createRdiDto: CreateRdiDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rdi>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rdiControllerCreate(createRdiDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RDIApi.rdiControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete RDI
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rdiControllerDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rdiControllerDelete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RDIApi.rdiControllerDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get RDI by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rdiControllerGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rdi>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rdiControllerGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RDIApi.rdiControllerGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get RDI list
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rdiControllerList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Rdi>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rdiControllerList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RDIApi.rdiControllerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update RDI
         * @summary 
         * @param {string} id 
         * @param {UpdateRdiDto} updateRdiDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rdiControllerUpdate(id: string, updateRdiDto: UpdateRdiDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rdi>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rdiControllerUpdate(id, updateRdiDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RDIApi.rdiControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deploy the pipeline
         * @summary 
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rdiPipelineControllerDeploy(id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rdiPipelineControllerDeploy(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RDIApi.rdiPipelineControllerDeploy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Dry run job
         * @summary 
         * @param {string} id 
         * @param {RdiDryRunJobDto} rdiDryRunJobDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rdiPipelineControllerDryRunJob(id: string, rdiDryRunJobDto: RdiDryRunJobDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RdiDryRunJobResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rdiPipelineControllerDryRunJob(id, rdiDryRunJobDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RDIApi.rdiPipelineControllerDryRunJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get config template for selected pipeline and db types
         * @summary 
         * @param {string} pipelineType 
         * @param {string} dbType 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rdiPipelineControllerGetConfigTemplate(pipelineType: string, dbType: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RdiTemplateResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rdiPipelineControllerGetConfigTemplate(pipelineType, dbType, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RDIApi.rdiPipelineControllerGetConfigTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get job functions
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rdiPipelineControllerGetJobFunctions(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rdiPipelineControllerGetJobFunctions(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RDIApi.rdiPipelineControllerGetJobFunctions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get job template for selected pipeline type
         * @summary 
         * @param {string} pipelineType 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rdiPipelineControllerGetJobTemplate(pipelineType: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RdiTemplateResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rdiPipelineControllerGetJobTemplate(pipelineType, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RDIApi.rdiPipelineControllerGetJobTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pipeline
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rdiPipelineControllerGetPipeline(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rdiPipelineControllerGetPipeline(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RDIApi.rdiPipelineControllerGetPipeline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pipeline status
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rdiPipelineControllerGetPipelineStatus(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rdiPipelineControllerGetPipelineStatus(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RDIApi.rdiPipelineControllerGetPipelineStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pipeline schema
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rdiPipelineControllerGetSchema(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rdiPipelineControllerGetSchema(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RDIApi.rdiPipelineControllerGetSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pipeline strategies and db types for template
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rdiPipelineControllerGetStrategies(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rdiPipelineControllerGetStrategies(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RDIApi.rdiPipelineControllerGetStrategies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resets default pipeline
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rdiPipelineControllerResetPipeline(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rdiPipelineControllerResetPipeline(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RDIApi.rdiPipelineControllerResetPipeline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starts the stopped pipeline
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rdiPipelineControllerStartPipeline(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rdiPipelineControllerStartPipeline(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RDIApi.rdiPipelineControllerStartPipeline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stops running pipeline
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rdiPipelineControllerStopPipeline(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rdiPipelineControllerStopPipeline(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RDIApi.rdiPipelineControllerStopPipeline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test target connections
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rdiPipelineControllerTestConnections(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RdiTestConnectionsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rdiPipelineControllerTestConnections(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RDIApi.rdiPipelineControllerTestConnections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get statistics
         * @summary 
         * @param {string} id 
         * @param {string} [sections] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rdiStatisticsControllerGetStatistics(id: string, sections?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rdiStatisticsControllerGetStatistics(id, sections, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RDIApi.rdiStatisticsControllerGetStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RDIApi - factory interface
 * @export
 */
export const RDIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RDIApiFp(configuration)
    return {
        /**
         * Connect to RDI
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiControllerConnect(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rdiControllerConnect(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create RDI
         * @summary 
         * @param {CreateRdiDto} createRdiDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiControllerCreate(createRdiDto: CreateRdiDto, options?: RawAxiosRequestConfig): AxiosPromise<Rdi> {
            return localVarFp.rdiControllerCreate(createRdiDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete RDI
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiControllerDelete(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rdiControllerDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * Get RDI by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiControllerGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Rdi> {
            return localVarFp.rdiControllerGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get RDI list
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiControllerList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Rdi>> {
            return localVarFp.rdiControllerList(options).then((request) => request(axios, basePath));
        },
        /**
         * Update RDI
         * @summary 
         * @param {string} id 
         * @param {UpdateRdiDto} updateRdiDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiControllerUpdate(id: string, updateRdiDto: UpdateRdiDto, options?: RawAxiosRequestConfig): AxiosPromise<Rdi> {
            return localVarFp.rdiControllerUpdate(id, updateRdiDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deploy the pipeline
         * @summary 
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerDeploy(id: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rdiPipelineControllerDeploy(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Dry run job
         * @summary 
         * @param {string} id 
         * @param {RdiDryRunJobDto} rdiDryRunJobDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerDryRunJob(id: string, rdiDryRunJobDto: RdiDryRunJobDto, options?: RawAxiosRequestConfig): AxiosPromise<RdiDryRunJobResponseDto> {
            return localVarFp.rdiPipelineControllerDryRunJob(id, rdiDryRunJobDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Get config template for selected pipeline and db types
         * @summary 
         * @param {string} pipelineType 
         * @param {string} dbType 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerGetConfigTemplate(pipelineType: string, dbType: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<RdiTemplateResponseDto> {
            return localVarFp.rdiPipelineControllerGetConfigTemplate(pipelineType, dbType, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get job functions
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerGetJobFunctions(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rdiPipelineControllerGetJobFunctions(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get job template for selected pipeline type
         * @summary 
         * @param {string} pipelineType 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerGetJobTemplate(pipelineType: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<RdiTemplateResponseDto> {
            return localVarFp.rdiPipelineControllerGetJobTemplate(pipelineType, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pipeline
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerGetPipeline(id: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.rdiPipelineControllerGetPipeline(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pipeline status
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerGetPipelineStatus(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rdiPipelineControllerGetPipelineStatus(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pipeline schema
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerGetSchema(id: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.rdiPipelineControllerGetSchema(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pipeline strategies and db types for template
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerGetStrategies(id: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.rdiPipelineControllerGetStrategies(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets default pipeline
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerResetPipeline(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rdiPipelineControllerResetPipeline(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts the stopped pipeline
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerStartPipeline(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rdiPipelineControllerStartPipeline(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Stops running pipeline
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerStopPipeline(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rdiPipelineControllerStopPipeline(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Test target connections
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiPipelineControllerTestConnections(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RdiTestConnectionsResponseDto> {
            return localVarFp.rdiPipelineControllerTestConnections(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get statistics
         * @summary 
         * @param {string} id 
         * @param {string} [sections] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rdiStatisticsControllerGetStatistics(id: string, sections?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.rdiStatisticsControllerGetStatistics(id, sections, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RDIApi - object-oriented interface
 * @export
 * @class RDIApi
 * @extends {BaseAPI}
 */
export class RDIApi extends BaseAPI {
    /**
     * Connect to RDI
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RDIApi
     */
    public rdiControllerConnect(id: string, options?: RawAxiosRequestConfig) {
        return RDIApiFp(this.configuration).rdiControllerConnect(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create RDI
     * @summary 
     * @param {CreateRdiDto} createRdiDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RDIApi
     */
    public rdiControllerCreate(createRdiDto: CreateRdiDto, options?: RawAxiosRequestConfig) {
        return RDIApiFp(this.configuration).rdiControllerCreate(createRdiDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete RDI
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RDIApi
     */
    public rdiControllerDelete(options?: RawAxiosRequestConfig) {
        return RDIApiFp(this.configuration).rdiControllerDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get RDI by id
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RDIApi
     */
    public rdiControllerGet(id: string, options?: RawAxiosRequestConfig) {
        return RDIApiFp(this.configuration).rdiControllerGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get RDI list
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RDIApi
     */
    public rdiControllerList(options?: RawAxiosRequestConfig) {
        return RDIApiFp(this.configuration).rdiControllerList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update RDI
     * @summary 
     * @param {string} id 
     * @param {UpdateRdiDto} updateRdiDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RDIApi
     */
    public rdiControllerUpdate(id: string, updateRdiDto: UpdateRdiDto, options?: RawAxiosRequestConfig) {
        return RDIApiFp(this.configuration).rdiControllerUpdate(id, updateRdiDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deploy the pipeline
     * @summary 
     * @param {string} id 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RDIApi
     */
    public rdiPipelineControllerDeploy(id: string, body: object, options?: RawAxiosRequestConfig) {
        return RDIApiFp(this.configuration).rdiPipelineControllerDeploy(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Dry run job
     * @summary 
     * @param {string} id 
     * @param {RdiDryRunJobDto} rdiDryRunJobDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RDIApi
     */
    public rdiPipelineControllerDryRunJob(id: string, rdiDryRunJobDto: RdiDryRunJobDto, options?: RawAxiosRequestConfig) {
        return RDIApiFp(this.configuration).rdiPipelineControllerDryRunJob(id, rdiDryRunJobDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get config template for selected pipeline and db types
     * @summary 
     * @param {string} pipelineType 
     * @param {string} dbType 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RDIApi
     */
    public rdiPipelineControllerGetConfigTemplate(pipelineType: string, dbType: string, id: string, options?: RawAxiosRequestConfig) {
        return RDIApiFp(this.configuration).rdiPipelineControllerGetConfigTemplate(pipelineType, dbType, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get job functions
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RDIApi
     */
    public rdiPipelineControllerGetJobFunctions(id: string, options?: RawAxiosRequestConfig) {
        return RDIApiFp(this.configuration).rdiPipelineControllerGetJobFunctions(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get job template for selected pipeline type
     * @summary 
     * @param {string} pipelineType 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RDIApi
     */
    public rdiPipelineControllerGetJobTemplate(pipelineType: string, id: string, options?: RawAxiosRequestConfig) {
        return RDIApiFp(this.configuration).rdiPipelineControllerGetJobTemplate(pipelineType, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pipeline
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RDIApi
     */
    public rdiPipelineControllerGetPipeline(id: string, options?: RawAxiosRequestConfig) {
        return RDIApiFp(this.configuration).rdiPipelineControllerGetPipeline(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pipeline status
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RDIApi
     */
    public rdiPipelineControllerGetPipelineStatus(id: string, options?: RawAxiosRequestConfig) {
        return RDIApiFp(this.configuration).rdiPipelineControllerGetPipelineStatus(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pipeline schema
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RDIApi
     */
    public rdiPipelineControllerGetSchema(id: string, options?: RawAxiosRequestConfig) {
        return RDIApiFp(this.configuration).rdiPipelineControllerGetSchema(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pipeline strategies and db types for template
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RDIApi
     */
    public rdiPipelineControllerGetStrategies(id: string, options?: RawAxiosRequestConfig) {
        return RDIApiFp(this.configuration).rdiPipelineControllerGetStrategies(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets default pipeline
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RDIApi
     */
    public rdiPipelineControllerResetPipeline(id: string, options?: RawAxiosRequestConfig) {
        return RDIApiFp(this.configuration).rdiPipelineControllerResetPipeline(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts the stopped pipeline
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RDIApi
     */
    public rdiPipelineControllerStartPipeline(id: string, options?: RawAxiosRequestConfig) {
        return RDIApiFp(this.configuration).rdiPipelineControllerStartPipeline(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stops running pipeline
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RDIApi
     */
    public rdiPipelineControllerStopPipeline(id: string, options?: RawAxiosRequestConfig) {
        return RDIApiFp(this.configuration).rdiPipelineControllerStopPipeline(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test target connections
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RDIApi
     */
    public rdiPipelineControllerTestConnections(id: string, options?: RawAxiosRequestConfig) {
        return RDIApiFp(this.configuration).rdiPipelineControllerTestConnections(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get statistics
     * @summary 
     * @param {string} id 
     * @param {string} [sections] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RDIApi
     */
    public rdiStatisticsControllerGetStatistics(id: string, sections?: string, options?: RawAxiosRequestConfig) {
        return RDIApiFp(this.configuration).rdiStatisticsControllerGetStatistics(id, sections, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RedisEnterpriseClusterApi - axios parameter creator
 * @export
 */
export const RedisEnterpriseClusterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add databases from Redis Enterprise cluster
         * @summary 
         * @param {AddRedisEnterpriseDatabasesDto} addRedisEnterpriseDatabasesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redisEnterpriseControllerAddRedisEnterpriseDatabases: async (addRedisEnterpriseDatabasesDto: AddRedisEnterpriseDatabasesDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addRedisEnterpriseDatabasesDto' is not null or undefined
            assertParamExists('redisEnterpriseControllerAddRedisEnterpriseDatabases', 'addRedisEnterpriseDatabasesDto', addRedisEnterpriseDatabasesDto)
            const localVarPath = `/api/redis-enterprise/cluster/databases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addRedisEnterpriseDatabasesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all databases in the cluster.
         * @summary 
         * @param {ClusterConnectionDetailsDto} clusterConnectionDetailsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redisEnterpriseControllerGetDatabases: async (clusterConnectionDetailsDto: ClusterConnectionDetailsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterConnectionDetailsDto' is not null or undefined
            assertParamExists('redisEnterpriseControllerGetDatabases', 'clusterConnectionDetailsDto', clusterConnectionDetailsDto)
            const localVarPath = `/api/redis-enterprise/cluster/get-databases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterConnectionDetailsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RedisEnterpriseClusterApi - functional programming interface
 * @export
 */
export const RedisEnterpriseClusterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RedisEnterpriseClusterApiAxiosParamCreator(configuration)
    return {
        /**
         * Add databases from Redis Enterprise cluster
         * @summary 
         * @param {AddRedisEnterpriseDatabasesDto} addRedisEnterpriseDatabasesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redisEnterpriseControllerAddRedisEnterpriseDatabases(addRedisEnterpriseDatabasesDto: AddRedisEnterpriseDatabasesDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AddRedisEnterpriseDatabaseResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redisEnterpriseControllerAddRedisEnterpriseDatabases(addRedisEnterpriseDatabasesDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RedisEnterpriseClusterApi.redisEnterpriseControllerAddRedisEnterpriseDatabases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all databases in the cluster.
         * @summary 
         * @param {ClusterConnectionDetailsDto} clusterConnectionDetailsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redisEnterpriseControllerGetDatabases(clusterConnectionDetailsDto: ClusterConnectionDetailsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RedisEnterpriseDatabase>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redisEnterpriseControllerGetDatabases(clusterConnectionDetailsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RedisEnterpriseClusterApi.redisEnterpriseControllerGetDatabases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RedisEnterpriseClusterApi - factory interface
 * @export
 */
export const RedisEnterpriseClusterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RedisEnterpriseClusterApiFp(configuration)
    return {
        /**
         * Add databases from Redis Enterprise cluster
         * @summary 
         * @param {AddRedisEnterpriseDatabasesDto} addRedisEnterpriseDatabasesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redisEnterpriseControllerAddRedisEnterpriseDatabases(addRedisEnterpriseDatabasesDto: AddRedisEnterpriseDatabasesDto, options?: RawAxiosRequestConfig): AxiosPromise<Array<AddRedisEnterpriseDatabaseResponse>> {
            return localVarFp.redisEnterpriseControllerAddRedisEnterpriseDatabases(addRedisEnterpriseDatabasesDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all databases in the cluster.
         * @summary 
         * @param {ClusterConnectionDetailsDto} clusterConnectionDetailsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redisEnterpriseControllerGetDatabases(clusterConnectionDetailsDto: ClusterConnectionDetailsDto, options?: RawAxiosRequestConfig): AxiosPromise<Array<RedisEnterpriseDatabase>> {
            return localVarFp.redisEnterpriseControllerGetDatabases(clusterConnectionDetailsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RedisEnterpriseClusterApi - object-oriented interface
 * @export
 * @class RedisEnterpriseClusterApi
 * @extends {BaseAPI}
 */
export class RedisEnterpriseClusterApi extends BaseAPI {
    /**
     * Add databases from Redis Enterprise cluster
     * @summary 
     * @param {AddRedisEnterpriseDatabasesDto} addRedisEnterpriseDatabasesDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedisEnterpriseClusterApi
     */
    public redisEnterpriseControllerAddRedisEnterpriseDatabases(addRedisEnterpriseDatabasesDto: AddRedisEnterpriseDatabasesDto, options?: RawAxiosRequestConfig) {
        return RedisEnterpriseClusterApiFp(this.configuration).redisEnterpriseControllerAddRedisEnterpriseDatabases(addRedisEnterpriseDatabasesDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all databases in the cluster.
     * @summary 
     * @param {ClusterConnectionDetailsDto} clusterConnectionDetailsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedisEnterpriseClusterApi
     */
    public redisEnterpriseControllerGetDatabases(clusterConnectionDetailsDto: ClusterConnectionDetailsDto, options?: RawAxiosRequestConfig) {
        return RedisEnterpriseClusterApiFp(this.configuration).redisEnterpriseControllerGetDatabases(clusterConnectionDetailsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RedisOSSSentinelApi - axios parameter creator
 * @export
 */
export const RedisOSSSentinelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add masters from Redis Sentinel
         * @summary 
         * @param {CreateSentinelDatabasesDto} createSentinelDatabasesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redisSentinelControllerAddSentinelMasters: async (createSentinelDatabasesDto: CreateSentinelDatabasesDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSentinelDatabasesDto' is not null or undefined
            assertParamExists('redisSentinelControllerAddSentinelMasters', 'createSentinelDatabasesDto', createSentinelDatabasesDto)
            const localVarPath = `/api/redis-sentinel/databases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSentinelDatabasesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get master groups
         * @summary 
         * @param {DiscoverSentinelMastersDto} discoverSentinelMastersDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redisSentinelControllerGetMasters: async (discoverSentinelMastersDto: DiscoverSentinelMastersDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'discoverSentinelMastersDto' is not null or undefined
            assertParamExists('redisSentinelControllerGetMasters', 'discoverSentinelMastersDto', discoverSentinelMastersDto)
            const localVarPath = `/api/redis-sentinel/get-databases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(discoverSentinelMastersDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RedisOSSSentinelApi - functional programming interface
 * @export
 */
export const RedisOSSSentinelApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RedisOSSSentinelApiAxiosParamCreator(configuration)
    return {
        /**
         * Add masters from Redis Sentinel
         * @summary 
         * @param {CreateSentinelDatabasesDto} createSentinelDatabasesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redisSentinelControllerAddSentinelMasters(createSentinelDatabasesDto: CreateSentinelDatabasesDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateSentinelDatabaseResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redisSentinelControllerAddSentinelMasters(createSentinelDatabasesDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RedisOSSSentinelApi.redisSentinelControllerAddSentinelMasters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get master groups
         * @summary 
         * @param {DiscoverSentinelMastersDto} discoverSentinelMastersDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redisSentinelControllerGetMasters(discoverSentinelMastersDto: DiscoverSentinelMastersDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SentinelMaster>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redisSentinelControllerGetMasters(discoverSentinelMastersDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RedisOSSSentinelApi.redisSentinelControllerGetMasters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RedisOSSSentinelApi - factory interface
 * @export
 */
export const RedisOSSSentinelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RedisOSSSentinelApiFp(configuration)
    return {
        /**
         * Add masters from Redis Sentinel
         * @summary 
         * @param {CreateSentinelDatabasesDto} createSentinelDatabasesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redisSentinelControllerAddSentinelMasters(createSentinelDatabasesDto: CreateSentinelDatabasesDto, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateSentinelDatabaseResponse>> {
            return localVarFp.redisSentinelControllerAddSentinelMasters(createSentinelDatabasesDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Get master groups
         * @summary 
         * @param {DiscoverSentinelMastersDto} discoverSentinelMastersDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redisSentinelControllerGetMasters(discoverSentinelMastersDto: DiscoverSentinelMastersDto, options?: RawAxiosRequestConfig): AxiosPromise<Array<SentinelMaster>> {
            return localVarFp.redisSentinelControllerGetMasters(discoverSentinelMastersDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RedisOSSSentinelApi - object-oriented interface
 * @export
 * @class RedisOSSSentinelApi
 * @extends {BaseAPI}
 */
export class RedisOSSSentinelApi extends BaseAPI {
    /**
     * Add masters from Redis Sentinel
     * @summary 
     * @param {CreateSentinelDatabasesDto} createSentinelDatabasesDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedisOSSSentinelApi
     */
    public redisSentinelControllerAddSentinelMasters(createSentinelDatabasesDto: CreateSentinelDatabasesDto, options?: RawAxiosRequestConfig) {
        return RedisOSSSentinelApiFp(this.configuration).redisSentinelControllerAddSentinelMasters(createSentinelDatabasesDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get master groups
     * @summary 
     * @param {DiscoverSentinelMastersDto} discoverSentinelMastersDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedisOSSSentinelApi
     */
    public redisSentinelControllerGetMasters(discoverSentinelMastersDto: DiscoverSentinelMastersDto, options?: RawAxiosRequestConfig) {
        return RedisOSSSentinelApiFp(this.configuration).redisSentinelControllerGetMasters(discoverSentinelMastersDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get json with agreements specification
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerGetAgreementsSpec: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/settings/agreements/spec`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get info about application settings
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerGetAppSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user application settings and agreements
         * @summary 
         * @param {UpdateSettingsDto} updateSettingsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerUpdate: async (updateSettingsDto: UpdateSettingsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateSettingsDto' is not null or undefined
            assertParamExists('settingsControllerUpdate', 'updateSettingsDto', updateSettingsDto)
            const localVarPath = `/api/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSettingsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get json with agreements specification
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsControllerGetAgreementsSpec(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAgreementsSpecResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerGetAgreementsSpec(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.settingsControllerGetAgreementsSpec']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get info about application settings
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsControllerGetAppSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAppSettingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerGetAppSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.settingsControllerGetAppSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user application settings and agreements
         * @summary 
         * @param {UpdateSettingsDto} updateSettingsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsControllerUpdate(updateSettingsDto: UpdateSettingsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAppSettingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerUpdate(updateSettingsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.settingsControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsApiFp(configuration)
    return {
        /**
         * Get json with agreements specification
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerGetAgreementsSpec(options?: RawAxiosRequestConfig): AxiosPromise<GetAgreementsSpecResponse> {
            return localVarFp.settingsControllerGetAgreementsSpec(options).then((request) => request(axios, basePath));
        },
        /**
         * Get info about application settings
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerGetAppSettings(options?: RawAxiosRequestConfig): AxiosPromise<GetAppSettingsResponse> {
            return localVarFp.settingsControllerGetAppSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Update user application settings and agreements
         * @summary 
         * @param {UpdateSettingsDto} updateSettingsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerUpdate(updateSettingsDto: UpdateSettingsDto, options?: RawAxiosRequestConfig): AxiosPromise<GetAppSettingsResponse> {
            return localVarFp.settingsControllerUpdate(updateSettingsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     * Get json with agreements specification
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsControllerGetAgreementsSpec(options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsControllerGetAgreementsSpec(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get info about application settings
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsControllerGetAppSettings(options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsControllerGetAppSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user application settings and agreements
     * @summary 
     * @param {UpdateSettingsDto} updateSettingsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsControllerUpdate(updateSettingsDto: UpdateSettingsDto, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsControllerUpdate(updateSettingsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SlowLogsApi - axios parameter creator
 * @export
 */
export const SlowLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get slowlog config
         * @summary 
         * @param {string} dbInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowLogControllerGetConfig: async (dbInstance: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('slowLogControllerGetConfig', 'dbInstance', dbInstance)
            const localVarPath = `/api/databases/{dbInstance}/slow-logs/config`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of slow logs
         * @summary 
         * @param {string} dbInstance 
         * @param {number} [count] Specifying the number of slow logs to fetch per node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowLogControllerGetSlowLogs: async (dbInstance: string, count?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('slowLogControllerGetSlowLogs', 'dbInstance', dbInstance)
            const localVarPath = `/api/databases/{dbInstance}/slow-logs`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clear slow logs
         * @summary 
         * @param {string} dbInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowLogControllerResetSlowLogs: async (dbInstance: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('slowLogControllerResetSlowLogs', 'dbInstance', dbInstance)
            const localVarPath = `/api/databases/{dbInstance}/slow-logs`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update slowlog config
         * @summary 
         * @param {string} dbInstance 
         * @param {UpdateSlowLogConfigDto} updateSlowLogConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowLogControllerUpdateConfig: async (dbInstance: string, updateSlowLogConfigDto: UpdateSlowLogConfigDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('slowLogControllerUpdateConfig', 'dbInstance', dbInstance)
            // verify required parameter 'updateSlowLogConfigDto' is not null or undefined
            assertParamExists('slowLogControllerUpdateConfig', 'updateSlowLogConfigDto', updateSlowLogConfigDto)
            const localVarPath = `/api/databases/{dbInstance}/slow-logs/config`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSlowLogConfigDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SlowLogsApi - functional programming interface
 * @export
 */
export const SlowLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SlowLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get slowlog config
         * @summary 
         * @param {string} dbInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slowLogControllerGetConfig(dbInstance: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlowLogConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slowLogControllerGetConfig(dbInstance, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlowLogsApi.slowLogControllerGetConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of slow logs
         * @summary 
         * @param {string} dbInstance 
         * @param {number} [count] Specifying the number of slow logs to fetch per node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slowLogControllerGetSlowLogs(dbInstance: string, count?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SlowLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slowLogControllerGetSlowLogs(dbInstance, count, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlowLogsApi.slowLogControllerGetSlowLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Clear slow logs
         * @summary 
         * @param {string} dbInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slowLogControllerResetSlowLogs(dbInstance: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slowLogControllerResetSlowLogs(dbInstance, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlowLogsApi.slowLogControllerResetSlowLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update slowlog config
         * @summary 
         * @param {string} dbInstance 
         * @param {UpdateSlowLogConfigDto} updateSlowLogConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slowLogControllerUpdateConfig(dbInstance: string, updateSlowLogConfigDto: UpdateSlowLogConfigDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SlowLogConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slowLogControllerUpdateConfig(dbInstance, updateSlowLogConfigDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlowLogsApi.slowLogControllerUpdateConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SlowLogsApi - factory interface
 * @export
 */
export const SlowLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SlowLogsApiFp(configuration)
    return {
        /**
         * Get slowlog config
         * @summary 
         * @param {string} dbInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowLogControllerGetConfig(dbInstance: string, options?: RawAxiosRequestConfig): AxiosPromise<SlowLogConfig> {
            return localVarFp.slowLogControllerGetConfig(dbInstance, options).then((request) => request(axios, basePath));
        },
        /**
         * List of slow logs
         * @summary 
         * @param {string} dbInstance 
         * @param {number} [count] Specifying the number of slow logs to fetch per node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowLogControllerGetSlowLogs(dbInstance: string, count?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<SlowLog>> {
            return localVarFp.slowLogControllerGetSlowLogs(dbInstance, count, options).then((request) => request(axios, basePath));
        },
        /**
         * Clear slow logs
         * @summary 
         * @param {string} dbInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowLogControllerResetSlowLogs(dbInstance: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.slowLogControllerResetSlowLogs(dbInstance, options).then((request) => request(axios, basePath));
        },
        /**
         * Update slowlog config
         * @summary 
         * @param {string} dbInstance 
         * @param {UpdateSlowLogConfigDto} updateSlowLogConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slowLogControllerUpdateConfig(dbInstance: string, updateSlowLogConfigDto: UpdateSlowLogConfigDto, options?: RawAxiosRequestConfig): AxiosPromise<SlowLogConfig> {
            return localVarFp.slowLogControllerUpdateConfig(dbInstance, updateSlowLogConfigDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SlowLogsApi - object-oriented interface
 * @export
 * @class SlowLogsApi
 * @extends {BaseAPI}
 */
export class SlowLogsApi extends BaseAPI {
    /**
     * Get slowlog config
     * @summary 
     * @param {string} dbInstance 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlowLogsApi
     */
    public slowLogControllerGetConfig(dbInstance: string, options?: RawAxiosRequestConfig) {
        return SlowLogsApiFp(this.configuration).slowLogControllerGetConfig(dbInstance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of slow logs
     * @summary 
     * @param {string} dbInstance 
     * @param {number} [count] Specifying the number of slow logs to fetch per node.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlowLogsApi
     */
    public slowLogControllerGetSlowLogs(dbInstance: string, count?: number, options?: RawAxiosRequestConfig) {
        return SlowLogsApiFp(this.configuration).slowLogControllerGetSlowLogs(dbInstance, count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clear slow logs
     * @summary 
     * @param {string} dbInstance 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlowLogsApi
     */
    public slowLogControllerResetSlowLogs(dbInstance: string, options?: RawAxiosRequestConfig) {
        return SlowLogsApiFp(this.configuration).slowLogControllerResetSlowLogs(dbInstance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update slowlog config
     * @summary 
     * @param {string} dbInstance 
     * @param {UpdateSlowLogConfigDto} updateSlowLogConfigDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlowLogsApi
     */
    public slowLogControllerUpdateConfig(dbInstance: string, updateSlowLogConfigDto: UpdateSlowLogConfigDto, options?: RawAxiosRequestConfig) {
        return SlowLogsApiFp(this.configuration).slowLogControllerUpdateConfig(dbInstance, updateSlowLogConfigDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TAGSApi - axios parameter creator
 * @export
 */
export const TAGSApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create tag
         * @summary 
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerCreate: async (createTagDto: CreateTagDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTagDto' is not null or undefined
            assertParamExists('tagControllerCreate', 'createTagDto', createTagDto)
            const localVarPath = `/api/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete tag
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tagControllerDelete', 'id', id)
            const localVarPath = `/api/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get tag by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tagControllerGet', 'id', id)
            const localVarPath = `/api/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get tags list
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update tag
         * @summary 
         * @param {string} id 
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerUpdate: async (id: string, updateTagDto: UpdateTagDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tagControllerUpdate', 'id', id)
            // verify required parameter 'updateTagDto' is not null or undefined
            assertParamExists('tagControllerUpdate', 'updateTagDto', updateTagDto)
            const localVarPath = `/api/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TAGSApi - functional programming interface
 * @export
 */
export const TAGSApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TAGSApiAxiosParamCreator(configuration)
    return {
        /**
         * Create tag
         * @summary 
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerCreate(createTagDto: CreateTagDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerCreate(createTagDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TAGSApi.tagControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete tag
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TAGSApi.tagControllerDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get tag by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TAGSApi.tagControllerGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get tags list
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TAGSApi.tagControllerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update tag
         * @summary 
         * @param {string} id 
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagControllerUpdate(id: string, updateTagDto: UpdateTagDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagControllerUpdate(id, updateTagDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TAGSApi.tagControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TAGSApi - factory interface
 * @export
 */
export const TAGSApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TAGSApiFp(configuration)
    return {
        /**
         * Create tag
         * @summary 
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerCreate(createTagDto: CreateTagDto, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.tagControllerCreate(createTagDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete tag
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tagControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get tag by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.tagControllerGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get tags list
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Tag>> {
            return localVarFp.tagControllerList(options).then((request) => request(axios, basePath));
        },
        /**
         * Update tag
         * @summary 
         * @param {string} id 
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerUpdate(id: string, updateTagDto: UpdateTagDto, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.tagControllerUpdate(id, updateTagDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TAGSApi - object-oriented interface
 * @export
 * @class TAGSApi
 * @extends {BaseAPI}
 */
export class TAGSApi extends BaseAPI {
    /**
     * Create tag
     * @summary 
     * @param {CreateTagDto} createTagDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TAGSApi
     */
    public tagControllerCreate(createTagDto: CreateTagDto, options?: RawAxiosRequestConfig) {
        return TAGSApiFp(this.configuration).tagControllerCreate(createTagDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete tag
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TAGSApi
     */
    public tagControllerDelete(id: string, options?: RawAxiosRequestConfig) {
        return TAGSApiFp(this.configuration).tagControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get tag by id
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TAGSApi
     */
    public tagControllerGet(id: string, options?: RawAxiosRequestConfig) {
        return TAGSApiFp(this.configuration).tagControllerGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get tags list
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TAGSApi
     */
    public tagControllerList(options?: RawAxiosRequestConfig) {
        return TAGSApiFp(this.configuration).tagControllerList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update tag
     * @summary 
     * @param {string} id 
     * @param {UpdateTagDto} updateTagDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TAGSApi
     */
    public tagControllerUpdate(id: string, updateTagDto: UpdateTagDto, options?: RawAxiosRequestConfig) {
        return TAGSApiFp(this.configuration).tagControllerUpdate(id, updateTagDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TLSCertificatesApi - axios parameter creator
 * @export
 */
export const TLSCertificatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete Ca Certificate by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caCertificateControllerDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('caCertificateControllerDelete', 'id', id)
            const localVarPath = `/api/certificates/ca/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Ca Certificate list
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caCertificateControllerList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/certificates/ca`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Client Certificate pair by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCertificateControllerDeleteClientCertificatePair: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientCertificateControllerDeleteClientCertificatePair', 'id', id)
            const localVarPath = `/api/certificates/client/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Client Certificate list
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCertificateControllerGetClientCertList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/certificates/client`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TLSCertificatesApi - functional programming interface
 * @export
 */
export const TLSCertificatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TLSCertificatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete Ca Certificate by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caCertificateControllerDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caCertificateControllerDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TLSCertificatesApi.caCertificateControllerDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Ca Certificate list
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caCertificateControllerList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaCertificate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caCertificateControllerList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TLSCertificatesApi.caCertificateControllerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Client Certificate pair by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCertificateControllerDeleteClientCertificatePair(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientCertificateControllerDeleteClientCertificatePair(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TLSCertificatesApi.clientCertificateControllerDeleteClientCertificatePair']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Client Certificate list
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCertificateControllerGetClientCertList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClientCertificate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientCertificateControllerGetClientCertList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TLSCertificatesApi.clientCertificateControllerGetClientCertList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TLSCertificatesApi - factory interface
 * @export
 */
export const TLSCertificatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TLSCertificatesApiFp(configuration)
    return {
        /**
         * Delete Ca Certificate by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caCertificateControllerDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.caCertificateControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Ca Certificate list
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caCertificateControllerList(options?: RawAxiosRequestConfig): AxiosPromise<Array<CaCertificate>> {
            return localVarFp.caCertificateControllerList(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Client Certificate pair by id
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCertificateControllerDeleteClientCertificatePair(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.clientCertificateControllerDeleteClientCertificatePair(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Client Certificate list
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCertificateControllerGetClientCertList(options?: RawAxiosRequestConfig): AxiosPromise<Array<ClientCertificate>> {
            return localVarFp.clientCertificateControllerGetClientCertList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TLSCertificatesApi - object-oriented interface
 * @export
 * @class TLSCertificatesApi
 * @extends {BaseAPI}
 */
export class TLSCertificatesApi extends BaseAPI {
    /**
     * Delete Ca Certificate by id
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TLSCertificatesApi
     */
    public caCertificateControllerDelete(id: string, options?: RawAxiosRequestConfig) {
        return TLSCertificatesApiFp(this.configuration).caCertificateControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Ca Certificate list
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TLSCertificatesApi
     */
    public caCertificateControllerList(options?: RawAxiosRequestConfig) {
        return TLSCertificatesApiFp(this.configuration).caCertificateControllerList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Client Certificate pair by id
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TLSCertificatesApi
     */
    public clientCertificateControllerDeleteClientCertificatePair(id: string, options?: RawAxiosRequestConfig) {
        return TLSCertificatesApiFp(this.configuration).clientCertificateControllerDeleteClientCertificatePair(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Client Certificate list
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TLSCertificatesApi
     */
    public clientCertificateControllerGetClientCertList(options?: RawAxiosRequestConfig) {
        return TLSCertificatesApiFp(this.configuration).clientCertificateControllerGetClientCertList(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TutorialsApi - axios parameter creator
 * @export
 */
export const TutorialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new tutorial
         * @summary 
         * @param {File} [file] ZIP archive with tutorial static files
         * @param {string} [link] External link to zip archive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTutorialControllerCreate: async (file?: File, link?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/custom-tutorials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (link !== undefined) { 
                localVarFormParams.append('link', link as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete custom tutorial and its files
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTutorialControllerDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('customTutorialControllerDelete', 'id', id)
            const localVarPath = `/api/custom-tutorials/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get global manifest for custom tutorials
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTutorialControllerGetGlobalManifest: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/custom-tutorials/manifest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TutorialsApi - functional programming interface
 * @export
 */
export const TutorialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TutorialsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new tutorial
         * @summary 
         * @param {File} [file] ZIP archive with tutorial static files
         * @param {string} [link] External link to zip archive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customTutorialControllerCreate(file?: File, link?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RootCustomTutorialManifest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customTutorialControllerCreate(file, link, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TutorialsApi.customTutorialControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete custom tutorial and its files
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customTutorialControllerDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customTutorialControllerDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TutorialsApi.customTutorialControllerDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get global manifest for custom tutorials
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customTutorialControllerGetGlobalManifest(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RootCustomTutorialManifest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customTutorialControllerGetGlobalManifest(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TutorialsApi.customTutorialControllerGetGlobalManifest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TutorialsApi - factory interface
 * @export
 */
export const TutorialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TutorialsApiFp(configuration)
    return {
        /**
         * Create new tutorial
         * @summary 
         * @param {File} [file] ZIP archive with tutorial static files
         * @param {string} [link] External link to zip archive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTutorialControllerCreate(file?: File, link?: string, options?: RawAxiosRequestConfig): AxiosPromise<RootCustomTutorialManifest> {
            return localVarFp.customTutorialControllerCreate(file, link, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete custom tutorial and its files
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTutorialControllerDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.customTutorialControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get global manifest for custom tutorials
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTutorialControllerGetGlobalManifest(options?: RawAxiosRequestConfig): AxiosPromise<RootCustomTutorialManifest> {
            return localVarFp.customTutorialControllerGetGlobalManifest(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TutorialsApi - object-oriented interface
 * @export
 * @class TutorialsApi
 * @extends {BaseAPI}
 */
export class TutorialsApi extends BaseAPI {
    /**
     * Create new tutorial
     * @summary 
     * @param {File} [file] ZIP archive with tutorial static files
     * @param {string} [link] External link to zip archive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TutorialsApi
     */
    public customTutorialControllerCreate(file?: File, link?: string, options?: RawAxiosRequestConfig) {
        return TutorialsApiFp(this.configuration).customTutorialControllerCreate(file, link, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete custom tutorial and its files
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TutorialsApi
     */
    public customTutorialControllerDelete(id: string, options?: RawAxiosRequestConfig) {
        return TutorialsApiFp(this.configuration).customTutorialControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get global manifest for custom tutorials
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TutorialsApi
     */
    public customTutorialControllerGetGlobalManifest(options?: RawAxiosRequestConfig) {
        return TutorialsApiFp(this.configuration).customTutorialControllerGetGlobalManifest(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkbenchApi - axios parameter creator
 * @export
 */
export const WorkbenchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete command execution
         * @summary 
         * @param {string} id 
         * @param {string} dbInstance Database instance id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workbenchControllerDeleteCommandExecution: async (id: string, dbInstance: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workbenchControllerDeleteCommandExecution', 'id', id)
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('workbenchControllerDeleteCommandExecution', 'dbInstance', dbInstance)
            const localVarPath = `/api/databases/{dbInstance}/workbench/command-executions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete command executions
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {CommandExecutionFilter} commandExecutionFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workbenchControllerDeleteCommandExecutions: async (dbInstance: string, commandExecutionFilter: CommandExecutionFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('workbenchControllerDeleteCommandExecutions', 'dbInstance', dbInstance)
            // verify required parameter 'commandExecutionFilter' is not null or undefined
            assertParamExists('workbenchControllerDeleteCommandExecutions', 'commandExecutionFilter', commandExecutionFilter)
            const localVarPath = `/api/databases/{dbInstance}/workbench/command-executions`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commandExecutionFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get command execution details
         * @summary 
         * @param {string} id 
         * @param {string} dbInstance Database instance id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workbenchControllerGetCommandExecution: async (id: string, dbInstance: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workbenchControllerGetCommandExecution', 'id', id)
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('workbenchControllerGetCommandExecution', 'dbInstance', dbInstance)
            const localVarPath = `/api/databases/{dbInstance}/workbench/command-executions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of command executions
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {WorkbenchControllerListCommandExecutionsTypeEnum} [type] Command execution type. Used to distinguish between search and workbench
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workbenchControllerListCommandExecutions: async (dbInstance: string, type?: WorkbenchControllerListCommandExecutionsTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('workbenchControllerListCommandExecutions', 'dbInstance', dbInstance)
            const localVarPath = `/api/databases/{dbInstance}/workbench/command-executions`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send Redis Batch Commands from the Workbench
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {CreateCommandExecutionsDto} createCommandExecutionsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workbenchControllerSendCommands: async (dbInstance: string, createCommandExecutionsDto: CreateCommandExecutionsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('workbenchControllerSendCommands', 'dbInstance', dbInstance)
            // verify required parameter 'createCommandExecutionsDto' is not null or undefined
            assertParamExists('workbenchControllerSendCommands', 'createCommandExecutionsDto', createCommandExecutionsDto)
            const localVarPath = `/api/databases/{dbInstance}/workbench/command-executions`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCommandExecutionsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkbenchApi - functional programming interface
 * @export
 */
export const WorkbenchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkbenchApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete command execution
         * @summary 
         * @param {string} id 
         * @param {string} dbInstance Database instance id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workbenchControllerDeleteCommandExecution(id: string, dbInstance: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workbenchControllerDeleteCommandExecution(id, dbInstance, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkbenchApi.workbenchControllerDeleteCommandExecution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete command executions
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {CommandExecutionFilter} commandExecutionFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workbenchControllerDeleteCommandExecutions(dbInstance: string, commandExecutionFilter: CommandExecutionFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workbenchControllerDeleteCommandExecutions(dbInstance, commandExecutionFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkbenchApi.workbenchControllerDeleteCommandExecutions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get command execution details
         * @summary 
         * @param {string} id 
         * @param {string} dbInstance Database instance id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workbenchControllerGetCommandExecution(id: string, dbInstance: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandExecution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workbenchControllerGetCommandExecution(id, dbInstance, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkbenchApi.workbenchControllerGetCommandExecution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of command executions
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {WorkbenchControllerListCommandExecutionsTypeEnum} [type] Command execution type. Used to distinguish between search and workbench
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workbenchControllerListCommandExecutions(dbInstance: string, type?: WorkbenchControllerListCommandExecutionsTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ShortCommandExecution>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workbenchControllerListCommandExecutions(dbInstance, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkbenchApi.workbenchControllerListCommandExecutions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send Redis Batch Commands from the Workbench
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {CreateCommandExecutionsDto} createCommandExecutionsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workbenchControllerSendCommands(dbInstance: string, createCommandExecutionsDto: CreateCommandExecutionsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandExecution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workbenchControllerSendCommands(dbInstance, createCommandExecutionsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkbenchApi.workbenchControllerSendCommands']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkbenchApi - factory interface
 * @export
 */
export const WorkbenchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkbenchApiFp(configuration)
    return {
        /**
         * Delete command execution
         * @summary 
         * @param {string} id 
         * @param {string} dbInstance Database instance id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workbenchControllerDeleteCommandExecution(id: string, dbInstance: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.workbenchControllerDeleteCommandExecution(id, dbInstance, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete command executions
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {CommandExecutionFilter} commandExecutionFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workbenchControllerDeleteCommandExecutions(dbInstance: string, commandExecutionFilter: CommandExecutionFilter, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.workbenchControllerDeleteCommandExecutions(dbInstance, commandExecutionFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get command execution details
         * @summary 
         * @param {string} id 
         * @param {string} dbInstance Database instance id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workbenchControllerGetCommandExecution(id: string, dbInstance: string, options?: RawAxiosRequestConfig): AxiosPromise<CommandExecution> {
            return localVarFp.workbenchControllerGetCommandExecution(id, dbInstance, options).then((request) => request(axios, basePath));
        },
        /**
         * List of command executions
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {WorkbenchControllerListCommandExecutionsTypeEnum} [type] Command execution type. Used to distinguish between search and workbench
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workbenchControllerListCommandExecutions(dbInstance: string, type?: WorkbenchControllerListCommandExecutionsTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<ShortCommandExecution>> {
            return localVarFp.workbenchControllerListCommandExecutions(dbInstance, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Send Redis Batch Commands from the Workbench
         * @summary 
         * @param {string} dbInstance Database instance id.
         * @param {CreateCommandExecutionsDto} createCommandExecutionsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workbenchControllerSendCommands(dbInstance: string, createCommandExecutionsDto: CreateCommandExecutionsDto, options?: RawAxiosRequestConfig): AxiosPromise<CommandExecution> {
            return localVarFp.workbenchControllerSendCommands(dbInstance, createCommandExecutionsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkbenchApi - object-oriented interface
 * @export
 * @class WorkbenchApi
 * @extends {BaseAPI}
 */
export class WorkbenchApi extends BaseAPI {
    /**
     * Delete command execution
     * @summary 
     * @param {string} id 
     * @param {string} dbInstance Database instance id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkbenchApi
     */
    public workbenchControllerDeleteCommandExecution(id: string, dbInstance: string, options?: RawAxiosRequestConfig) {
        return WorkbenchApiFp(this.configuration).workbenchControllerDeleteCommandExecution(id, dbInstance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete command executions
     * @summary 
     * @param {string} dbInstance Database instance id.
     * @param {CommandExecutionFilter} commandExecutionFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkbenchApi
     */
    public workbenchControllerDeleteCommandExecutions(dbInstance: string, commandExecutionFilter: CommandExecutionFilter, options?: RawAxiosRequestConfig) {
        return WorkbenchApiFp(this.configuration).workbenchControllerDeleteCommandExecutions(dbInstance, commandExecutionFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get command execution details
     * @summary 
     * @param {string} id 
     * @param {string} dbInstance Database instance id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkbenchApi
     */
    public workbenchControllerGetCommandExecution(id: string, dbInstance: string, options?: RawAxiosRequestConfig) {
        return WorkbenchApiFp(this.configuration).workbenchControllerGetCommandExecution(id, dbInstance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of command executions
     * @summary 
     * @param {string} dbInstance Database instance id.
     * @param {WorkbenchControllerListCommandExecutionsTypeEnum} [type] Command execution type. Used to distinguish between search and workbench
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkbenchApi
     */
    public workbenchControllerListCommandExecutions(dbInstance: string, type?: WorkbenchControllerListCommandExecutionsTypeEnum, options?: RawAxiosRequestConfig) {
        return WorkbenchApiFp(this.configuration).workbenchControllerListCommandExecutions(dbInstance, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send Redis Batch Commands from the Workbench
     * @summary 
     * @param {string} dbInstance Database instance id.
     * @param {CreateCommandExecutionsDto} createCommandExecutionsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkbenchApi
     */
    public workbenchControllerSendCommands(dbInstance: string, createCommandExecutionsDto: CreateCommandExecutionsDto, options?: RawAxiosRequestConfig) {
        return WorkbenchApiFp(this.configuration).workbenchControllerSendCommands(dbInstance, createCommandExecutionsDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const WorkbenchControllerListCommandExecutionsTypeEnum = {
    Workbench: 'WORKBENCH',
    Search: 'SEARCH'
} as const;
export type WorkbenchControllerListCommandExecutionsTypeEnum = typeof WorkbenchControllerListCommandExecutionsTypeEnum[keyof typeof WorkbenchControllerListCommandExecutionsTypeEnum];


